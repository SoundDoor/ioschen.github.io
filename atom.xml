<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://ioschen.com/"/>
  <updated>2015-11-02T07:20:12.000Z</updated>
  <id>http://ioschen.com/</id>
  
  <author>
    <name><![CDATA[Whale Chen]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://ioschen.com/2015/11/02/hello-world/"/>
    <id>http://ioschen.com/2015/11/02/hello-world/</id>
    <published>2015-11-02T07:20:12.000Z</published>
    <updated>2015-11-02T07:20:12.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html">Deployment</a></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[test]]></title>
    <link href="http://ioschen.com/2015/11/02/test/"/>
    <id>http://ioschen.com/2015/11/02/test/</id>
    <published>2015-11-02T06:45:32.000Z</published>
    <updated>2015-11-02T07:26:02.000Z</updated>
    <content type="html"><![CDATA[<p>asdfdfa</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>asdfdfa</p>]]>
    
    </summary>
    
      <category term="js" scheme="http://ioschen.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift获取WIFI的SSID 和Swift获取IP]]></title>
    <link href="http://ioschen.com/2015/08/17/swiftssid/"/>
    <id>http://ioschen.com/2015/08/17/swiftssid/</id>
    <published>2015-08-17T07:42:45.000Z</published>
    <updated>2015-08-17T07:50:52.000Z</updated>
    <content type="html"><![CDATA[<p>##WIFI的SSID</p>
<p>先导入 import SystemConfiguration.CaptiveNetwork<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getSSID</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> interfaces: <span class="type">CFArray</span>! = <span class="type">CNCopySupportedInterfaces</span>()?.takeRetainedValue()</span><br><span class="line">        <span class="keyword">if</span> interfaces == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> if0: <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;? = <span class="type">CFArrayGetValueAtIndex</span>(interfaces, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> if0 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> interfaceName: <span class="type">CFStringRef</span> = <span class="built_in">unsafeBitCast</span>(if0!, <span class="type">CFStringRef</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> dictionary = <span class="type">CNCopyCurrentNetworkInfo</span>(interfaceName)?.takeRetainedValue() <span class="keyword">as</span> <span class="type">NSDictionary</span>?</span><br><span class="line">        <span class="keyword">if</span> dictionary == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dictionary?[kCNNetworkInfoKeySSID <span class="keyword">as</span> <span class="type">String</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>##Swift获取IP<br>先在桥接文件中加入  <code>#include &lt;ifaddrs.h&gt;</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return IP address of WiFi interface (en0) as a String, or `nil`</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getWiFiAddress</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> address : <span class="type">String</span>?</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Get list of all interfaces on the local machine:</span></span><br><span class="line">        <span class="keyword">var</span> ifaddr : <span class="type">UnsafeMutablePointer</span>&lt;ifaddrs&gt; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> getifaddrs(&amp;ifaddr) == <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// For each interface ...</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> ptr = ifaddr; ptr != <span class="literal">nil</span>; ptr = ptr.memory.ifa_next) &#123;</span><br><span class="line">                <span class="keyword">let</span> interface = ptr.memory</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Check for IPv4 or IPv6 interface:</span></span><br><span class="line">                <span class="keyword">let</span> addrFamily = interface.ifa_addr.memory.sa_family</span><br><span class="line">                <span class="keyword">if</span> addrFamily == <span class="type">UInt8</span>(<span class="type">AF_INET</span>) || addrFamily == <span class="type">UInt8</span>(<span class="type">AF_INET6</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Check interface name:</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> name = <span class="type">String</span>.fromCString(interface.ifa_name) <span class="keyword">where</span> name == <span class="string">"en0"</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Convert interface address to a human readable string:</span></span><br><span class="line">                        <span class="keyword">var</span> addr = interface.ifa_addr.memory</span><br><span class="line">                        <span class="keyword">var</span> hostname = [<span class="type">CChar</span>](<span class="built_in">count</span>: <span class="type">Int</span>(<span class="type">NI_MAXHOST</span>), repeatedValue: <span class="number">0</span>)</span><br><span class="line">                        getnameinfo(&amp;addr, socklen_t(interface.ifa_addr.memory.sa_len),</span><br><span class="line">                            &amp;hostname, socklen_t(hostname.<span class="built_in">count</span>),</span><br><span class="line">                            <span class="literal">nil</span>, socklen_t(<span class="number">0</span>), <span class="type">NI_NUMERICHOST</span>)</span><br><span class="line">                        address = <span class="type">String</span>.fromCString(hostname)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            freeifaddrs(ifaddr)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> address</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>##WIFI的SSID</p>
<p>先导入 import SystemConfiguration.CaptiveNetwork<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getSSID</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> interfaces: <span class="type">CFArray</span>! = <span class="type">CNCopySupportedInterfaces</span>()?.takeRetainedValue()</span><br><span class="line">        <span class="keyword">if</span> interfaces == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> if0: <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;? = <span class="type">CFArrayGetValueAtIndex</span>(interfaces, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> if0 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> interfaceName: <span class="type">CFStringRef</span> = <span class="built_in">unsafeBitCast</span>(if0!, <span class="type">CFStringRef</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> dictionary = <span class="type">CNCopyCurrentNetworkInfo</span>(interfaceName)?.takeRetainedValue() <span class="keyword">as</span> <span class="type">NSDictionary</span>?</span><br><span class="line">        <span class="keyword">if</span> dictionary == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dictionary?[kCNNetworkInfoKeySSID <span class="keyword">as</span> <span class="type">String</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>##Swift获取IP<br>先在桥接文件中加入  <code>#include &lt;ifaddrs.h&gt;</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return IP address of WiFi interface (en0) as a String, or `nil`</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getWiFiAddress</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> address : <span class="type">String</span>?</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Get list of all interfaces on the local machine:</span></span><br><span class="line">        <span class="keyword">var</span> ifaddr : <span class="type">UnsafeMutablePointer</span>&lt;ifaddrs&gt; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> getifaddrs(&amp;ifaddr) == <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// For each interface ...</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> ptr = ifaddr; ptr != <span class="literal">nil</span>; ptr = ptr.memory.ifa_next) &#123;</span><br><span class="line">                <span class="keyword">let</span> interface = ptr.memory</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Check for IPv4 or IPv6 interface:</span></span><br><span class="line">                <span class="keyword">let</span> addrFamily = interface.ifa_addr.memory.sa_family</span><br><span class="line">                <span class="keyword">if</span> addrFamily == <span class="type">UInt8</span>(<span class="type">AF_INET</span>) || addrFamily == <span class="type">UInt8</span>(<span class="type">AF_INET6</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Check interface name:</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> name = <span class="type">String</span>.fromCString(interface.ifa_name) <span class="keyword">where</span> name == <span class="string">"en0"</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Convert interface address to a human readable string:</span></span><br><span class="line">                        <span class="keyword">var</span> addr = interface.ifa_addr.memory</span><br><span class="line">                        <span class="keyword">var</span> hostname = [<span class="type">CChar</span>](<span class="built_in">count</span>: <span class="type">Int</span>(<span class="type">NI_MAXHOST</span>), repeatedValue: <span class="number">0</span>)</span><br><span class="line">                        getnameinfo(&amp;addr, socklen_t(interface.ifa_addr.memory.sa_len),</span><br><span class="line">                            &amp;hostname, socklen_t(hostname.<span class="built_in">count</span>),</span><br><span class="line">                            <span class="literal">nil</span>, socklen_t(<span class="number">0</span>), <span class="type">NI_NUMERICHOST</span>)</span><br><span class="line">                        address = <span class="type">String</span>.fromCString(hostname)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            freeifaddrs(ifaddr)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> address</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="swift ssid" scheme="http://ioschen.com/tags/swift-ssid/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[think]]></title>
    <link href="http://ioschen.com/2015/06/04/think/"/>
    <id>http://ioschen.com/2015/06/04/think/</id>
    <published>2015-06-03T16:36:38.000Z</published>
    <updated>2015-06-04T00:33:39.000Z</updated>
    <content type="html"><![CDATA[<p>误导，【英语】 Mislead 【基本解释】指导做 错误的事;错误的指导。</p>
<h1 id="缘由">缘由</h1><p>今天和小杭的聊天<br>本来不想发表这篇文章，因为这样可能会让有些人对我的世界观以及想法产生误解</p>
<h1 id="过去的事情对今天产生影响">过去的事情对今天产生影响</h1><p>人们总是替自己的言行找这样那样的借口<br>说别人以前有自己的自由，自己的生活方式，不应该去过问。<br>甚至拿出你的生命和家境由父母决定，你是没法选择的来做类推以期望达到证明自己的观点是正确的。<br>可笑的是这个根本不存在因果关系，但是还是会有很多人回去相信</p>
<h2 id="手段：以偏概全，只说需要说的">手段：以偏概全，只说需要说的</h2><p>希特勒是个可怜的艺术家<br>关于希特勒，可以这样来形容：有个人酷爱艺术，通过合法竞选高票当上总理，任上让德国经济腾飞，结果被逼自杀了。</p>
<p>看了这段话，你大概不会认为这个总理是嗜血成性的希特勒。</p>
<h2 id="切入：以公众情感作为切入点">切入：以公众情感作为切入点</h2><p>要确保能误导成功，首先要让大部分人进入到非理性状态，要进入到非理性状态，最简单的做法是让读者愤怒起来。以柴静的视频为例，她先说到她的女儿，用一些表述手法让公众认为女儿患上肿瘤与雾霾是因果关系，随之表达愤怒。作为情感动物，人们在这种时候会与视频产生共鸣，甚至心里可能会想：「妈的，就是这雾霾让我家的小孩也老咳嗽的。」<br>儿童<br>以儿童的健康等原因，作为文章的切入，容易让读者进入到非理性状态。<br>弱势群体<br>老、弱、病、残、被性别其实的妇女，被性取向歧视的个人或群体，都是很好的作为情感切入的对象。</p>
<h2 id="手段：含糊其词引用专业词汇">手段：含糊其词引用专业词汇</h2><p>记者也好，写作者也好，有时为了便于读者理解，会把复杂的概念简单化。在简单化的过程里，也是很容易进行误导的过程，因为你可以简化掉那些不支持你观点的论据，剩下你需要的。</p>
<h2 id="手段：误导因果关联关系">手段：误导因果关联关系</h2><p>为了误导，我们需要捏造因果关系。之所以称之为捏造，是因为我们无法确切证明两者之间有明确的因果关系。</p>
<p>柴静：让你觉得我女儿的肿瘤与雾霾有关</p>
<p>没有证据表明她女儿的肿瘤与雾霾有关， 柴静也没有直接说孩子是因为雾霾患上肿瘤，但她懂得如何让媒体往这个方向去传播，《柴静离职自费百万拍雾霾纪录片 因女儿未出世患肿瘤》这篇新闻早早在网上传播了起来。</p>
<p>为了达到这样的误导效果，柴静在视频开始中说，「生活在一年竟有175天污染的北京，害怕女儿有一天会问我什么是蓝天、为什么老把我关在家里，加上全社会对空气污染问题也越来越关心，职业训练和母亲本能都让我觉得应该回答这些问题：雾霾是什么？从哪儿来？该怎么办？」</p>
<p>柴静都这么说了，结合她女儿患肿瘤的事实，就很容易误导媒体往这个方向去传播，于是就误导成功了。<br>我帮我哥们找到了对象<br>以前我写可能吧的时候，一个朋友让我在博客上帮他发征婚文章，我发了之后他收了不少邮件，现在他已经结婚当爸了，他特别感谢我当年帮他发征婚帖。<br>吃糖的孩子聪明<br>一项研究发现，经常吃糖的小孩，智商会比其它小孩高出5%以上。<br>GoPro 导致舒马赫一直昏迷<br>一位知情人士表示，舒马赫在滑雪时头戴 GoPro 相机，沉重的撞击让他昏迷一年多至今仍未苏醒，消息披露后， GoPro 股价当天跌了将近10%。<br>手段：以相关性误导因果关系<br>与捏造因果关系不同，捏造对象很多时候是没有关联性的。为了达到更好的误导效果，有时需要通过对象的相关性，来<br>柴静：PM2.5让死亡率增高</p>
<p>在视频的12:39处，柴静引用了几条曲线说明：当PM2.5增多时，人类的死亡率随之增高。实际上，这两者可能有相关性，但并不是因果关系。这里面的因素可以很多，比如PM2.5增多的地方，医疗水平也会随之提高，死亡率的提高，并不一定与PM2.5有直接关联。</p>
<p>但这样的表述，可以起到误导因果关系的作用，值得借鉴。<br>激素替代疗法有预防冠心病的效果<br>以前有这么一种说法：流行病学研究曾发现，接受激素替代疗法的妇女，发生冠心病的比率较一般人低。</p>
<p>但实际上，接受激素替代疗法的妇女社会地位多半较高，她们通常有较好的饮食、运动习惯，因而比较不容易发生冠心病。<br>天蝎座的人容易成功<br>中国互联网巨头的生日分别为：马云 1964年10月15日，李彦宏 1968年11月17日，马化腾 1971年10月29日，丁磊 1971年10月10日。都是天蝎座。<br>因为 Google，我哥们上了黄网<br>还记得多年前的大学生「高也」么？</p>
<p>央视在采访他时，让他说了这么一段话：就我一个同学吧，他以前就是青少年比较好奇这些东西，他就去点那些黄色网站什么的。然后就搞到那段时间心神不宁，然后后来国家打击黄色网站了，他就没上，那段时间就好了。结果后来他又发现通过Google这些用户比较多的搜索引擎可以打开这些网址，然后又进入了这些黄色网站，Google里面的链接特别多，然后就导致他又反复了。<br>手段：捏造不便查证的数据<br>一般有这几种做法。<br>柴静：捏在1970-1998年的统计数据</p>
<p>柴静分享了一份来自加洲空气质量管理局的数据，从1970年到2012年 PM2.5 的变化曲线，但如果我们从官网里查找这些数据，会发现，1998年之前的数据是没有记录的，那么，1970-1998的数据，就是捏造。</p>
<p>但是，大部分公众并不会去追究这些数据的真实性，因为这条曲线，符合他们的非理性认知。<br>90%的真实加上10%的造假<br>其实如果你写的内容有90%是真实或符合大众的心理期待的，那么，你可以有10%的造假，这些造假大部分是不会去深究的，这时你就误导成功了。<br>机构研究表示<br>有些时候，写文章时，用这些短语会提高文章的权威性，公众一般不会去深究，也无法查证：</p>
<p><em>机构研究表明
</em>权威机构正视<br>*美国一项报告指出<br>在查证了大量的论文后……<br>这种说法，也是一种捏造不便查证的数据的方式。<br>How to：基本写作流程<br>首先确定结论<br>这与探索性的文章写法是相反的。要误导公众，你在搜集资料之前，就应该确定结论，而不是在寻找大量的资料后，用分析的方法确定结论。<br>寻找支持结论的论据<br>论据分为搜集的资料以及采访对象的口述，而对于口述的文字，有时需要用到断章取义的方式来支持文章的论点。<br>寻找支持结论的数据<br>人们对数字都很敏感，这种敏感性显示在爱看、爱说。一个人说了一连串的数字，不管真实性如何，大部分人都会认为他是「有过研究的」。<br>对不支持结论的论据，瓦解其关联性或不提及<br>不提及当然是最好的，但有时不得不提及，那么就需要瓦解它们的关联性。所谓的瓦解，就是故意只说部分的事实，来切断论据与结论的关联性。<br>尽量多地在文章中引入个人感受，激起读者的愤怒或强烈的情感<br>以偏概全地制造不相关的因果关系</p>
<p>大可<br>1、信任变得太脆弱，站队成了主流。<br>2、过去的两个月，我抑郁了。<br>3、这两句都是真的，但没有完全正相关的因果关系。</p>
<p>先断章取义截图视频中的某一个画面，基于能看到的画面和字幕，顺序得出一个柴静不够严谨的结论，将其他切实存在误导的报道和理论放在下面进行类比，引导大家得出“看吧就是那招，你们还没有发现规律吗？”<br>但问题是，这些事件是独立的，很大程度上跟柴静得出结论的方式并不相同，他们的不靠谱，并不影响柴静的结论。重点最根本就是，一开始他自己得出的结论就是以偏概全的<br>大众会被误导的原因多是他们懒于查证，不会独立思考。</p>
<p>从某种意义上来说，营销广告就是欺骗消费者花钱，演讲也是为了感染听众，传递自己的表达。基于如此，［误导］还是必要的！</p>
<p>其实吧，如果你看一件东西或者被别人的一些话击中，最后引起共鸣，误导或许就在里面……再替作者重申一下，误导，真的不是贬义词，只是给你带入了一个环境。<br>不过说实在的，穹顶看完之后总觉得有点儿言过了，太严谨的逻辑加上一边倒的结论，引导性的确不小，具体感受请脱离情景来看</p>
<p>只要一个人，一个群体，在公开场所讲话，宣传，都很少能不“误导公众”。但这并不重要，重要的是每一个公众都应该养成独立判断独立见解的能力，这样就无所谓“误导”不误导之说了。当然，柴静的纪录片在某些程度上是具有积极作用的，她至少激起了公众对于治理污染的热情与信心。我们没有权利只知抱怨不知改变，柴静用她的方式，不论完美与否，与污染作出了抗争，相信这篇轻单也一样。</p>
<p>按：无论这个纪录片是要干什么，但最起码的要求是事实和数据要真实正确。数据的误差固然不可避免，但是如果是故意的造假，那么就一定要问一下，为什么要故意造假？</p>
<p>无论是自然科学还是社会科学，一篇文章有一个数据故意造假，就已经完全失去了进一步讨论的意义。</p>
<p>用了大量的数据和资料来支撑她的结论，我一般习惯看数据都是看paper,还不太习惯看文科生摆弄些她自己都不懂的东西，我必须承认她的勇气，但是同时我也有点气愤，因为错误造假的数据对大众的影响比煽情的鼓动来的更大。看着那一串串高大上的NASA, 技术统计局，国家监测局，大家都觉得这是多么”严谨的”调查研究啊！ 本人正好博士论文与emission有点关系，看着看着觉得有点不对，查了查资料，发觉几乎每个数据都有问题。实在是有点忍不住了。</p>
<p>以下是纯技术讨论分割线，我都附上详细的引用资料，绝对比柴小姐专门唬人的大title来得详细，欢迎理性讨论。</p>
<p>【1】6：10 有意混淆雾霾和PM2.5</p>
<p>她问雾霾是什么？然后一下子转到PM2.5, smog不等于 PM2.5好吧，smog中有CO, Pb, NOx, PM, 还有SO2.怎么逻辑上一下子就套换了呢 (Smog and Particulates:Pollutant Descriptions)</p>
<p>【2-4】6：30 伪造采样结果</p>
<p>我注意到她的这款采样仪， 是LIbra Buck pump, 看样子是LP4的pump, 这个pump的工作时常是8小时左右，怎么可以采样24小时？ 恩，她应该是背了好几个大电池吧，不过我没见着，而且额外的电池也不是标配 (<a href="http://www.buckservice.com/manuals/Libramanua%20L-4.pdf" target="_blank" rel="external">http://www.buckservice.com/manuals/Libramanua%20L-4.pdf</a>) LP5是可以工作20个小时的，不过她的型号不是LP5的。￼</p>
<p>你能告诉我你知道采样膜本身应该是什么颜色的吗？？你知不知道是PVC和MCE材料的？大部分黑色的是吸附的碳吧，碳本身的毒性不大，哦，这是不是又和你研究结果的大部分是致癌物矛盾了？</p>
<p>￼让我来告诉你实验该怎么做吧， 采样仪的测试范围和灵敏度数据要有吧，空气的湿度和风向条件要有吧，采样仪的流量数据要有吧，什么都没有就敢上数据，数据就是垃圾。(说句老实话我根本不相信filter会黑成那样，24小时，污染再大，顶多是灰色，我实验室放了7年的filter都没有那么黑，弄得太黑亮了，真的。）</p>
<p>【5】8：40 对图片进行裁剪和后期加工</p>
<p>这个是柴小姐NASA的碳密度图，这个数据好像很神秘，其实他是这样的。</p>
<p>SVS: AtmosphericBlack Carbon Density (id 3668)</p>
<p>￼这个是官方图，怎么样？我截的是不是看上去没有那么恐怖？ 因为这个图是8-11月的数据，所以她可以随意截出最槽糕的图片，甚至人为调亮度，既然都是网上资源，干吗不直接连网络而要截图片？因为图片是可以操作的。实际上，大部分发展中国家，东南亚，非洲，一些南美国家，都差不多。</p>
<p>￼</p>
<p>【6】12:41 编造并不存在的因果关系</p>
<p>这个是最吐嘈的地方， 看到这个数据，我的早饭都喷出来了，来，先上图看看。</p>
<p>￼￼￼看清楚了吗？？图的横坐标是年份，纵坐标是各种死亡率。你能告诉我和PM2.5有一毛钱关系吗吗？ PM2.5的数据在哪里啊？你不要欺负我看不懂数据图啊，尤其这个“复杂”的数据图还有三个销魂的多项式，放在右边。我懒得截图了，不过我随便看了一下，如果X=0的话，Y应该是负的，而我随便代一个X的数据，Y是一个巨大的数字，根本不在图表显示之类。感兴趣的话可以自己做线性拟合。柴小姐太入戏了，我做学生的时候导师常教导我说，自己不是很明白的图表不要去误导人，看来不同人的职业操守是不一样的。</p>
<p>【7】改变数据口径形成误导印象</p>
<p>这个是全国的PM2.5来源，我看着不对，因为PM2.5来源复杂，这个图有点把问题太简单话了，我知道，简单的东西比较容易发挥，因为这时候的攻击对象是煤。</p>
<p>￼然后接下来，她又扔出来一张图，是北京PM2.5的来源，现在这个数据显示：31.1%来自机动车</p>
<p>￼同学门要问了，为啥这附图不把燃煤+燃油放在一起呢？ 因为柴小姐要讨论汽油了啊！放一起不就显示不出汽油排放的害处了吗！所以数据的“处理”是可以根据需要来玩的。当然，北京的数据我是有的（R. Zhang et al.: Chemical characterization and sourceapportionment of PM2.5 in Beijing）这篇文章分析得很详尽，关于污染源也按照不同季节区分了，事实上，机动车的污染并没有那么严重。我就是不喜欢为了自己的论点来manipulate数据，很恶俗。￼</p>
<p>【8】24.06 篡改资料的背景和时间</p>
<p>全球化石能源燃烧强度表<br>￼首先，你可以告诉我这是全球吗， 吗？？你不要欺负我没学过地理啊！南半球呢？这个图说真的我不是很懂，什么叫燃烧强度？怎么测啊？ 不过我稍微转个弯想想，她们是想说二氧化碳的排放吧，因为大部分能源燃烧排放的是CO2, 于是我找到了下面这张图。</p>
<p>￼这个确实是NASA2014年公布的CO2 emission的资料（Both Beautiful and Disturbing, a New NASA Visualization Shows CarbonDioxide Emissions Swirling Around the World）不过这个图明明写的是亚洲和喜马拉雅地区。还有这个图是超级计算机模拟出来的，是个visualization，不是真实数据，虽然是NASA2014年放出来的，但是模拟的是2005-2007的情况，也是为了响应中美对于温室气体排放控制协议。柴小姐这样随便串改资料背景，为自己所用，还堂而皇之的拿出来show,我真是佩服。</p>
<p>【9】更恶劣的：直接伪造数据</p>
<p>接下来，柴小姐给大家普及了一个时髦的名词，叫蒸汽压。也就是Vaporpressure. 看着红外镜头下的汽油蒸发物是不是很酷的东西？好吧，不懂vapor pressure的人自己自行补课吧，我要说的是数据。￼</p>
<p>柴小姐数据常常是信口就来，我该佩服她博学多才呢还是记忆力好呢。这个1升等于多少克的概念是不是很熟悉？学过中学物理的都会算吧。</p>
<p>PV=nRT,n=PV/RT=(0.5X1)/(8.3X298) m=nM=0.02g</p>
<p>不是0.02g吗，怎么是1.5g?</p>
<p>注意： 我用的pressure是她表格里的50Kpa, T是室温，M是105.</p>
<p><a href="http://www.methanol.org/energy/resources/alternative-fuel/alt-fuel-properties.aspx" target="_blank" rel="external">http://www.methanol.org/energy/resources/alternative-fuel/alt-fuel-properties.aspx</a></p>
<p>接下来注意</p>
<p>￼越来越入戏了。</p>
<p>请看标准的汽车尾气排放数据，就算是高标准的美国，每加仑CO2的排放（还不是全部尾气哦）就是8.8kg per gallon, 1gallon是3。78升，也就是排放33g的二氧化碳。</p>
<p>你是要告诉我1.5g比33g 多吗？？？</p>
<p><a href="https://www.chargepoint.com/files/420f05001.pdf" target="_blank" rel="external">https://www.chargepoint.com/files/420f05001.pdf</a></p>
<p>【10】直接在数据后面加两个零！！！</p>
<p>这个时候我已经不想继续看下去了。一般来说在学术界，你要一个数据错误，造假，manipulate.你的reputation就没了，因为你就是这个水平。柴小姐这个错误百出的PPT还是越发来劲，最后再补一个吧。凑个整数（其实到处嘈点还很多…)</p>
<p>￼这个加洲的数据，号称来自空气质量管理局。好，请看加州官网的数据。他是这么写的</p>
<p>1970, CA’s populationreached 20 million people. Total registered vehicles exceeded 12 million andvMT was 110 billion. Cumulative CA vehicle emissions for NOx and HCs were 1.6million tons/year.</p>
<p>Key Events in theHistory or Air Quality in California</p>
<p>柴小姐右边是VMT ，也就是vehicle mileage traveled. (一年的里程数） 那么1970年是110billion,</p>
<p>1billion=1000million,110=110,000million. 请数下，是4个零。 再看柴的图表， 1970年对应的是1000000，我数了好几篇，就是6个零。白白的多了10倍！！</p>
<p>为嘛呀， 这个数据不用造假啊？ 也不影响她的PPT的说教。我想了一下，觉得这个应该是水平问题。我想看看PM2.5的数据，结果我得出来的是</p>
<p>￼原来这个数据1999才有，至于她们怎么拿到1970-1999的，大家就自行脑补好了。</p>
<p>最后，我不评价她的观点，但是她敢拿假数据说话，还一定要把数据挂个官方的大牌子给自己做装饰，我看一次打一次。如今网络发达了，屁都不懂的人也可以google个事是而非的东西装点门面，大家在这方面还是要多看看专家的观点，毕竟他们受过严格的科学训练，有着严谨的操守，而专业煽情的人，也应该专注在煽情上。</p>
<p>以下转自四月网网友张帅 <a href="http://www.m4.cn/opinion/2015-03/1265041.shtml" target="_blank" rel="external">http://www.m4.cn/opinion/2015-03/1265041.shtml</a></p>
<p>【11】3%＝一半？</p>
<p>我承认这个表述当时令我非常震惊，我从来没想到轮船的耗油量占到总石油消耗的一半，至于是不是失控当时还没来得及想。</p>
<p>查下来的实际数字是轮船用油占燃料油的比例接近一半（47%），而燃料油占总油量消耗量的比例是6.6%，也就是说，船舶运输占石油消耗的比例是3%，这和一半差太多了吧。再怎么考虑节目效果也不能把3%误导成一半。</p>
<p>【12】故意混淆经济可采储量、技术可采储量和地质储量</p>
<p>“天然气在中国无法大量开采的原因是中石化的垄断，只要开放就可以解决？举例：9000亿立方米可采储量，只开采了1000亿立方米，根本原因是：70%资源被中石油垄断。”</p>
<p>垄断问题后面讲，首先要说的是柴静的团队没搞清楚产量、经济可采储量、技术可采储量和地质储量的关系。</p>
<p>我也举个例子，全球油气剩余技术可采资源量高达6000亿吨和810万亿立方米，但是2014年油气产量仅为41.5亿吨和3.57万亿立方米。这也是因为全球石油巨头不开放市场导致的？</p>
<p>另外与其他天然气大国相比，我国油气发现和开采成本不断攀升，截止2013年底，我国天然气井日均产量不到3万立方米，低于1万立方米的占一半。如果真的把所有的技术可采储量都开采了，大家估计就会骂中石化败家子，搞得企业亏损。</p>
<p>【13】故意回避有关事实</p>
<p>“伦敦的经验告诉我们，要减少雾霾必须降低煤炭消耗量增加天然气用量，英国就是这样变好的，所以我们也要大幅提高天然气比例。”</p>
<p>我能告诉你英国天然气用量增加主要原因是北海油气田的开发吗？天然气生产出来当然要用啊，这不是因为有雾霾英国大量进口天然气的结果。</p>
<p>大家都知道用天然气比煤炭要环保，问题是中国有那么多天然气来替代煤炭吗？</p>
<p>现在中国能源结构里天然气占比5%，但同时中国已经是天然气第六大生产国和第五大天然气进口国，未来这个数字还会增加。但依靠天然气替代煤炭没有任何可能，只能很小幅度地替代。按照全球25%的比例，中国要增加五倍的天然气需求，这哪里去买啊？其他国家的人怎么办？</p>
<p>以下转自一位知名学者的微信</p>
<p>扭曲手法一览：引用的数据曲线、方程画面快速扫过，很多数据去除单位、可参照指标，避免人们对其论据进行仔细深入查验伪造数据，混淆概念，在油气开采的表述上极为严重大量场景、数据采自2004年，即中国经济大规模起飞的初期，甚至更早的八九十年代。按照其引用的数据，中国的城市污染反而是在减轻对民营加油站的采访（本片作为负面例子）反而恰好打了自己“油气私有、竞争就能提高效率”的嘴巴对西方如英国的能源-经济历史进行因果曲解，完全不提及七十年代英国北海油田发现对其经济结构改变的作用及其效益唯一相对客观的，是进京货运车辆的油品品质问题，这相对较好的解释了北京夜晚空气颗粒物明显增加的现象。</p>
<p>结论：<br>a、此片是政治事件，是中国“绿党”势力的里程碑事件，要高度警惕。了解经济史、工程史、企业史的人一般知道西方绿党势力对本国经济尤其是大型前沿工程的压制、拖累作用。<br>b、技术上看，此篇做的还比较糙，煽情较重，科学、经济学、社会学硬伤极多，大量行业从业人员，包括能源行业从业者、金融行业（相关行业投资、贷款）从业者都可一眼看出。与西方戈尔等势力的直接控制本国科研机构进行高超包装的手法相比，还有距离。这是好事，及早暴露，及早对其提起警惕。如果等到西方那样病入骨髓，科研单位也被操弄，那就麻烦了。<br>c、从而可以反推，此事尚为柴为核心的小团体所为，还没有俘获国家核心人员。<br>d、以当前国内经济形态发展，中国用煤高峰已经出现在2013年，未来将持续下行，雾霾已经开始日趋消散。相比开始好转的雾霾问题，更应该关心的是河北、东北原传统产业的就业人员的出路问题、银行金融体系的坏账问题，重型行业如何平滑过渡的问题。</p>
<p>g、所有能一眼看出其中大量常识性弊病、移花接木手法的专业人员，不要再犹豫，应当捍卫理性王国的边界。否则，我们的孩子们将最终生活在以道德温情为始，以密不透风的思想穹顶为终的世界里。</p>
<p>15/6/3 18:39:08.617 [NOTICE] DisableNetwork is set. Tor will not make or accept non-control network connections. Shutting down all existing connections.<br>15/6/3 18:39:08.617 [NOTICE] Opening Socks listener on 127.0.0.1:9150<br>15/6/3 18:39:12.585 [WARN] The communication stream of managed proxy ‘PluggableTransports/meek-client-torbrowser’ is ‘closed’. Most probably the managed proxy stopped running. This might be a bug of the managed proxy, a bug of Tor, or a misconfiguration. Please enable logging on your managed proxy and check the logs for errors.<br>15/6/3 18:39:12.585 [NOTICE] Failed to terminate process with PID ‘47389’ (‘No child processes’).<br>15/6/3 18:39:13.587 [NOTICE] Bootstrapped 5%: Connecting to directory server<br>15/6/3 18:39:13.588 [WARN] We were supposed to connect to bridge ‘0.0.2.0:2’ using pluggable transport ‘meek’, but we can’t find a pluggable transport proxy supporting ‘meek’. This can happen if you haven’t provided a ClientTransportPlugin line, or if your pluggable transport proxy stopped running.<br>15/6/3 18:39:13.588 [WARN] Problem bootstrapping. Stuck at 5%: Connecting to directory server. (Can’t connect to bridge; PT_MISSING; count 1; recommendation warn; host 4EE0CC769EB4B15A872F742EDE27D298A59DCADE at 0.0.2.0:2)<br>15/6/3 18:39:37.588 [WARN] The communication stream of managed proxy ‘PluggableTransports/meek-client-torbrowser’ is ‘closed’. Most probably the managed proxy stopped running. This might be a bug of the managed proxy, a bug of Tor, or a misconfiguration. Please enable logging on your managed proxy and check the logs for errors.<br>15/6/3 18:39:37.588 [NOTICE] Failed to terminate process with PID ‘47490’ (‘Resource temporarily unavailable’).<br>15/6/3 18:39:38.586 [WARN] We were supposed to connect to bridge ‘0.0.2.0:2’ using pluggable transport ‘meek’, but we can’t find a pluggable transport proxy supporting ‘meek’. This can happen if you haven’t provided a ClientTransportPlugin line, or if your pluggable transport proxy stopped running.<br>15/6/3 18:39:38.586 [WARN] Problem bootstrapping. Stuck at 5%: Connecting to directory server. (Can’t connect to bridge; PT_MISSING; count 2; recommendation warn; host 4EE0CC769EB4B15A872F742EDE27D298A59DCADE at 0.0.2.0:2) </p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>误导，【英语】 Mislead 【基本解释】指导做 错误的事;错误的指导。</p>
<h1 id="缘由">缘由</h1><p>今天和小杭的聊天<br>本来不想发表这篇文章，因为这样可能会让有些人对我的世界观以及想法产生误解</p>
<h1 id="过去的事情对今天产生影响">过去的事情对今天产生影响</h1><p>人们总是替自己的言行找这样那样的借口<br>说别人以前有自己的自由，自己的生活方式，不应该去过问。<br>甚至拿出你的生命和家境由父母决定，你是没法选择的来做类推以期望达到证明自己的观点是正确的。<br>可笑的是这个根本不存在因果关系，但是还是会有很多人回去相信</p>
<h2 id="手段：以偏概全，只说需要说的">手段：以偏概全，只说需要说的</h2><p>希特勒是个可怜的艺术家<br>关于希特勒，可以这样来形容：有个人酷爱艺术，通过合法竞选高票当上总理，任上让德国经济腾飞，结果被逼自杀了。</p>
<p>看了这段话，你大概不会认为这个总理是嗜血成性的希特勒。</p>
<h2 id="切入：以公众情感作为切入点">切入：以公众情感作为切入点</h2><p>要确保能误导成功，首先要让大部分人进入到非理性状态，要进入到非理性状态，最简单的做法是让读者愤怒起来。以柴静的视频为例，她先说到她的女儿，用一些表述手法让公众认为女儿患上肿瘤与雾霾是因果关系，随之表达愤怒。作为情感动物，人们在这种时候会与视频产生共鸣，甚至心里可能会想：「妈的，就是这雾霾让我家的小孩也老咳嗽的。」<br>儿童<br>以儿童的健康等原因，作为文章的切入，容易让读者进入到非理性状态。<br>弱势群体<br>老、弱、病、残、被性别其实的妇女，被性取向歧视的个人或群体，都是很好的作为情感切入的对象。</p>
<h2 id="手段：含糊其词引用专业词汇">手段：含糊其词引用专业词汇</h2><p>记者也好，写作者也好，有时为了便于读者理解，会把复杂的概念简单化。在简单化的过程里，也是很容易进行误导的过程，因为你可以简化掉那些不支持你观点的论据，剩下你需要的。</p>
<h2 id="手段：误导因果关联关系">手段：误导因果关联关系</h2><p>为了误导，我们需要捏造因果关系。之所以称之为捏造，是因为我们无法确切证明两者之间有明确的因果关系。</p>
<p>柴静：让你觉得我女儿的肿瘤与雾霾有关</p>
<p>没有证据表明她女儿的肿瘤与雾霾有关， 柴静也没有直接说孩子是因为雾霾患上肿瘤，但她懂得如何让媒体往这个方向去传播，《柴静离职自费百万拍雾霾纪录片 因女儿未出世患肿瘤》这篇新闻早早在网上传播了起来。</p>
<p>为了达到这样的误导效果，柴静在视频开始中说，「生活在一年竟有175天污染的北京，害怕女儿有一天会问我什么是蓝天、为什么老把我关在家里，加上全社会对空气污染问题也越来越关心，职业训练和母亲本能都让我觉得应该回答这些问题：雾霾是什么？从哪儿来？该怎么办？」</p>
<p>柴静都这么说了，结合她女儿患肿瘤的事实，就很容易误导媒体往这个方向去传播，于是就误导成功了。<br>我帮我哥们找到了对象<br>以前我写可能吧的时候，一个朋友让我在博客上帮他发征婚文章，我发了之后他收了不少邮件，现在他已经结婚当爸了，他特别感谢我当年帮他发征婚帖。<br>吃糖的孩子聪明<br>一项研究发现，经常吃糖的小孩，智商会比其它小孩高出5%以上。<br>GoPro 导致舒马赫一直昏迷<br>一位知情人士表示，舒马赫在滑雪时头戴 GoPro 相机，沉重的撞击让他昏迷一年多至今仍未苏醒，消息披露后， GoPro 股价当天跌了将近10%。<br>手段：以相关性误导因果关系<br>与捏造因果关系不同，捏造对象很多时候是没有关联性的。为了达到更好的误导效果，有时需要通过对象的相关性，来<br>柴静：PM2.5让死亡率增高</p>
<p>在视频的12:39处，柴静引用了几条曲线说明：当PM2.5增多时，人类的死亡率随之增高。实际上，这两者可能有相关性，但并不是因果关系。这里面的因素可以很多，比如PM2.5增多的地方，医疗水平也会随之提高，死亡率的提高，并不一定与PM2.5有直接关联。</p>
<p>但这样的表述，可以起到误导因果关系的作用，值得借鉴。<br>激素替代疗法有预防冠心病的效果<br>以前有这么一种说法：流行病学研究曾发现，接受激素替代疗法的妇女，发生冠心病的比率较一般人低。</p>
<p>但实际上，接受激素替代疗法的妇女社会地位多半较高，她们通常有较好的饮食、运动习惯，因而比较不容易发生冠心病。<br>天蝎座的人容易成功<br>中国互联网巨头的生日分别为：马云 1964年10月15日，李彦宏 1968年11月17日，马化腾 1971年10月29日，丁磊 1971年10月10日。都是天蝎座。<br>因为 Google，我哥们上了黄网<br>还记得多年前的大学生「高也」么？</p>
<p>央视在采访他时，让他说了这么一段话：就我一个同学吧，他以前就是青少年比较好奇这些东西，他就去点那些黄色网站什么的。然后就搞到那段时间心神不宁，然后后来国家打击黄色网站了，他就没上，那段时间就好了。结果后来他又发现通过Google这些用户比较多的搜索引擎可以打开这些网址，然后又进入了这些黄色网站，Google里面的链接特别多，然后就导致他又反复了。<br>手段：捏造不便查证的数据<br>一般有这几种做法。<br>柴静：捏在1970-1998年的统计数据</p>
<p>柴静分享了一份来自加洲空气质量管理局的数据，从1970年到2012年 PM2.5 的变化曲线，但如果我们从官网里查找这些数据，会发现，1998年之前的数据是没有记录的，那么，1970-1998的数据，就是捏造。</p>
<p>但是，大部分公众并不会去追究这些数据的真实性，因为这条曲线，符合他们的非理性认知。<br>90%的真实加上10%的造假<br>其实如果你写的内容有90%是真实或符合大众的心理期待的，那么，你可以有10%的造假，这些造假大部分是不会去深究的，这时你就误导成功了。<br>机构研究表示<br>有些时候，写文章时，用这些短语会提高文章的权威性，公众一般不会去深究，也无法查证：</p>
<p><em>机构研究表明
</em>权威机构正视<br>*美国一项报告指出<br>在查证了大量的论文后……<br>这种说法，也是一种捏造不便查证的数据的方式。<br>How to：基本写作流程<br>首先确定结论<br>这与探索性的文章写法是相反的。要误导公众，你在搜集资料之前，就应该确定结论，而不是在寻找大量的资料后，用分析的方法确定结论。<br>寻找支持结论的论据<br>论据分为搜集的资料以及采访对象的口述，而对于口述的文字，有时需要用到断章取义的方式来支持文章的论点。<br>寻找支持结论的数据<br>人们对数字都很敏感，这种敏感性显示在爱看、爱说。一个人说了一连串的数字，不管真实性如何，大部分人都会认为他是「有过研究的」。<br>对不支持结论的论据，瓦解其关联性或不提及<br>不提及当然是最好的，但有时不得不提及，那么就需要瓦解它们的关联性。所谓的瓦解，就是故意只说部分的事实，来切断论据与结论的关联性。<br>尽量多地在文章中引入个人感受，激起读者的愤怒或强烈的情感<br>以偏概全地制造不相关的因果关系</p>
<p>大可<br>1、信任变得太脆弱，站队成了主流。<br>2、过去的两个月，我抑郁了。<br>3、这两句都是真的，但没有完全正相关的因果关系。</p>
<p>先断章取义截图视频中的某一个画面，基于能看到的画面和字幕，顺序得出一个柴静不够严谨的结论，将其他切实存在误导的报道和理论放在下面进行类比，引导大家得出“看吧就是那招，你们还没有发现规律吗？”<br>但问题是，这些事件是独立的，很大程度上跟柴静得出结论的方式并不相同，他们的不靠谱，并不影响柴静的结论。重点最根本就是，一开始他自己得出的结论就是以偏概全的<br>大众会被误导的原因多是他们懒于查证，不会独立思考。</p>
<p>从某种意义上来说，营销广告就是欺骗消费者花钱，演讲也是为了感染听众，传递自己的表达。基于如此，［误导］还是必要的！</p>
<p>其实吧，如果你看一件东西或者被别人的一些话击中，最后引起共鸣，误导或许就在里面……再替作者重申一下，误导，真的不是贬义词，只是给你带入了一个环境。<br>不过说实在的，穹顶看完之后总觉得有点儿言过了，太严谨的逻辑加上一边倒的结论，引导性的确不小，具体感受请脱离情景来看</p>
<p>只要一个人，一个群体，在公开场所讲话，宣传，都很少能不“误导公众”。但这并不重要，重要的是每一个公众都应该养成独立判断独立见解的能力，这样就无所谓“误导”不误导之说了。当然，柴静的纪录片在某些程度上是具有积极作用的，她至少激起了公众对于治理污染的热情与信心。我们没有权利只知抱怨不知改变，柴静用她的方式，不论完美与否，与污染作出了抗争，相信这篇轻单也一样。</p>
<p>按：无论这个纪录片是要干什么，但最起码的要求是事实和数据要真实正确。数据的误差固然不可避免，但是如果是故意的造假，那么就一定要问一下，为什么要故意造假？</p>
<p>无论是自然科学还是社会科学，一篇文章有一个数据故意造假，就已经完全失去了进一步讨论的意义。</p>
<p>用了大量的数据和资料来支撑她的结论，我一般习惯看数据都是看paper,还不太习惯看文科生摆弄些她自己都不懂的东西，我必须承认她的勇气，但是同时我也有点气愤，因为错误造假的数据对大众的影响比煽情的鼓动来的更大。看着那一串串高大上的NASA, 技术统计局，国家监测局，大家都觉得这是多么”严谨的”调查研究啊！ 本人正好博士论文与emission有点关系，看着看着觉得有点不对，查了查资料，发觉几乎每个数据都有问题。实在是有点忍不住了。</p>
<p>以下是纯技术讨论分割线，我都附上详细的引用资料，绝对比柴小姐专门唬人的大title来得详细，欢迎理性讨论。</p>
<p>【1】6：10 有意混淆雾霾和PM2.5</p>
<p>她问雾霾是什么？然后一下子转到PM2.5, smog不等于 PM2.5好吧，smog中有CO, Pb, NOx, PM, 还有SO2.怎么逻辑上一下子就套换了呢 (Smog and Particulates:Pollutant Descriptions)</p>
<p>【2-4】6：30 伪造采样结果</p>
<p>我注意到她的这款采样仪， 是LIbra Buck pump, 看样子是LP4的pump, 这个pump的工作时常是8小时左右，怎么可以采样24小时？ 恩，她应该是背了好几个大电池吧，不过我没见着，而且额外的电池也不是标配 (<a href="http://www.buckservice.com/manuals/Libramanua%20L-4.pdf">http://www.buckservice.com/manuals/Libramanua%20L-4.pdf</a>) LP5是可以工作20个小时的，不过她的型号不是LP5的。￼</p>
<p>你能告诉我你知道采样膜本身应该是什么颜色的吗？？你知不知道是PVC和MCE材料的？大部分黑色的是吸附的碳吧，碳本身的毒性不大，哦，这是不是又和你研究结果的大部分是致癌物矛盾了？</p>
<p>￼让我来告诉你实验该怎么做吧， 采样仪的测试范围和灵敏度数据要有吧，空气的湿度和风向条件要有吧，采样仪的流量数据要有吧，什么都没有就敢上数据，数据就是垃圾。(说句老实话我根本不相信filter会黑成那样，24小时，污染再大，顶多是灰色，我实验室放了7年的filter都没有那么黑，弄得太黑亮了，真的。）</p>
<p>【5】8：40 对图片进行裁剪和后期加工</p>
<p>这个是柴小姐NASA的碳密度图，这个数据好像很神秘，其实他是这样的。</p>
<p>SVS: AtmosphericBlack Carbon Density (id 3668)</p>
<p>￼这个是官方图，怎么样？我截的是不是看上去没有那么恐怖？ 因为这个图是8-11月的数据，所以她可以随意截出最槽糕的图片，甚至人为调亮度，既然都是网上资源，干吗不直接连网络而要截图片？因为图片是可以操作的。实际上，大部分发展中国家，东南亚，非洲，一些南美国家，都差不多。</p>
<p>￼</p>
<p>【6】12:41 编造并不存在的因果关系</p>
<p>这个是最吐嘈的地方， 看到这个数据，我的早饭都喷出来了，来，先上图看看。</p>
<p>￼￼￼看清楚了吗？？图的横坐标是年份，纵坐标是各种死亡率。你能告诉我和PM2.5有一毛钱关系吗吗？ PM2.5的数据在哪里啊？你不要欺负我看不懂数据图啊，尤其这个“复杂”的数据图还有三个销魂的多项式，放在右边。我懒得截图了，不过我随便看了一下，如果X=0的话，Y应该是负的，而我随便代一个X的数据，Y是一个巨大的数字，根本不在图表显示之类。感兴趣的话可以自己做线性拟合。柴小姐太入戏了，我做学生的时候导师常教导我说，自己不是很明白的图表不要去误导人，看来不同人的职业操守是不一样的。</p>
<p>【7】改变数据口径形成误导印象</p>
<p>这个是全国的PM2.5来源，我看着不对，因为PM2.5来源复杂，这个图有点把问题太简单话了，我知道，简单的东西比较容易发挥，因为这时候的攻击对象是煤。</p>
<p>￼然后接下来，她又扔出来一张图，是北京PM2.5的来源，现在这个数据显示：31.1%来自机动车</p>
<p>￼同学门要问了，为啥这附图不把燃煤+燃油放在一起呢？ 因为柴小姐要讨论汽油了啊！放一起不就显示不出汽油排放的害处了吗！所以数据的“处理”是可以根据需要来玩的。当然，北京的数据我是有的（R. Zhang et al.: Chemical characterization and sourceapportionment of PM2.5 in Beijing）这篇文章分析得很详尽，关于污染源也按照不同季节区分了，事实上，机动车的污染并没有那么严重。我就是不喜欢为了自己的论点来manipulate数据，很恶俗。￼</p>
<p>【8】24.06 篡改资料的背景和时间</p>
<p>全球化石能源燃烧强度表<br>￼首先，你可以告诉我这是全球吗， 吗？？你不要欺负我没学过地理啊！南半球呢？这个图说真的我不是很懂，什么叫燃烧强度？怎么测啊？ 不过我稍微转个弯想想，她们是想说二氧化碳的排放吧，因为大部分能源燃烧排放的是CO2, 于是我找到了下面这张图。</p>
<p>￼这个确实是NASA2014年公布的CO2 emission的资料（Both Beautiful and Disturbing, a New NASA Visualization Shows CarbonDioxide Emissions Swirling Around the World）不过这个图明明写的是亚洲和喜马拉雅地区。还有这个图是超级计算机模拟出来的，是个visualization，不是真实数据，虽然是NASA2014年放出来的，但是模拟的是2005-2007的情况，也是为了响应中美对于温室气体排放控制协议。柴小姐这样随便串改资料背景，为自己所用，还堂而皇之的拿出来show,我真是佩服。</p>
<p>【9】更恶劣的：直接伪造数据</p>
<p>接下来，柴小姐给大家普及了一个时髦的名词，叫蒸汽压。也就是Vaporpressure. 看着红外镜头下的汽油蒸发物是不是很酷的东西？好吧，不懂vapor pressure的人自己自行补课吧，我要说的是数据。￼</p>
<p>柴小姐数据常常是信口就来，我该佩服她博学多才呢还是记忆力好呢。这个1升等于多少克的概念是不是很熟悉？学过中学物理的都会算吧。</p>
<p>PV=nRT,n=PV/RT=(0.5X1)/(8.3X298) m=nM=0.02g</p>
<p>不是0.02g吗，怎么是1.5g?</p>
<p>注意： 我用的pressure是她表格里的50Kpa, T是室温，M是105.</p>
<p><a href="http://www.methanol.org/energy/resources/alternative-fuel/alt-fuel-properties.aspx">http://www.methanol.org/energy/resources/alternative-fuel/alt-fuel-properties.aspx</a></p>
<p>接下来注意</p>
<p>￼越来越入戏了。</p>
<p>请看标准的汽车尾气排放数据，就算是高标准的美国，每加仑CO2的排放（还不是全部尾气哦）就是8.8kg per gallon, 1gallon是3。78升，也就是排放33g的二氧化碳。</p>
<p>你是要告诉我1.5g比33g 多吗？？？</p>
<p><a href="https://www.chargepoint.com/files/420f05001.pdf">https://www.chargepoint.com/files/420f05001.pdf</a></p>
<p>【10】直接在数据后面加两个零！！！</p>
<p>这个时候我已经不想继续看下去了。一般来说在学术界，你要一个数据错误，造假，manipulate.你的reputation就没了，因为你就是这个水平。柴小姐这个错误百出的PPT还是越发来劲，最后再补一个吧。凑个整数（其实到处嘈点还很多…)</p>
<p>￼这个加洲的数据，号称来自空气质量管理局。好，请看加州官网的数据。他是这么写的</p>
<p>1970, CA’s populationreached 20 million people. Total registered vehicles exceeded 12 million andvMT was 110 billion. Cumulative CA vehicle emissions for NOx and HCs were 1.6million tons/year.</p>
<p>Key Events in theHistory or Air Quality in California</p>
<p>柴小姐右边是VMT ，也就是vehicle mileage traveled. (一年的里程数） 那么1970年是110billion,</p>
<p>1billion=1000million,110=110,000million. 请数下，是4个零。 再看柴的图表， 1970年对应的是1000000，我数了好几篇，就是6个零。白白的多了10倍！！</p>
<p>为嘛呀， 这个数据不用造假啊？ 也不影响她的PPT的说教。我想了一下，觉得这个应该是水平问题。我想看看PM2.5的数据，结果我得出来的是</p>
<p>￼原来这个数据1999才有，至于她们怎么拿到1970-1999的，大家就自行脑补好了。</p>
<p>最后，我不评价她的观点，但是她敢拿假数据说话，还一定要把数据挂个官方的大牌子给自己做装饰，我看一次打一次。如今网络发达了，屁都不懂的人也可以google个事是而非的东西装点门面，大家在这方面还是要多看看专家的观点，毕竟他们受过严格的科学训练，有着严谨的操守，而专业煽情的人，也应该专注在煽情上。</p>
<p>以下转自四月网网友张帅 <a href="http://www.m4.cn/opinion/2015-03/1265041.shtml">http://www.m4.cn/opinion/2015-03/1265041.shtml</a></p>
<p>【11】3%＝一半？</p>
<p>我承认这个表述当时令我非常震惊，我从来没想到轮船的耗油量占到总石油消耗的一半，至于是不是失控当时还没来得及想。</p>
<p>查下来的实际数字是轮船用油占燃料油的比例接近一半（47%），而燃料油占总油量消耗量的比例是6.6%，也就是说，船舶运输占石油消耗的比例是3%，这和一半差太多了吧。再怎么考虑节目效果也不能把3%误导成一半。</p>
<p>【12】故意混淆经济可采储量、技术可采储量和地质储量</p>
<p>“天然气在中国无法大量开采的原因是中石化的垄断，只要开放就可以解决？举例：9000亿立方米可采储量，只开采了1000亿立方米，根本原因是：70%资源被中石油垄断。”</p>
<p>垄断问题后面讲，首先要说的是柴静的团队没搞清楚产量、经济可采储量、技术可采储量和地质储量的关系。</p>
<p>我也举个例子，全球油气剩余技术可采资源量高达6000亿吨和810万亿立方米，但是2014年油气产量仅为41.5亿吨和3.57万亿立方米。这也是因为全球石油巨头不开放市场导致的？</p>
<p>另外与其他天然气大国相比，我国油气发现和开采成本不断攀升，截止2013年底，我国天然气井日均产量不到3万立方米，低于1万立方米的占一半。如果真的把所有的技术可采储量都开采了，大家估计就会骂中石化败家子，搞得企业亏损。</p>
<p>【13】故意回避有关事实</p>
<p>“伦敦的经验告诉我们，要减少雾霾必须降低煤炭消耗量增加天然气用量，英国就是这样变好的，所以我们也要大幅提高天然气比例。”</p>
<p>我能告诉你英国天然气用量增加主要原因是北海油气田的开发吗？天然气生产出来当然要用啊，这不是因为有雾霾英国大量进口天然气的结果。</p>
<p>大家都知道用天然气比煤炭要环保，问题是中国有那么多天然气来替代煤炭吗？</p>
<p>现在中国能源结构里天然气占比5%，但同时中国已经是天然气第六大生产国和第五大天然气进口国，未来这个数字还会增加。但依靠天然气替代煤炭没有任何可能，只能很小幅度地替代。按照全球25%的比例，中国要增加五倍的天然气需求，这哪里去买啊？其他国家的人怎么办？</p>
<p>以下转自一位知名学者的微信</p>
<p>扭曲手法一览：引用的数据曲线、方程画面快速扫过，很多数据去除单位、可参照指标，避免人们对其论据进行仔细深入查验伪造数据，混淆概念，在油气开采的表述上极为严重大量场景、数据采自2004年，即中国经济大规模起飞的初期，甚至更早的八九十年代。按照其引用的数据，中国的城市污染反而是在减轻对民营加油站的采访（本片作为负面例子）反而恰好打了自己“油气私有、竞争就能提高效率”的嘴巴对西方如英国的能源-经济历史进行因果曲解，完全不提及七十年代英国北海油田发现对其经济结构改变的作用及其效益唯一相对客观的，是进京货运车辆的油品品质问题，这相对较好的解释了北京夜晚空气颗粒物明显增加的现象。</p>
<p>结论：<br>a、此片是政治事件，是中国“绿党”势力的里程碑事件，要高度警惕。了解经济史、工程史、企业史的人一般知道西方绿党势力对本国经济尤其是大型前沿工程的压制、拖累作用。<br>b、技术上看，此篇做的还比较糙，煽情较重，科学、经济学、社会学硬伤极多，大量行业从业人员，包括能源行业从业者、金融行业（相关行业投资、贷款）从业者都可一眼看出。与西方戈尔等势力的直接控制本国科研机构进行高超包装的手法相比，还有距离。这是好事，及早暴露，及早对其提起警惕。如果等到西方那样病入骨髓，科研单位也被操弄，那就麻烦了。<br>c、从而可以反推，此事尚为柴为核心的小团体所为，还没有俘获国家核心人员。<br>d、以当前国内经济形态发展，中国用煤高峰已经出现在2013年，未来将持续下行，雾霾已经开始日趋消散。相比开始好转的雾霾问题，更应该关心的是河北、东北原传统产业的就业人员的出路问题、银行金融体系的坏账问题，重型行业如何平滑过渡的问题。</p>
<p>g、所有能一眼看出其中大量常识性弊病、移花接木手法的专业人员，不要再犹豫，应当捍卫理性王国的边界。否则，我们的孩子们将最终生活在以道德温情为始，以密不透风的思想穹顶为终的世界里。</p>
<p>15/6/3 18:39:08.617 [NOTICE] DisableNetwork is set. Tor will not make or accept non-control network connections. Shutting down all existing connections.<br>15/6/3 18:39:08.617 [NOTICE] Opening Socks listener on 127.0.0.1:9150<br>15/6/3 18:39:12.585 [WARN] The communication stream of managed proxy ‘PluggableTransports/meek-client-torbrowser’ is ‘closed’. Most probably the managed proxy stopped running. This might be a bug of the managed proxy, a bug of Tor, or a misconfiguration. Please enable logging on your managed proxy and check the logs for errors.<br>15/6/3 18:39:12.585 [NOTICE] Failed to terminate process with PID ‘47389’ (‘No child processes’).<br>15/6/3 18:39:13.587 [NOTICE] Bootstrapped 5%: Connecting to directory server<br>15/6/3 18:39:13.588 [WARN] We were supposed to connect to bridge ‘0.0.2.0:2’ using pluggable transport ‘meek’, but we can’t find a pluggable transport proxy supporting ‘meek’. This can happen if you haven’t provided a ClientTransportPlugin line, or if your pluggable transport proxy stopped running.<br>15/6/3 18:39:13.588 [WARN] Problem bootstrapping. Stuck at 5%: Connecting to directory server. (Can’t connect to bridge; PT_MISSING; count 1; recommendation warn; host 4EE0CC769EB4B15A872F742EDE27D298A59DCADE at 0.0.2.0:2)<br>15/6/3 18:39:37.588 [WARN] The communication stream of managed proxy ‘PluggableTransports/meek-client-torbrowser’ is ‘closed’. Most probably the managed proxy stopped running. This might be a bug of the managed proxy, a bug of Tor, or a misconfiguration. Please enable logging on your managed proxy and check the logs for errors.<br>15/6/3 18:39:37.588 [NOTICE] Failed to terminate process with PID ‘47490’ (‘Resource temporarily unavailable’).<br>15/6/3 18:39:38.586 [WARN] We were supposed to connect to bridge ‘0.0.2.0:2’ using pluggable transport ‘meek’, but we can’t find a pluggable transport proxy supporting ‘meek’. This can happen if you haven’t provided a ClientTransportPlugin line, or if your pluggable transport proxy stopped running.<br>15/6/3 18:39:38.586 [WARN] Problem bootstrapping. Stuck at 5%: Connecting to directory server. (Can’t connect to bridge; PT_MISSING; count 2; recommendation warn; host 4EE0CC769EB4B15A872F742EDE27D298A59DCADE at 0.0.2.0:2) </p>]]>
    
    </summary>
    
      <category term="思想 思考" scheme="http://ioschen.com/tags/%E6%80%9D%E6%83%B3-%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac开发NSButton学习笔记]]></title>
    <link href="http://ioschen.com/2015/01/07/studyui/"/>
    <id>http://ioschen.com/2015/01/07/studyui/</id>
    <published>2015-01-07T13:36:10.000Z</published>
    <updated>2015-03-30T07:31:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="新建项目StudyUI">新建项目StudyUI</h3><ol>
<li>和IOS项目一样,新建工程StudyUI 不适用storyboard</li>
<li>新建文件MainMenuView继承NSView</li>
<li>设置如下图<br><img src="http://ioschen.com/images/mac/nsbutton/button1.jpg" alt="image"></li>
</ol>
<h3 id="NSButton属性">NSButton属性</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">drawRect:</span>(NSRect)dirtyRect &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">drawRect:</span>dirtyRect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Drawing code here.</span></span><br><span class="line">    </span><br><span class="line">    NSButton *button=[[NSButton alloc]<span class="string">initWithFrame:</span>NSMakeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    [button <span class="string">setButtonType:</span> NSMomentaryPushInButton];<span class="comment">//集中样式看API</span></span><br><span class="line">    button.bezelStyle=NSRoundRectBezelStyle;</span><br><span class="line">    [button <span class="string">setBordered:</span> NO];<span class="comment">//默认有边框 因为设置图片所有去掉边框</span></span><br><span class="line">    [button <span class="string">setTarget:</span>self];</span><br><span class="line">    [button <span class="string">setAction:</span><span class="annotation">@selector</span>(<span class="string">hehe:</span>)];<span class="comment">//设置按钮点击事件</span></span><br><span class="line">    [button <span class="string">setTag:</span><span class="number">10</span>];</span><br><span class="line">    <span class="comment">//[button setTitle:@"我不是按钮"];</span></span><br><span class="line">    [button <span class="string">setImage:</span>[NSImage <span class="string">imageNamed:</span>@<span class="string">"Emacs.png"</span>]];</span><br><span class="line">    <span class="comment">//下面这个是设置图片裁剪自适应 如果不加这句话图片是300*300 按钮大小是100*100那么现实的只是图片的局部</span></span><br><span class="line">    [[button cell] <span class="string">setImageScaling:</span>NSImageScaleAxesIndependently];</span><br><span class="line">    </span><br><span class="line">    [button <span class="string">setImagePosition:</span>NSImageOnly];</span><br><span class="line">    [self <span class="string">addSubview:</span>button];</span><br><span class="line"><span class="comment">//    [self.window.contentView addSubview: button];</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="typename">void</span>)<span class="string">hehe:</span>(id)sender&#123;</span><br><span class="line">    NSLog(@<span class="string">"hehe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用拖拽线的方式设置按钮事件 还可以设置属性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="新建项目StudyUI">新建项目StudyUI</h3><ol>
<li>和IOS项目一样,新建工程StudyUI 不适用storyboard</li>
<li>新建文件MainMenuView继承NSView</li>
<li>设置如下图<br><img sr]]>
    </summary>
    
      <category term="Mac软件" scheme="http://ioschen.com/tags/Mac%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的Mac定制软件]]></title>
    <link href="http://ioschen.com/2015/01/07/cly/"/>
    <id>http://ioschen.com/2015/01/07/cly/</id>
    <published>2015-01-07T13:36:10.000Z</published>
    <updated>2015-03-30T07:21:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="项目简介">项目简介</h3><p>新建项目CLY</p>
<h3 id="Mac图标">Mac图标</h3><p><img src="http://ioschen.com/images/cly.png" alt="image"></p>
<ol>
<li>icon_16x16.png</li>
<li>icon_16x16@2x.png</li>
<li>icon_32x32.png</li>
<li>icon_32x32@2x.png</li>
<li>icon_128x128.png</li>
<li>icon_128x128@2x.png</li>
<li>icon_256x256.png</li>
<li>icon_256x256@2x.png</li>
<li>icon_512x512.png</li>
<li>icon_512x512@2x.png</li>
</ol>
<h3 id="设置图标">设置图标</h3><p><img src="http://ioschen.com/images/cly_icon.png" alt="image"></p>
<h3 id="Git">Git</h3><p><a href="https://github.com/ioschen/OnlyYou" target="_blank" rel="external">Github地址</a></p>
<p>持续更新！</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="项目简介">项目简介</h3><p>新建项目CLY</p>
<h3 id="Mac图标">Mac图标</h3><p><img src="http://ioschen.com/images/cly.png" alt="image"></p>
<ol>
<li>icon_16x16.png</li>
<li>icon_16x16@2x.png</li>
<li>icon_32x32.png</li>
<li>icon_32x32@2x.png</li>
<li>icon_128x128.png</li>
<li>icon_128x128@2x.png</li>
<li>icon_256x256.png</li>
<li>icon_256x256@2x.png</li>
<li>icon_512x512.png</li>
<li>icon_512x512@2x.png</li>
</ol>
<h3 id="设置图标">设置图标</h3><p><img src="http://ioschen.com/images/cly_icon.png" alt="image"></p>
<h3 id="Git">Git</h3><p><a href="https://github.com/ioschen/OnlyYou">Github地址</a></p>
<p>持续更新！</p>]]>
    
    </summary>
    
      <category term="Mac软件" scheme="http://ioschen.com/tags/Mac%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BestApp]]></title>
    <link href="http://ioschen.com/2014/12/10/bestapp/"/>
    <id>http://ioschen.com/2014/12/10/bestapp/</id>
    <published>2014-12-10T03:14:23.000Z</published>
    <updated>2015-01-07T14:02:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="必备软件">必备软件</h2><ol>
<li>dropbox</li>
<li>mou</li>
<li>1password</li>
<li>readkit</li>
<li>colorsnapper</li>
</ol>
<h2 id="快捷键组合">快捷键组合</h2><ol>
<li>Shift+Command+G 三个组合按键查找文件</li>
<li>在你创建仓库的目录下有个隐藏文件叫”.git”把这个文件删除就可以了。</li>
</ol>
<h2 id="网站">网站</h2><p>dnspod</p>
<hr>
<h1 id="超链接，页面设置">超链接，页面设置</h1><h1 id="定位技术（表格、层、框架）。">定位技术（表格、层、框架）。</h1><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[你对本页的描述]]>
    
    </summary>
    
      <category term="APP,技巧" scheme="http://ioschen.com/tags/APP-%E6%8A%80%E5%B7%A7/"/>
    
      <category term="default" scheme="http://ioschen.com/categories/default/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[one]]></title>
    <link href="http://ioschen.com/2014/08/31/one/"/>
    <id>http://ioschen.com/2014/08/31/one/</id>
    <published>2014-08-30T16:06:09.000Z</published>
    <updated>2014-08-30T16:12:00.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚灵光一闪，想到一个绝佳创意。建立一个网站叫做壹元购，每天推一到两款产品，比如iPhone5s手机5000元。只要超过5230个人购买就生效，否则参与的一元钱退还。超过的话就抽奖，抽中的人得到。为了公平起见，抽中的人根据当天的彩票号码或者其他号码进行算法处理，保证只能一个人中奖。</p>
<h5 id="这个最大的问题就是属于博彩。">这个最大的问题就是属于博彩。</h5><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚灵光一闪，想到一个绝佳创意。建立一个网站叫做壹元购，每天推一到两款产品，比如iPhone5s手机5000元。只要超过5230个人购买就生效，否则参与的一元钱退还。超过的话就抽奖，抽中的人得到。为了公平起见，抽中的人根据当天的彩票号码或者其他号码进行算法处理，保证只能一个人中奖。</p>
<h5 id="这个最大的问题就是属于博彩。">这个最大的问题就是属于博彩。</h5>]]>
    
    </summary>
    
      <category term="灵感" scheme="http://ioschen.com/tags/%E7%81%B5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bug]]></title>
    <link href="http://ioschen.com/2014/06/21/bug/"/>
    <id>http://ioschen.com/2014/06/21/bug/</id>
    <published>2014-06-21T14:05:04.000Z</published>
    <updated>2014-06-21T14:08:28.000Z</updated>
    <content type="html"><![CDATA[<p>今天出现一个问题</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> Symbol not <span class="string">found:</span> _OBJC_CLASS_$_NSMutableURLRequest</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br><span class="line">  Expected <span class="string">in:</span> <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CFNetwork.framework/CFNetwork</span><br><span class="line"> <span class="keyword">in</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br></pre></td></tr></table></figure>
<p>正好我升级了ios8 xcode的sdk也是ios8<br>照成这个原因是我用的smartlink已经在包里引用了CFNetwork.framework而我重复引用了。最后删掉就解决了<br>ps:奇怪的是我平时调试都没有出问题。今天拿到朋友手机就出现了。</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>今天出现一个问题</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> Symbol not <span class="string">found:</span> _OBJC_CLASS_$_NSMutableURLRequest</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br><span class="line">  Expected <span class="string">in:</span> <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CFNetwork.framework/CFNetwork</span><br><span class="line"> <span class="keyword">in</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br></pre></td></tr></table></figure>
<p>正好我升级了ios8 xcode的sdk也是ios8<br>照成这个原因是我用的smartlink已经在包里引用了CFNetwork.framework而我重复引用了。最后删掉就解决了<br>ps:奇怪的是我平时调试都没有出问题。今天拿到朋友手机就出现了。</p>]]>
    
    </summary>
    
      <category term="ios" scheme="http://ioschen.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[freebsd 10.0安装]]></title>
    <link href="http://ioschen.com/2014/04/05/freebsd/"/>
    <id>http://ioschen.com/2014/04/05/freebsd/</id>
    <published>2014-04-05T11:20:06.000Z</published>
    <updated>2014-04-05T12:36:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="理由">理由</h1><h1 id="下载">下载</h1><p><a href="http://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.0/" target="_blank" rel="external">下载地址</a></p>
<p>找到64为的这个</p>
<ol>
<li>FreeBSD-10.0-RELEASE-amd64-bootonly.iso    </li>
<li>FreeBSD-10.0-RELEASE-amd64-disc1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-dvd1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-memstick.img</li>
</ol>
<p>四个镜像文件</p>
<ol>
<li>第一个FreeBSD-10.0-RELEASE-amd64-bootonly.iso是可以引导的光盘，只能引导系统，通常用于网络安装。基本没用。</li>
<li>第二个FreeBSD-10.0-RELEASE-amd64-disc1.iso是系统光盘的第一张。用这张就可以安装一个基本的系统。其他的软件，在系统安装完之后安装。</li>
<li>第三个FreeBSD-10.0-RELEASE-amd64-dvd1.iso是系统盘的DVD版本。包括的软件比上一个多一点。不过这些软件通过网络也可以安装。看你的网速了。快的话，没用必要用这个。</li>
<li>第四个FreeBSD-10.0-RELEASE-amd64-memstick.img个是U盘镜像。用相关工具写入U盘就行。<br>还有一个是LiveCD。可以用它启动计算机进入系统。用来进行系统的演示，而不用进行硬盘的改动。当然了，也可以用它安装系统。</li>
</ol>
<p>这里我选择第三个,因为我的网络不是太好.<br><a id="more"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="理由">理由</h1><h1 id="下载">下载</h1><p><a href="http://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.0/">下载地址</a></p>
<p>找到64为的这个</p>
<ol>
<li>FreeBSD-10.0-RELEASE-amd64-bootonly.iso    </li>
<li>FreeBSD-10.0-RELEASE-amd64-disc1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-dvd1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-memstick.img</li>
</ol>
<p>四个镜像文件</p>
<ol>
<li>第一个FreeBSD-10.0-RELEASE-amd64-bootonly.iso是可以引导的光盘，只能引导系统，通常用于网络安装。基本没用。</li>
<li>第二个FreeBSD-10.0-RELEASE-amd64-disc1.iso是系统光盘的第一张。用这张就可以安装一个基本的系统。其他的软件，在系统安装完之后安装。</li>
<li>第三个FreeBSD-10.0-RELEASE-amd64-dvd1.iso是系统盘的DVD版本。包括的软件比上一个多一点。不过这些软件通过网络也可以安装。看你的网速了。快的话，没用必要用这个。</li>
<li>第四个FreeBSD-10.0-RELEASE-amd64-memstick.img个是U盘镜像。用相关工具写入U盘就行。<br>还有一个是LiveCD。可以用它启动计算机进入系统。用来进行系统的演示，而不用进行硬盘的改动。当然了，也可以用它安装系统。</li>
</ol>
<p>这里我选择第三个,因为我的网络不是太好.<br>]]>
    
    </summary>
    
      <category term="freebsd" scheme="http://ioschen.com/tags/freebsd/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎样才能改变一个人]]></title>
    <link href="http://ioschen.com/2014/04/03/jing/"/>
    <id>http://ioschen.com/2014/04/03/jing/</id>
    <published>2014-04-03T13:04:05.000Z</published>
    <updated>2014-04-03T14:08:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="怎样才能改变一个人">怎样才能改变一个人</h1><ul>
<li>自然改变</li>
<li>人为改变</li>
<li>环境改变</li>
</ul>
<p>到学校几天改变，比如一个人以前上课穿衬衫，但是学校要求必须裸体去上课，开始有一个人反对，这个人被退学了（或者主动离开了），忽然学生人群中有一个人带头脱掉上衣去上课。大家就都裸体了，随着时间的推移，大家就觉得这个很正常了，而看到别的学校都穿上衣上课就会感觉很鄙视，感觉别人是外星人。这个在军队，公司都是这样子吧，</p>
<p>一个人以前没见过米饭，只吃过面条，忽然有一天，有一个偶然的机会，去了一个城市，吃到了米饭，忽然觉得米饭才是人吃的，面条是什么啊，决定再也不回去了。</p>
<p>从小父母说去考公务员，考上了就可以为人民服务呢，经过十年寒窗苦读后发现事实并不是这个样子，我的领导做非法的，我的同事做非法的，我的下属也做非法的，我到底做不做呢，大家都这么做，我该不该做呢</p>
<p>一个学校裸体上课，老师想反正不是我的孩子，裸体有什么关系呢，根我没有关系都行，我什么都不管，只当娱乐吧，变态的娱乐吧。</p>
<p>什么才是对什么才是错</p>
<p>一个人一直坚信一个东西，忽然有一天大显自己坚信的东西被一个人所击败后，会是什么样子呢</p>
<p>一个人坚守一件事情很多年，忽然有一天这个坚守的东西被别人告知是不存在的，一开始肯定是极力不相信，非要找证据，找来找去，发现别人是对的，一直找不到证据，反而发现事实就是这个样子的，而最有理的证据就是这个打破事实的人，她简直就是恶魔啊，应该怎么对待 她呢，事实往往就是这么的无聊啊，你们说怎么做呢啊，你们什么时候发现就是这个样子的呢啊，什么人才是真的呢，了解一个人真的很重要，，高山流水啊，就是高山流水，高山流水，</p>
<p>知己知彼，百战不殆，我只想知道一个了解自己的人，了解真的很重要啊，你们说是不是啊，你们说是不是啊，我们就是脸皮后啊，你们说是不是啊，你们说是不是啊，我们就是这个意思啊，装逼有那么必要吗，，，，装逼的几个原则我已经全部做到了，我就是装逼的原则啊，</p>
<p>事情的真相往往就是让别人吐的，你们说是不是啊，我们就是这个意思啊，你们说呢啊，我们就是这个啊，你们这个我们就是这个啊，你们手是不是啊，我们的啊，是什么呢啊，你们什么的啊，没主意赢写了三签字呢啊，我们什么时候才能够整整的斯卡过uge人味儿啊，</p>
<p>我现在是不是有点犯浑呢啊， 我已经不想要毕业证呢啊，我开始思考人活着是为什么呢啊，到底要不要同流合污，还是做最干脆的自己。这个就会与一开始被盗相次啊，你们是不了解这个社会啊，什么时候的事情啊 ，你们说是不是啊，我们就是开始研究的啊，开始研讨会的啊，你们说是不是啊，我们就是这个意思ia，你们什么时候的事情那个啊，你们不知道啊，怎么知道啊，你们是什么的呢啊，是不是啊我们什么时候人才就是作贼做做你们什么时候</p>
<h3 id="人是不分年龄的，不分大小，我不管这个人多大，其实就是兄弟啊，你们说是不是啊，我们兄弟之间就是这个样子的啊，你们说是不死你们，为什么灰色这样字的啊_，我们就是不知道呢啊，你们手是什么圆瑛呢啊，">人是不分年龄的，不分大小，我不管这个人多大，其实就是兄弟啊，你们说是不是啊，我们兄弟之间就是这个样子的啊，你们说是不死你们，为什么灰色这样字的啊 ，我们就是不知道呢啊，你们手是什么圆瑛呢啊，</h3><p>我想去当兵啊，我不知道我为什么这么想呢啊， 我到底想干嘛啊，两年后我就24呢啊，我今年22两年后就是15呢啊，是不是啊，我们的大雾怎么样子呢啊，你们说是不是啊，我能够看出来她不喜欢当兵的，啊，，但是我喜欢它啊，你握手怎么办呢啊，这个人真的额是这个样子的按摩，你说再呢吗做呢啊，我就是喜欢她啊，我已经无法子吧呢啊，你们说是不是我么明年就是这个沿海字的啊吗，人怎么往往就是这么喜欢着iji的文章啊，很多时候都一几个不知道打了多少个字呢啊，你们什么时候你們什麼手是的我們就是中國兒女啊，你們什麼時候開始的啊，　</p>
<hr>
<h1 id="为什么要改变一个人">为什么要改变一个人</h1><hr>
<h1 id="正义">正义</h1><p>在我很小的时候，师长经常问我们想做什么，大多数都说做科学家，医生，解放军，而我当年说的什么我已经记不清楚了，按道理说自己的梦想印象能不深吗？还能忘记？这个怎么可能？但是事实往往就是如此，一个很小的孩子怎么可能知道梦想呢，（我不研究概率）</p>
<p>为什么上学？<br>很多时候我疑问为什么要上学，上学是干嘛的，我一直觉得上学是成年人为了甩开小孩，让小孩不再成为负担，但是 以前不是这样的，新中国之前，小孩可以打打下手，比如木匠可以拿木头，学学技术，而现在研究化学，智能学习</p>
<h4 id="正式话题">正式话题</h4><p>其实我想说的是怎样判定一个人是好人还是坏人，</p>
<p>恐怖组织是什么意思，如果我就是想死，但是死之前杀掉一些人，这个难道不对吗？我只想说站在杀人者的角度来想，这个一点也没有错，因为他们就是这个样子的啊。你说是不是啊，</p>
<p>怎样才能改变一个人，</p>
<h1 id="计划，事情没有计划做不好。">计划，事情没有计划做不好。</h1><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="怎样才能改变一个人">怎样才能改变一个人</h1><ul>
<li>自然改变</li>
<li>人为改变</li>
<li>环境改变</li>
</ul>
<p>到学校几天改变，比如一个人以前上课穿衬衫，但是学校要求必须裸体去上课，开始有一个人反对，这个人被退学了（或者主动离开了），忽然学生人群中有一个人带头脱掉上衣去上课。大家就都裸体了，随着时间的推移，大家就觉得这个很正常了，而看到别的学校都穿上衣上课就会感觉很鄙视，感觉别人是外星人。这个在军队，公司都是这样子吧，</p>
<p>一个人以前没见过米饭，只吃过面条，忽然有一天，有一个偶然的机会，去了一个城市，吃到了米饭，忽然觉得米饭才是人吃的，面条是什么啊，决定再也不回去了。</p>
<p>从小父母说去考公务员，考上了就可以为人民服务呢，经过十年寒窗苦读后发现事实并不是这个样子，我的领导做非法的，我的同事做非法的，我的下属也做非法的，我到底做不做呢，大家都这么做，我该不该做呢</p>
<p>一个学校裸体上课，老师想反正不是我的孩子，裸体有什么关系呢，根我没有关系都行，我什么都不管，只当娱乐吧，变态的娱乐吧。</p>
<p>什么才是对什么才是错</p>
<p>一个人一直坚信一个东西，忽然有一天大显自己坚信的东西被一个人所击败后，会是什么样子呢</p>
<p>一个人坚守一件事情很多年，忽然有一天这个坚守的东西被别人告知是不存在的，一开始肯定是极力不相信，非要找证据，找来找去，发现别人是对的，一直找不到证据，反而发现事实就是这个样子的，而最有理的证据就是这个打破事实的人，她简直就是恶魔啊，应该怎么对待 她呢，事实往往就是这么的无聊啊，你们说怎么做呢啊，你们什么时候发现就是这个样子的呢啊，什么人才是真的呢，了解一个人真的很重要，，高山流水啊，就是高山流水，高山流水，</p>
<p>知己知彼，百战不殆，我只想知道一个了解自己的人，了解真的很重要啊，你们说是不是啊，你们说是不是啊，我们就是脸皮后啊，你们说是不是啊，你们说是不是啊，我们就是这个意思啊，装逼有那么必要吗，，，，装逼的几个原则我已经全部做到了，我就是装逼的原则啊，</p>
<p>事情的真相往往就是让别人吐的，你们说是不是啊，我们就是这个意思啊，你们说呢啊，我们就是这个啊，你们这个我们就是这个啊，你们手是不是啊，我们的啊，是什么呢啊，你们什么的啊，没主意赢写了三签字呢啊，我们什么时候才能够整整的斯卡过uge人味儿啊，</p>
<p>我现在是不是有点犯浑呢啊， 我已经不想要毕业证呢啊，我开始思考人活着是为什么呢啊，到底要不要同流合污，还是做最干脆的自己。这个就会与一开始被盗相次啊，你们是不了解这个社会啊，什么时候的事情啊 ，你们说是不是啊，我们就是开始研究的啊，开始研讨会的啊，你们说是不是啊，我们就是这个意思ia，你们什么时候的事情那个啊，你们不知道啊，怎么知道啊，你们是什么的呢啊，是不是啊我们什么时候人才就是作贼做做你们什么时候</p>
<h3 id="人是不分年龄的，不分大小，我不管这个人多大，其实就是兄弟啊，你们说是不是啊，我们兄弟之间就是这个样子的啊，你们说是不死你们，为什么灰色这样字的啊_，我们就是不知道呢啊，你们手是什么圆瑛呢啊，">人是不分年龄的，不分大小，我不管这个人多大，其实就是兄弟啊，你们说是不是啊，我们兄弟之间就是这个样子的啊，你们说是不死你们，为什么灰色这样字的啊 ，我们就是不知道呢啊，你们手是什么圆瑛呢啊，</h3><p>我想去当兵啊，我不知道我为什么这么想呢啊， 我到底想干嘛啊，两年后我就24呢啊，我今年22两年后就是15呢啊，是不是啊，我们的大雾怎么样子呢啊，你们说是不是啊，我能够看出来她不喜欢当兵的，啊，，但是我喜欢它啊，你握手怎么办呢啊，这个人真的额是这个样子的按摩，你说再呢吗做呢啊，我就是喜欢她啊，我已经无法子吧呢啊，你们说是不是我么明年就是这个沿海字的啊吗，人怎么往往就是这么喜欢着iji的文章啊，很多时候都一几个不知道打了多少个字呢啊，你们什么时候你們什麼手是的我們就是中國兒女啊，你們什麼時候開始的啊，　</p>
<hr>
<h1 id="为什么要改变一个人">为什么要改变一个人</h1><hr>
<h1 id="正义">正义</h1><p>在我很小的时候，师长经常问我们想做什么，大多数都说做科学家，医生，解放军，而我当年说的什么我已经记不清楚了，按道理说自己的梦想印象能不深吗？还能忘记？这个怎么可能？但是事实往往就是如此，一个很小的孩子怎么可能知道梦想呢，（我不研究概率）</p>
<p>为什么上学？<br>很多时候我疑问为什么要上学，上学是干嘛的，我一直觉得上学是成年人为了甩开小孩，让小孩不再成为负担，但是 以前不是这样的，新中国之前，小孩可以打打下手，比如木匠可以拿木头，学学技术，而现在研究化学，智能学习</p>
<h4 id="正式话题">正式话题</h4><p>其实我想说的是怎样判定一个人是好人还是坏人，</p>
<p>恐怖组织是什么意思，如果我就是想死，但是死之前杀掉一些人，这个难道不对吗？我只想说站在杀人者的角度来想，这个一点也没有错，因为他们就是这个样子的啊。你说是不是啊，</p>
<p>怎样才能改变一个人，</p>
<h1 id="计划，事情没有计划做不好。">计划，事情没有计划做不好。</h1>]]>
    
    </summary>
    
      <category term="人性" scheme="http://ioschen.com/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[宏:标准控制结构]]></title>
    <link href="http://ioschen.com/2014/04/01/controlstructure/"/>
    <id>http://ioschen.com/2014/04/01/controlstructure/</id>
    <published>2014-04-01T01:32:28.000Z</published>
    <updated>2014-04-06T14:22:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="引导">引导</h1><p>lisp和其他语言一样，有条件表达式，垃圾收集，但是lisp的宏系统却始终使他保持了在语言风格上的独特性。lisp的宏和任何语言的“宏”是不一样的。这个东西很难解释。</p>
<p>语言都有一个“核心”语言实现的标准功能库（java的JDK），如果某些功能没有定义在标准库中，可以自己实现。（求平凡实现列子）</p>
<p>。。。。。。</p>
<h1 id="WHEN和UNLESS">WHEN和UNLESS</h1><p>最基本的条件执行形式是IF特殊操作符，其基本形式是:如果x成立，那么执行y，否则执行z。</p>
<p><code>(if condition then-form [else-form])</code></p>
<p>condition被求值，如果其值非NIL，那么then-form会被求值并返回其结果。否则，如果有else-form，他将被求值并返回其结果。如果condition是NIL并且没有else-form，那么IF返回NIL。（<font color="red">condition是判断条件，如果为nil就返回then-form的值，否则要是有else-form就返回else-form的值。如果只有condition并且值是nil就返回nil</font>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"YES"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"no"</span></span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"yes"</span>)</span></span><br><span class="line">NIL</span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">3</span> <span class="number">2</span>)</span><span class="string">"yes"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"yes"</span></span><br></pre></td></tr></table></figure>
<p>有一个情况不行，当条件成立，连续执行两个就不可以，因为会被当成else执行。要想在条件语句执行多个就必须使用progn特殊操作符。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">progn</span></span><br><span class="line"> 		<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line"> 		<span class="list">(<span class="keyword">update</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如上面，这样才会在a成立的时候执行into再执行update。</p>
<p>其lisp提供了一个标准宏WHEN 就是解决这个问题的。上面的可以写成这个样子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">update</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果它没有被内置到标准库中，你也可以像下面这样用一个宏来定义WHEN<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> ,condition <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>与WHEN宏同系列的另一个宏是UNLESS 它取相反条件，只有条件假的时候才求值其形式体。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> ,condition)</span> <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><del>其实上面的定义不对，因为重新定义when所在的common-lisp包中的名字是非法的，如果非要这么做，可以修改名字，比如my-when</del></p>
<h1 id="COND">COND</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> a</span><br><span class="line">	<span class="list">(<span class="keyword">do-x</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> b</span><br><span class="line">		<span class="list">(<span class="keyword">do-y</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">do-z</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>多重分支用if是可以，但是比较丑陋</p>
<p>如果子句再分很多就更丑了，但是lisp提供了一个<code>用于表达多重分支条件的宏COND</code>基本结构如下</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">cond</span></span></span><br><span class="line">	<span class="list">(<span class="keyword">test-1</span> form*)</span></span><br><span class="line">	<span class="list">(<span class="keyword">test-2</span> form*)</span></span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	<span class="list">(<span class="keyword">test-N</span> form*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="AND、OR和NOT">AND、OR和NOT</h1><h1 id="循环">循环</h1><h1 id="DOLIST和DOTIMES">DOLIST和DOTIMES</h1><h1 id="DO">DO</h1><h1 id="强大的LOOP">强大的LOOP</h1><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="引导">引导</h1><p>lisp和其他语言一样，有条件表达式，垃圾收集，但是lisp的宏系统却始终使他保持了在语言风格上的独特性。lisp的宏和任何语言的“宏”是不一样的。这个东西很难解释。</p>
<p>语言都有一个“核心”语言实现的标准功能库（java的JDK），如果某些功能没有定义在标准库中，可以自己实现。（求平凡实现列子）</p>
<p>。。。。。。</p>
<h1 id="WHEN和UNLESS">WHEN和UNLESS</h1><p>最基本的条件执行形式是IF特殊操作符，其基本形式是:如果x成立，那么执行y，否则执行z。</p>
<p><code>(if condition then-form [else-form])</code></p>
<p>condition被求值，如果其值非NIL，那么then-form会被求值并返回其结果。否则，如果有else-form，他将被求值并返回其结果。如果condition是NIL并且没有else-form，那么IF返回NIL。（<font color=red>condition是判断条件，如果为nil就返回then-form的值，否则要是有else-form就返回else-form的值。如果只有condition并且值是nil就返回nil</font>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"YES"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"no"</span></span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"yes"</span>)</span></span><br><span class="line">NIL</span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">3</span> <span class="number">2</span>)</span><span class="string">"yes"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"yes"</span></span><br></pre></td></tr></table></figure>
<p>有一个情况不行，当条件成立，连续执行两个就不可以，因为会被当成else执行。要想在条件语句执行多个就必须使用progn特殊操作符。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">progn</span></span><br><span class="line"> 		<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line"> 		<span class="list">(<span class="keyword">update</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如上面，这样才会在a成立的时候执行into再执行update。</p>
<p>其lisp提供了一个标准宏WHEN 就是解决这个问题的。上面的可以写成这个样子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">update</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果它没有被内置到标准库中，你也可以像下面这样用一个宏来定义WHEN<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> ,condition <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>与WHEN宏同系列的另一个宏是UNLESS 它取相反条件，只有条件假的时候才求值其形式体。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> ,condition)</span> <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><del>其实上面的定义不对，因为重新定义when所在的common-lisp包中的名字是非法的，如果非要这么做，可以修改名字，比如my-when</del></p>
<h1 id="COND">COND</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> a</span><br><span class="line">	<span class="list">(<span class="keyword">do-x</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> b</span><br><span class="line">		<span class="list">(<span class="keyword">do-y</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">do-z</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>多重分支用if是可以，但是比较丑陋</p>
<p>如果子句再分很多就更丑了，但是lisp提供了一个<code>用于表达多重分支条件的宏COND</code>基本结构如下</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">cond</span></span></span><br><span class="line">	<span class="list">(<span class="keyword">test-1</span> form*)</span></span><br><span class="line">	<span class="list">(<span class="keyword">test-2</span> form*)</span></span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	<span class="list">(<span class="keyword">test-N</span> form*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="AND、OR和NOT">AND、OR和NOT</h1><h1 id="循环">循环</h1><h1 id="DOLIST和DOTIMES">DOLIST和DOTIMES</h1><h1 id="DO">DO</h1><h1 id="强大的LOOP">强大的LOOP</h1>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[freebook]]></title>
    <link href="http://ioschen.com/2014/03/30/freebook/"/>
    <id>http://ioschen.com/2014/03/30/freebook/</id>
    <published>2014-03-30T12:57:31.000Z</published>
    <updated>2014-03-30T12:58:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="免费的编程中文书籍索引">免费的编程中文书籍索引</h1><h3 id="转载地点"><a href="https://github.com/Yixiaohan/free-programming-books-zh_CN" target="_blank" rel="external">转载地点</a></h3><hr>
<p>免费的编程中文书籍索引，欢迎投稿。</p>
<ul>
<li>国外程序员在 <a href="http://stackoverflow.com/a/1713/343194" target="_blank" rel="external">stackoverflow</a> 推荐的程序员必读书籍，<a href="http://justjavac.com/other/2012/05/15/qualified-programmer-should-read-what-books.html" title="一个合格的程序员应该读过哪些书" target="_blank" rel="external">中文版</a>。</li>
<li><a href="http://stackoverflow.com/q/38210/343194" target="_blank" rel="external">stackoverflow</a> 上的程序员应该阅读的非编程类书籍有哪些？ <a href="what-non-programming-books-should-programmers-read.md">中文版</a></li>
<li><a href="https://github.com/vhf/free-programming-books" target="_blank" rel="external">github</a> 上的一个流行的编程书籍索引  <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-ch.md" target="_blank" rel="external">中文版</a></li>
</ul>
<h2 id="参与交流">参与交流</h2><p>欢迎大家讲珍藏已久的经典免费书籍共享出来，您可以：</p>
<ul>
<li>使用 <a href="https://github.com/justjavac/free-programming-books-zh_CN/issues" target="_blank" rel="external">Issues</a> 以及 Pull Request </li>
<li>发邮箱给我 <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x6a;&#x75;&#115;&#x74;&#x6a;&#x61;&#x76;&#97;&#99;&#x2b;&#103;&#x68;&#x62;&#x6f;&#111;&#107;&#x73;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x75;&#115;&#x74;&#x6a;&#x61;&#x76;&#97;&#99;&#x2b;&#103;&#x68;&#x62;&#x6f;&#111;&#107;&#x73;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a></li>
<li>来 <a href="http://segmentfault.com/q/1010000000329895" target="_blank" rel="external">SegmentFault</a> 交流</li>
</ul>
<p><strong>注</strong>：看到有人 fork 此 repository，其实如果觉得有帮助，可以 star 或者 watch，<br>如果 fork 到你的 repositories 下则不能保证你的 repo 是最新的，除非是主动定期的 pull。</p>
<ul>
<li>star 的作用是收藏，目的是方便以后查找。</li>
<li>watch 的作用是关注，目的是等我更新的时候，你可以收到通知。</li>
<li>fork 的作用是参与，目的是你增加新的内容，然后 Pull Request，我会考虑把你的修改和我原来的内容合并。</li>
</ul>
<p>请选择合理的方式。（上面的内容是写给一些 fork 狂的，很多开发者喜欢 fork 一些 linux 内核，jquery之类的东东，其实这些东东完全没有必要 fork）</p>
<h2 id="捐赠与福利">捐赠与福利</h2><p>如果觉得我收录的内容对你有帮助，可以捐赠我点比特币 <code>15hfB3YMe31TkLz9vS8ybY7NFGHRXr2HyP</code>。</p>
<p>如果你没有可以去这儿<strong>免费领取</strong>：<a href="https://github.com/freebitcoin/freebitcoin" target="_blank" rel="external">如何免费获得比特币？</a></p>
<h2 id="目录">目录</h2><ul>
<li><p><a href="#语言无关类">语言无关类</a></p>
<ul>
<li><a href="#操作系统">操作系统</a></li>
<li><a href="#web服务器">WEB服务器</a></li>
<li><a href="#版本控制">版本控制</a></li>
<li><a href="#nosql">NoSQL</a></li>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#项目相关">项目相关</a></li>
<li><a href="#web">Web</a></li>
</ul>
</li>
<li><p><a href="#语言相关类">语言相关类</a></p>
<ul>
<li><a href="#cc">C/C++</a></li>
<li><a href="$css">CSS</a></li>
<li><a href="#dart">Dart</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#ios">iOS</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#shell">Shell</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#groovy">Groovy</a></li>
<li><a href="#lisp">LISP</a></li>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#scala">Scala</a></li>
</ul>
</li>
<li><p><a href="#读书笔记及其它">读书笔记及其它</a></p>
</li>
</ul>
<h2 id="语言无关类">语言无关类</h2><h3 id="操作系统">操作系统</h3><ul>
<li><a href="http://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="external">开源世界旅行手册</a></li>
<li><a href="http://vbird.dic.ksu.edu.tw/" target="_blank" rel="external">鸟哥的Linux私房菜</a> (简体)</li>
<li><a href="http://sourceforge.net/apps/trac/elpi/wiki/ALP" target="_blank" rel="external">Linux 系统高级编程</a></li>
<li><a href="http://billie66.github.io/TLCL/index.html" target="_blank" rel="external">The Linux Command Line</a> (中英文版)</li>
</ul>
<h3 id="WEB服务器">WEB服务器</h3><ul>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="external">Nginx开发从入门到精通</a> (淘宝团队出品)</li>
</ul>
<h3 id="版本控制">版本控制</h3><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简易指南</a></li>
<li><a href="http://gitref.justjavac.com" target="_blank" rel="external">Git 参考手册</a></li>
<li><a href="http://git-scm.com/book/zh" target="_blank" rel="external">Pro Git</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git Magic</a></li>
</ul>
<h3 id="NoSQL">NoSQL</h3><ul>
<li><a href="http://www.yankay.com/wp-content/NoSql_Database_Note.html" target="_blank" rel="external">NoSQL数据库笔谈</a> (<a href="http://yankaycom-wordpress.stor.sinaapp.com/uploads/2012/12/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%B0%88v2.pdf" target="_blank" rel="external">PDF</a>)</li>
<li><a href="http://www.redisbook.com/en/latest/" target="_blank" rel="external">Redis 设计与实现</a></li>
<li><a href="http://www.redisdoc.com/en/latest/" target="_blank" rel="external">Redis 命令参考</a></li>
<li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md" target="_blank" rel="external">The Little MongoDB Book</a></li>
<li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md" target="_blank" rel="external">The Little Redis Book</a></li>
</ul>
<h3 id="MySQL">MySQL</h3><ul>
<li><a href="http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></li>
</ul>
<h3 id="项目相关">项目相关</h3><ul>
<li><a href="http://article.yeeyan.org/view/2251/94882" target="_blank" rel="external">持续集成（第二版）</a> (译言网)</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-ap/" target="_blank" rel="external">让开发自动化系列专栏</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-cq/" target="_blank" rel="external">追求代码质量</a></li>
<li><a href="https://github.com/fool2fish/selenium-doc" target="_blank" rel="external">selenium 中文文档</a></li>
</ul>
<h3 id="Web">Web</h3><ul>
<li><a href="http://www.20thingsilearned.com/zh-CN/home" target="_blank" rel="external">关于浏览器和网络的 20 项须知</a> </li>
<li><a href="http://knowledge.ecomfe.com/" target="_blank" rel="external">前端知识体系</a></li>
<li><a href="http://jinlong.github.io/blog/2013/08/29/devtoolsecrets/" target="_blank" rel="external">浏览器开发工具的秘密</a></li>
<li><a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">Chrome扩展开发文档</a></li>
</ul>
<h2 id="语言相关类">语言相关类</h2><h3 id="C/C++">C/C++</h3><ul>
<li><a href="https://github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial" target="_blank" rel="external">C++ 并发编程指南</a> (<a href="http://weibo.com/1702076100" target="_blank" rel="external">@傅海平ICT</a>)</li>
<li><a href="http://learn.akae.cn/media/index.html" target="_blank" rel="external">Linux C编程一站式学习</a> (宋劲杉, 北京亚嵌教育研究中心)</li>
<li><a href="https://github.com/leeyiw/cgdb-manual-in-chinese" target="_blank" rel="external">CGDB中文手册</a></li>
<li><a href="https://github.com/anjuke/zguide-cn" target="_blank" rel="external">ZMQ 指南</a></li>
</ul>
<h3 id="CSS">CSS</h3><ul>
<li><a href="http://zh.learnlayout.com/" target="_blank" rel="external">学习CSS布局</a></li>
<li><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md" target="_blank" rel="external">通用 CSS 笔记、建议与指导</a></li>
</ul>
<h3 id="Dart">Dart</h3><ul>
<li><a href="http://dart.lidian.info/wiki/Language_Tour" target="_blank" rel="external">Dart 语言导览</a></li>
</ul>
<h3 id="Java">Java</h3><ul>
<li><p><a href="http://www.ibm.com/developerworks/cn/java/j-rtj/?ca=j-h-p" target="_blank" rel="external">实时 Java 系列</a></p>
</li>
<li><p>使用 Eclipse 和 Java SE 6 创建独立 Web Services 应用程序</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/webservices/ws-eclipse-javase1/index.html" target="_blank" rel="external">第 1 部分: Web Services 服务端应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/webservices/tutorials/ws-jse/index.html" target="_blank" rel="external">第 2 部分: Web 服务客户端应用程序</a></li>
</ul>
</li>
<li>JavaServer Faces 1.2 入门<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jsf1/index.html" target="_blank" rel="external">第 1 部分: 构建基本应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jsf2/index.html" target="_blank" rel="external">第 2 部分: JSF 生命周期、转换、检验和阶段监听器</a></li>
</ul>
</li>
<li>用 Eclipse Europa 进行 Web 开发<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa1/index.html" target="_blank" rel="external">第 1 部分: Eclipse Java EE</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa2/index.html" target="_blank" rel="external">第 2 部分: PHP 开发工具</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa3/index.html" target="_blank" rel="external">第 3 部分: Ruby Development Toolkit 和 RadRails</a></li>
</ul>
</li>
<li>使用 JavaServer Faces 构建 Apache Geronimo 应用程序<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf1/index.html" target="_blank" rel="external">第 1 部分: 使用 Eclipse 和 Apache MyFaces Core 构建基本的应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf2/index.html" target="_blank" rel="external">第 2 部分: 在 JavaServer Faces 中使用 Tomahawk</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf3/index.html" target="_blank" rel="external">第 3 部分: 使用 ajax4jsf 添加 Ajax 功能</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf4/index.html" target="_blank" rel="external">第 4 部分: 使用 Apache Trinidad 组件扩展 JSF</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf5/index.html" target="_blank" rel="external">第 5 部分: 将 JSF 应用程序与 Spring 集成</a></li>
</ul>
</li>
<li>Apache Geronimo 和 Spring 框架<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe1/index.html" target="_blank" rel="external">第 1 部分: 开发方法学</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe2/index.html" target="_blank" rel="external">第 2 部分: 构建第一个应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe3/index.html" target="_blank" rel="external">第 3 部分: 集成 DAO 与 ORM</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe4/index.html" target="_blank" rel="external">第 4 部分: 混合使用 Spring AOP 和 Spring Web Flow</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe5/index.html" target="_blank" rel="external">第 5 部分: Spring MVC</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe6/index.html" target="_blank" rel="external">第 6 部分: Spring MVC：使用 Web 视图技术</a></li>
</ul>
</li>
<li>终极 mashup —— Web 服务和语义 Web<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup1/index.html" target="_blank" rel="external">第 1 部分: 使用与组合 Web 服务</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup2/index.html" target="_blank" rel="external">第 2 部分: 管理 Mashup 数据缓存</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup3/index.html" target="_blank" rel="external">第 3 部分: 理解 RDF 和 RDFs</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup4/index.html" target="_blank" rel="external">第 4 部分: 创建本体</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup5/index.html" target="_blank" rel="external">第 5 部分: 切换 Web 服务</a></li>
</ul>
</li>
</ul>
<h3 id="JavaScript">JavaScript</h3><ul>
<li><a href="http://chajn.org/jsguide/javascriptguide.html" target="_blank" rel="external">Google JavaScript 代码风格指南</a></li>
<li><a href="https://github.com/adamlu/javascript-style-guide" target="_blank" rel="external">Airbnb JavaScript 规范</a></li>
<li><a href="https://github.com/justjavac/12-javascript-quirks" target="_blank" rel="external">javascript 的 12 个怪癖</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="external">JavaScript 秘密花园</a></li>
<li><a href="http://icodeit.org/jsccp/" target="_blank" rel="external">JavaScript核心概念及实践</a> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</li>
<li><a href="http://justjavac.com/named-function-expressions-demystified.html" target="_blank" rel="external">命名函数表达式探秘</a>  (注:原文由<a href="http://www.cn-cuckoo.com" target="_blank" rel="external">为之漫笔</a>翻译，原始地址无法打开，所以此处地址为我博客上的备份)</li>
<li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns" target="_blank" rel="external">学用 JavaScript 设计模式</a> (开源中国)</li>
<li>Node.js<ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">Node入门</a></li>
<li><a href="https://github.com/nodejs-tw/nodejs-wiki-book" target="_blank" rel="external">Nodejs Wiki Book</a> (繁体中文)</li>
<li><a href="http://sofish.github.io/express-guide/" target="_blank" rel="external">express.js 指南</a></li>
</ul>
</li>
<li>backbone.js<ul>
<li><a href="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html" target="_blank" rel="external">backbone.js入门教程</a> (PDF)</li>
<li><a href="https://github.com/the5fire/backbonejs-learning-note" target="_blank" rel="external">Backbone.js入门教程第二版</a></li>
<li><a href="http://feliving.github.io/developing-backbone-applications" target="_blank" rel="external">Developing Backbone.js Applications(中文版)</a></li>
</ul>
</li>
<li>AngularJS<ul>
<li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md" target="_blank" rel="external">AngularJS最佳实践和风格指南</a></li>
<li><a href="https://github.com/basestyle/angularjs-cn" target="_blank" rel="external">AngularJS中译本</a> </li>
</ul>
</li>
<li><a href="http://www.360weboy.com/handbook/zepto/index.html" target="_blank" rel="external">zepto 简明中文手册</a> </li>
</ul>
<h3 id="PHP">PHP</h3><ul>
<li><a href="http://www.laruence.com/2010/06/21/1608.html" target="_blank" rel="external">PHP调试技术手册</a>(PDF)</li>
<li><a href="https://github.com/wulijun/php-the-right-way" target="_blank" rel="external">PHP之道</a></li>
<li><a href="https://github.com/justjavac/PHP-Best-Practices-zh_CN" target="_blank" rel="external">PHP 最佳实践</a></li>
<li><a href="https://github.com/reeze/tipi" target="_blank" rel="external">深入理解PHP内核</a></li>
<li><a href="http://www.walu.cc/phpbook/" target="_blank" rel="external">PHP扩展开发及内核应用</a></li>
<li><a href="http://codeigniter.org.cn/user_guide/index.html" target="_blank" rel="external">CodeIgniter 用户指南</a></li>
<li><a href="http://www.golaravel.com/docs/" target="_blank" rel="external">Laravel4 中文文档</a></li>
<li><a href="http://symfony-docs-chs.readthedocs.org/en/latest/" target="_blank" rel="external">Symfony2中文文档</a> (未译完)</li>
</ul>
<h3 id="iOS">iOS</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md" target="_blank" rel="external">iOS开发60分钟入门</a></li>
</ul>
<h3 id="Python">Python</h3><ul>
<li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/" target="_blank" rel="external">简明Python教程</a></li>
<li><a href="http://liam0205.me/Python-tutorial-zh_cn/" target="_blank" rel="external">Python入门教程</a> (<a href="http://liam0205.me/attachment/Python/The_Python_Tutorial_zh-cn.pdf" target="_blank" rel="external">PDF</a>)</li>
<li><a href="http://article.yeeyan.org/view/311527/287706" target="_blank" rel="external">Python的神奇方法指南</a></li>
<li><a href="https://django-document-cn.readthedocs.org/en/latest/" target="_blank" rel="external">Django 文档中文版</a></li>
<li><a href="https://github.com/brantyoung/zh-django-best-practices" target="_blank" rel="external">Django 最佳实践</a></li>
<li><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="external">The Django Book 中文版</a></li>
<li><a href="http://webpy.org/tutorial3.zh-cn" target="_blank" rel="external">web.py 0.3 新手指南</a></li>
<li><a href="http://webpy.org/cookbook/index.zh-cn" target="_blank" rel="external">Web.py Cookbook 简体中文版</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython/" target="_blank" rel="external">Dive Into Python 中文版</a></li>
<li><a href="http://bottlepy.org/docs/dev-cn/" target="_blank" rel="external">Bottle 文档中文版</a></li>
<li><a href="http://docs.torriacg.org/docs/flask/" target="_blank" rel="external">Flask 文档中文版</a></li>
</ul>
<h3 id="Ruby">Ruby</h3><ul>
<li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Ruby 风格指南</a></li>
<li><a href="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Rails 风格指南</a></li>
<li><a href="http://railstutorial-china.org/" target="_blank" rel="external">Ruby on Rails Tutorial 原书第 2 版</a> (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元)</li>
</ul>
<h3 id="Shell">Shell</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="external">Shell脚本编程30分钟入门</a></li>
</ul>
<h3 id="Go">Go</h3><ul>
<li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="external">Go编程基础</a></li>
<li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="external">Go入门指南</a></li>
<li><a href="http://mikespook.com/learning-go/" target="_blank" rel="external">学习Go语言</a> (<a href="http://xxiyy.qiniudn.com/%E5%AD%A6%E4%B9%A0%20Go%20%E8%AF%AD%E8%A8%80\(Golang\" target="_blank" rel="external">PDF</a>.pdf?download))</li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="external">Go Web 编程</a> (此书已经出版，希望开发者们去购买，支持作者的创作)</li>
<li><a href="https://github.com/astaxie/Go-in-Action" target="_blank" rel="external">Go实战开发</a> (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者<a href="https://me.alipay.com/astaxie" target="_blank" rel="external">捐赠</a>，以鼓励作者的继续创作)</li>
<li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="external">Network programming with Go 中文翻译版本</a></li>
</ul>
<h3 id="Groovy">Groovy</h3><ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-pg/" target="_blank" rel="external">实战 Groovy 系列</a></li>
</ul>
<h3 id="LISP">LISP</h3><ul>
<li><a href="http://acl.readthedocs.org/en/latest/" target="_blank" rel="external">ANSI Common Lisp 中文翻譯版</a></li>
</ul>
<h3 id="Haskell">Haskell</h3><ul>
<li><a href="http://rwh.readthedocs.org/en/latest/" target="_blank" rel="external">Real World Haskell 中文版</a></li>
</ul>
<h3 id="Scala">Scala</h3><ul>
<li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="external">Scala课堂</a> (Twitter的Scala中文教程)</li>
</ul>
<h3 id="读书笔记及其它">读书笔记及其它</h3><ul>
<li><a href="https://github.com/fool2fish/dragon-book-exercise-answers" target="_blank" rel="external">编译原理（紫龙书）中文第2版习题答案</a></li>
<li><a href="http://hawstein.com/posts/make-thiner-programming-pearls.html" target="_blank" rel="external">把《编程珠玑》读薄</a></li>
<li><a href="https://github.com/XiaolongJason/ReadingNote/blob/master/Effective%20C%2B%2B/Effective%20C%2B%2B.md" target="_blank" rel="external">Effective C++读书笔记</a></li>
<li><a href="https://github.com/qyuhen/book" target="_blank" rel="external">Golang 学习笔记、Python 学习笔记、C 学习笔记</a> (PDF)</li>
<li><a href="https://github.com/code4craft/jsoup-learning" target="_blank" rel="external">Jsoup 学习笔记</a></li>
<li><a href="https://github.com/lzjun567/note" target="_blank" rel="external">学习笔记: Vim、Python、memcached</a></li>
</ul>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="免费的编程中文书籍索引">免费的编程中文书籍索引</h1><h3 id="转载地点"><a href="https://github.com/Yixiaohan/free-programming-books-zh_CN">转载地点</a></h3><hr>
<p>免费的编程中文书籍索引，欢迎投稿。</p>
<ul>
<li>国外程序员在 <a href="http://stackoverflow.com/a/1713/343194">stackoverflow</a> 推荐的程序员必读书籍，<a href="http://justjavac.com/other/2012/05/15/qualified-programmer-should-read-what-books.html" title="一个合格的程序员应该读过哪些书">中文版</a>。</li>
<li><a href="http://stackoverflow.com/q/38210/343194">stackoverflow</a> 上的程序员应该阅读的非编程类书籍有哪些？ <a href="what-non-programming-books-should-programmers-read.md">中文版</a></li>
<li><a href="https://github.com/vhf/free-programming-books">github</a> 上的一个流行的编程书籍索引  <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-ch.md">中文版</a></li>
</ul>
<h2 id="参与交流">参与交流</h2><p>欢迎大家讲珍藏已久的经典免费书籍共享出来，您可以：</p>
<ul>
<li>使用 <a href="https://github.com/justjavac/free-programming-books-zh_CN/issues">Issues</a> 以及 Pull Request </li>
<li>发邮箱给我 <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x6a;&#x75;&#115;&#x74;&#x6a;&#x61;&#x76;&#97;&#99;&#x2b;&#103;&#x68;&#x62;&#x6f;&#111;&#107;&#x73;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x75;&#115;&#x74;&#x6a;&#x61;&#x76;&#97;&#99;&#x2b;&#103;&#x68;&#x62;&#x6f;&#111;&#107;&#x73;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a></li>
<li>来 <a href="http://segmentfault.com/q/1010000000329895">SegmentFault</a> 交流</li>
</ul>
<p><strong>注</strong>：看到有人 fork 此 repository，其实如果觉得有帮助，可以 star 或者 watch，<br>如果 fork 到你的 repositories 下则不能保证你的 repo 是最新的，除非是主动定期的 pull。</p>
<ul>
<li>star 的作用是收藏，目的是方便以后查找。</li>
<li>watch 的作用是关注，目的是等我更新的时候，你可以收到通知。</li>
<li>fork 的作用是参与，目的是你增加新的内容，然后 Pull Request，我会考虑把你的修改和我原来的内容合并。</li>
</ul>
<p>请选择合理的方式。（上面的内容是写给一些 fork 狂的，很多开发者喜欢 fork 一些 linux 内核，jquery之类的东东，其实这些东东完全没有必要 fork）</p>
<h2 id="捐赠与福利">捐赠与福利</h2><p>如果觉得我收录的内容对你有帮助，可以捐赠我点比特币 <code>15hfB3YMe31TkLz9vS8ybY7NFGHRXr2HyP</code>。</p>
<p>如果你没有可以去这儿<strong>免费领取</strong>：<a href="https://github.com/freebitcoin/freebitcoin">如何免费获得比特币？</a></p>
<h2 id="目录">目录</h2><ul>
<li><p><a href="#语言无关类">语言无关类</a></p>
<ul>
<li><a href="#操作系统">操作系统</a></li>
<li><a href="#web服务器">WEB服务器</a></li>
<li><a href="#版本控制">版本控制</a></li>
<li><a href="#nosql">NoSQL</a></li>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#项目相关">项目相关</a></li>
<li><a href="#web">Web</a></li>
</ul>
</li>
<li><p><a href="#语言相关类">语言相关类</a></p>
<ul>
<li><a href="#cc">C/C++</a></li>
<li><a href="$css">CSS</a></li>
<li><a href="#dart">Dart</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#ios">iOS</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#shell">Shell</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#groovy">Groovy</a></li>
<li><a href="#lisp">LISP</a></li>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#scala">Scala</a></li>
</ul>
</li>
<li><p><a href="#读书笔记及其它">读书笔记及其它</a></p>
</li>
</ul>
<h2 id="语言无关类">语言无关类</h2><h3 id="操作系统">操作系统</h3><ul>
<li><a href="http://i.linuxtoy.org/docs/guide/index.html">开源世界旅行手册</a></li>
<li><a href="http://vbird.dic.ksu.edu.tw/">鸟哥的Linux私房菜</a> (简体)</li>
<li><a href="http://sourceforge.net/apps/trac/elpi/wiki/ALP">Linux 系统高级编程</a></li>
<li><a href="http://billie66.github.io/TLCL/index.html">The Linux Command Line</a> (中英文版)</li>
</ul>
<h3 id="WEB服务器">WEB服务器</h3><ul>
<li><a href="http://tengine.taobao.org/book/index.html">Nginx开发从入门到精通</a> (淘宝团队出品)</li>
</ul>
<h3 id="版本控制">版本控制</h3><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简易指南</a></li>
<li><a href="http://gitref.justjavac.com">Git 参考手册</a></li>
<li><a href="http://git-scm.com/book/zh">Pro Git</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic</a></li>
</ul>
<h3 id="NoSQL">NoSQL</h3><ul>
<li><a href="http://www.yankay.com/wp-content/NoSql_Database_Note.html">NoSQL数据库笔谈</a> (<a href="http://yankaycom-wordpress.stor.sinaapp.com/uploads/2012/12/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%B0%88v2.pdf">PDF</a>)</li>
<li><a href="http://www.redisbook.com/en/latest/">Redis 设计与实现</a></li>
<li><a href="http://www.redisdoc.com/en/latest/">Redis 命令参考</a></li>
<li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md">The Little MongoDB Book</a></li>
<li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md">The Little Redis Book</a></li>
</ul>
<h3 id="MySQL">MySQL</h3><ul>
<li><a href="http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html">MySQL索引背后的数据结构及算法原理</a></li>
</ul>
<h3 id="项目相关">项目相关</h3><ul>
<li><a href="http://article.yeeyan.org/view/2251/94882">持续集成（第二版）</a> (译言网)</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-ap/">让开发自动化系列专栏</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-cq/">追求代码质量</a></li>
<li><a href="https://github.com/fool2fish/selenium-doc">selenium 中文文档</a></li>
</ul>
<h3 id="Web">Web</h3><ul>
<li><a href="http://www.20thingsilearned.com/zh-CN/home">关于浏览器和网络的 20 项须知</a> </li>
<li><a href="http://knowledge.ecomfe.com/">前端知识体系</a></li>
<li><a href="http://jinlong.github.io/blog/2013/08/29/devtoolsecrets/">浏览器开发工具的秘密</a></li>
<li><a href="http://open.chrome.360.cn/extension_dev/overview.html">Chrome扩展开发文档</a></li>
</ul>
<h2 id="语言相关类">语言相关类</h2><h3 id="C/C++">C/C++</h3><ul>
<li><a href="https://github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial">C++ 并发编程指南</a> (<a href="http://weibo.com/1702076100">@傅海平ICT</a>)</li>
<li><a href="http://learn.akae.cn/media/index.html">Linux C编程一站式学习</a> (宋劲杉, 北京亚嵌教育研究中心)</li>
<li><a href="https://github.com/leeyiw/cgdb-manual-in-chinese">CGDB中文手册</a></li>
<li><a href="https://github.com/anjuke/zguide-cn">ZMQ 指南</a></li>
</ul>
<h3 id="CSS">CSS</h3><ul>
<li><a href="http://zh.learnlayout.com/">学习CSS布局</a></li>
<li><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md">通用 CSS 笔记、建议与指导</a></li>
</ul>
<h3 id="Dart">Dart</h3><ul>
<li><a href="http://dart.lidian.info/wiki/Language_Tour">Dart 语言导览</a></li>
</ul>
<h3 id="Java">Java</h3><ul>
<li><p><a href="http://www.ibm.com/developerworks/cn/java/j-rtj/?ca=j-h-p">实时 Java 系列</a></p>
</li>
<li><p>使用 Eclipse 和 Java SE 6 创建独立 Web Services 应用程序</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/webservices/ws-eclipse-javase1/index.html">第 1 部分: Web Services 服务端应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/webservices/tutorials/ws-jse/index.html">第 2 部分: Web 服务客户端应用程序</a></li>
</ul>
</li>
<li>JavaServer Faces 1.2 入门<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jsf1/index.html">第 1 部分: 构建基本应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jsf2/index.html">第 2 部分: JSF 生命周期、转换、检验和阶段监听器</a></li>
</ul>
</li>
<li>用 Eclipse Europa 进行 Web 开发<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa1/index.html">第 1 部分: Eclipse Java EE</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa2/index.html">第 2 部分: PHP 开发工具</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa3/index.html">第 3 部分: Ruby Development Toolkit 和 RadRails</a></li>
</ul>
</li>
<li>使用 JavaServer Faces 构建 Apache Geronimo 应用程序<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf1/index.html">第 1 部分: 使用 Eclipse 和 Apache MyFaces Core 构建基本的应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf2/index.html">第 2 部分: 在 JavaServer Faces 中使用 Tomahawk</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf3/index.html">第 3 部分: 使用 ajax4jsf 添加 Ajax 功能</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf4/index.html">第 4 部分: 使用 Apache Trinidad 组件扩展 JSF</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf5/index.html">第 5 部分: 将 JSF 应用程序与 Spring 集成</a></li>
</ul>
</li>
<li>Apache Geronimo 和 Spring 框架<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe1/index.html">第 1 部分: 开发方法学</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe2/index.html">第 2 部分: 构建第一个应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe3/index.html">第 3 部分: 集成 DAO 与 ORM</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe4/index.html">第 4 部分: 混合使用 Spring AOP 和 Spring Web Flow</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe5/index.html">第 5 部分: Spring MVC</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe6/index.html">第 6 部分: Spring MVC：使用 Web 视图技术</a></li>
</ul>
</li>
<li>终极 mashup —— Web 服务和语义 Web<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup1/index.html">第 1 部分: 使用与组合 Web 服务</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup2/index.html">第 2 部分: 管理 Mashup 数据缓存</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup3/index.html">第 3 部分: 理解 RDF 和 RDFs</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup4/index.html">第 4 部分: 创建本体</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup5/index.html">第 5 部分: 切换 Web 服务</a></li>
</ul>
</li>
</ul>
<h3 id="JavaScript">JavaScript</h3><ul>
<li><a href="http://chajn.org/jsguide/javascriptguide.html">Google JavaScript 代码风格指南</a></li>
<li><a href="https://github.com/adamlu/javascript-style-guide">Airbnb JavaScript 规范</a></li>
<li><a href="https://github.com/justjavac/12-javascript-quirks">javascript 的 12 个怪癖</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a></li>
<li><a href="http://icodeit.org/jsccp/">JavaScript核心概念及实践</a> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</li>
<li><a href="http://justjavac.com/named-function-expressions-demystified.html">命名函数表达式探秘</a>  (注:原文由<a href="http://www.cn-cuckoo.com">为之漫笔</a>翻译，原始地址无法打开，所以此处地址为我博客上的备份)</li>
<li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns">学用 JavaScript 设计模式</a> (开源中国)</li>
<li>Node.js<ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html">Node入门</a></li>
<li><a href="https://github.com/nodejs-tw/nodejs-wiki-book">Nodejs Wiki Book</a> (繁体中文)</li>
<li><a href="http://sofish.github.io/express-guide/">express.js 指南</a></li>
</ul>
</li>
<li>backbone.js<ul>
<li><a href="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html">backbone.js入门教程</a> (PDF)</li>
<li><a href="https://github.com/the5fire/backbonejs-learning-note">Backbone.js入门教程第二版</a></li>
<li><a href="http://feliving.github.io/developing-backbone-applications">Developing Backbone.js Applications(中文版)</a></li>
</ul>
</li>
<li>AngularJS<ul>
<li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md">AngularJS最佳实践和风格指南</a></li>
<li><a href="https://github.com/basestyle/angularjs-cn">AngularJS中译本</a> </li>
</ul>
</li>
<li><a href="http://www.360weboy.com/handbook/zepto/index.html">zepto 简明中文手册</a> </li>
</ul>
<h3 id="PHP">PHP</h3><ul>
<li><a href="http://www.laruence.com/2010/06/21/1608.html">PHP调试技术手册</a>(PDF)</li>
<li><a href="https://github.com/wulijun/php-the-right-way">PHP之道</a></li>
<li><a href="https://github.com/justjavac/PHP-Best-Practices-zh_CN">PHP 最佳实践</a></li>
<li><a href="https://github.com/reeze/tipi">深入理解PHP内核</a></li>
<li><a href="http://www.walu.cc/phpbook/">PHP扩展开发及内核应用</a></li>
<li><a href="http://codeigniter.org.cn/user_guide/index.html">CodeIgniter 用户指南</a></li>
<li><a href="http://www.golaravel.com/docs/">Laravel4 中文文档</a></li>
<li><a href="http://symfony-docs-chs.readthedocs.org/en/latest/">Symfony2中文文档</a> (未译完)</li>
</ul>
<h3 id="iOS">iOS</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md">iOS开发60分钟入门</a></li>
</ul>
<h3 id="Python">Python</h3><ul>
<li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/">简明Python教程</a></li>
<li><a href="http://liam0205.me/Python-tutorial-zh_cn/">Python入门教程</a> (<a href="http://liam0205.me/attachment/Python/The_Python_Tutorial_zh-cn.pdf">PDF</a>)</li>
<li><a href="http://article.yeeyan.org/view/311527/287706">Python的神奇方法指南</a></li>
<li><a href="https://django-document-cn.readthedocs.org/en/latest/">Django 文档中文版</a></li>
<li><a href="https://github.com/brantyoung/zh-django-best-practices">Django 最佳实践</a></li>
<li><a href="http://djangobook.py3k.cn/2.0/">The Django Book 中文版</a></li>
<li><a href="http://webpy.org/tutorial3.zh-cn">web.py 0.3 新手指南</a></li>
<li><a href="http://webpy.org/cookbook/index.zh-cn">Web.py Cookbook 简体中文版</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython/">Dive Into Python 中文版</a></li>
<li><a href="http://bottlepy.org/docs/dev-cn/">Bottle 文档中文版</a></li>
<li><a href="http://docs.torriacg.org/docs/flask/">Flask 文档中文版</a></li>
</ul>
<h3 id="Ruby">Ruby</h3><ul>
<li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md">Ruby 风格指南</a></li>
<li><a href="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md">Rails 风格指南</a></li>
<li><a href="http://railstutorial-china.org/">Ruby on Rails Tutorial 原书第 2 版</a> (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元)</li>
</ul>
<h3 id="Shell">Shell</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md">Shell脚本编程30分钟入门</a></li>
</ul>
<h3 id="Go">Go</h3><ul>
<li><a href="https://github.com/Unknwon/go-fundamental-programming">Go编程基础</a></li>
<li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">Go入门指南</a></li>
<li><a href="http://mikespook.com/learning-go/">学习Go语言</a> (<a href="http://xxiyy.qiniudn.com/%E5%AD%A6%E4%B9%A0%20Go%20%E8%AF%AD%E8%A8%80\(Golang\">PDF</a>.pdf?download))</li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang">Go Web 编程</a> (此书已经出版，希望开发者们去购买，支持作者的创作)</li>
<li><a href="https://github.com/astaxie/Go-in-Action">Go实战开发</a> (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者<a href="https://me.alipay.com/astaxie">捐赠</a>，以鼓励作者的继续创作)</li>
<li><a href="https://github.com/astaxie/NPWG_zh">Network programming with Go 中文翻译版本</a></li>
</ul>
<h3 id="Groovy">Groovy</h3><ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-pg/">实战 Groovy 系列</a></li>
</ul>
<h3 id="LISP">LISP</h3><ul>
<li><a href="http://acl.readthedocs.org/en/latest/">ANSI Common Lisp 中文翻譯版</a></li>
</ul>
<h3 id="Haskell">Haskell</h3><ul>
<li><a href="http://rwh.readthedocs.org/en/latest/">Real World Haskell 中文版</a></li>
</ul>
<h3 id="Scala">Scala</h3><ul>
<li><a href="http://twitter.github.io/scala_school/zh_cn/index.html">Scala课堂</a> (Twitter的Scala中文教程)</li>
</ul>
<h3 id="读书笔记及其它">读书笔记及其它</h3><ul>
<li><a href="https://github.com/fool2fish/dragon-book-exercise-answers">编译原理（紫龙书）中文第2版习题答案</a></li>
<li><a href="http://hawstein.com/posts/make-thiner-programming-pearls.html">把《编程珠玑》读薄</a></li>
<li><a href="https://github.com/XiaolongJason/ReadingNote/blob/master/Effective%20C%2B%2B/Effective%20C%2B%2B.md">Effective C++读书笔记</a></li>
<li><a href="https://github.com/qyuhen/book">Golang 学习笔记、Python 学习笔记、C 学习笔记</a> (PDF)</li>
<li><a href="https://github.com/code4craft/jsoup-learning">Jsoup 学习笔记</a></li>
<li><a href="https://github.com/lzjun567/note">学习笔记: Vim、Python、memcached</a></li>
</ul>]]>
    
    </summary>
    
      <category term="资料分享" scheme="http://ioschen.com/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ruby]]></title>
    <link href="http://ioschen.com/2014/03/30/ruby/"/>
    <id>http://ioschen.com/2014/03/30/ruby/</id>
    <published>2014-03-30T12:13:11.000Z</published>
    <updated>2014-03-30T12:13:51.000Z</updated>
    <content type="html"><![CDATA[<p>ruby</p>
<p>当年应该学兽医</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>ruby</p>
<p>当年应该学兽医</p>]]>
    
    </summary>
    
      <category term="ruby" scheme="http://ioschen.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[变量]]></title>
    <link href="http://ioschen.com/2014/03/26/variable/"/>
    <id>http://ioschen.com/2014/03/26/variable/</id>
    <published>2014-03-25T18:11:27.000Z</published>
    <updated>2014-04-06T11:12:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="引子">引子</h1><p>基本程序构造单元——变量。</p>
<p>Common Lisp支持两种类型的变量:词法（lexical）变量和动态（dynamic）变量。（动态变量有时也叫做特殊变量 special variable）这两中变量对应类型分别对应其他语言的局部变量和全局变量，<strong>不过，只能说是大致相似</strong>一方面某些语言中的局部变量更像是Common Lisp的动态变量。另一方面，某些语言中的局部变量虽然是词法作用域的，但并没有提供由Common Lisp的词法变量所提供的所有功能，尤其是并非所有语言都提供了支持闭包的词法作用域变量。</p>
<p><del>许多含有变量表达式都可以同时使用词法变量和动态变量</del></p>
<h1 id="变量的基础知识">变量的基础知识</h1><p>和其他语言一样，Common Lisp中的变量是一些可以保存值得具名位置，但是在Common Lisp中，变量并非像在Java和c++等语言中那样带有确定的类型，也就是不需要为每一个变量声明其可以保存对象的类型，相反，一个变量可以保存任何类型的值，并且这些值带有可用于运行期类检查的类型信息。因此 Common Lisp是动态类型的——类型错误会被动态的检测到。</p>
<p>比如，给+函数传递个字符串，Common Lisp就会报类型错误。而另一方面，Common Lisp是一种强类型语言，因为所有的类型错误都将被检测到——无法将一个对象作为其不属于的类型的实列来对待。</p>
<p>至少从概念上来说，Common Lisp中所有值都是对象的引用，因此，将一个变量赋予新值就会改变变量所指向的对象，而对之前被引用的对象没有影响。（如果一个变量保存了对一个可变对象的引用，那么久可以用该引用来修改此对象，而这种改动将应用于任何带有相同对象引用的代码。）</p>
<p>而另一种已经用到的引入新变量的方式是定义函数形参。在用DEFUN来定义函数时，形参列表定义了当函数被调用时用来保存实参的变量。列如，下列函数定义了三个变量x y和z，用来保存其实参:</p>
<p><code>(defun foo (x y z) (+ x y z))</code></p>
<p>每当函数被调用时，Lisp将会创建新的绑定来保存由函数调用者所传递的实参。绑定代表了变量在运行期的存在。单个变量就是可以在程序源代码中所指出的那种东西，在程序运行过程中可以有多个不同的绑定，单个变量甚至可以同时带有多重绑定。例如，一个递归函数的形参会在每一次函数调用中被重新绑定。</p>
<p>和所有Common Lisp变量一样，函数形参也可以保存对象引用。因此，可以在函数体内为一个函数形参赋予新值，而这并不会影响到同样函数的另一个调用所创建的绑定。但如果改变了传递给函数的可变对象，则这些改动将会被调用者看到，因为无论调用者还是被调用者都在引用同一个对象。</p>
<p>引入新变量的另一种方式是使用LET特殊操作符。下面就是一个LET形式的结构:</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">let</span></span> <span class="list">(<span class="keyword">variable*</span>)</span>
    body-form*)</span>
</code></pre><p>其中每一个variable都是一耳光变量初始化形式，每一个初始化形式要么是一个含有变量名和初值形式的列表，要么就是一个简单的变量名——作为将变量初始化到NIL得简略写法。列如，下面的LET形式会将三个变量x y z绑定到初始值10 20 和NIL上:</p>
<p><code>(let ((x 10) (y 20) z)
    ...)</code></p>
<p>当这个LET形式被求值时，所有的初始值形式都将首先被求值，然后创建出新的绑定，并在形式体被执行之前这些绑定将初始化到适当的初始值上。在LET形式体中，变量名将引用新创建的绑定。在LET形式体执行结束后，这些变量名将重新引用在执行LET之前它们所引用的内容，如果有的话。</p>
<p>形式体中最后一个表达式的值将作为LET表达式的值返回，和函数形参一眼，由LET所引入的变量将在每次进入LET时被重新绑定。</p>
<p>函数形参和LET变量的作用域（变量名可用来引用该绑定的程序区域）被限定在引入该变量的形式之内，该形式即函数定义或LET，被称为绑定形式。很快将看到，词法变量和动态变量使用两种略有不同的作用域机制，但两者的作用域都被界定在绑定形式之内。</p>
<p>如果嵌套了引入同名变量的绑定形式，那么最内层的变量绑定将<em>覆盖</em>外层的绑定。例如，在调用下面的函数时，将创建一个形参x的绑定来保存函数的实参。第一个LET创建了一个带有初始值2的新绑定，而内层的LET创建了另外一个绑定，其初始值为3。右边的竖线标记出了每一个绑定的作用域。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;;;;第二杭的x为实参，第四行为<span class="number">2</span> 第六行为<span class="number">3</span></span><br><span class="line"><span class="comment">(defun foo (x)</span></span><br><span class="line">	<span class="comment">(format t "Parameter: ~a~%" x)</span></span><br><span class="line">	<span class="comment">(let ((x 2)</span>)</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span></span><br><span class="line">		<span class="comment">(let ((x 3)</span>)</span><br><span class="line">			<span class="comment">(format t "Inner LET: ~a~%" x)</span>))</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span>)</span><br><span class="line">	<span class="comment">(foramt t "Parameter: ~a~%" x)</span>)</span><br></pre></td></tr></table></figure>
<p>每一次对x的引用都将指向最小封闭作用域中的绑定。一旦程序控制离开了一个绑定形式的作用域，其最近的闭合作用域中的绑定就被解除覆盖，并且x将转而指向它。因此，调用foo将得到这样的输出:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (foo <span class="number">1</span>)</span><br><span class="line">Parameter: <span class="number">1</span></span><br><span class="line">Outer LET: <span class="number">2</span></span><br><span class="line">Inner LET: <span class="number">3</span></span><br><span class="line">Outer LET: <span class="number">1</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>后面学习其他可以作为绑定形式使用的程序构造，其特点在于所引入的新变量只能用于该构造。</p>
<p><del>DOTIMES循环和LET*需要后面学习</del></p>
<h1 id="词法变量和闭包">词法变量和闭包</h1><h1 id="动态变量">动态变量</h1><h1 id="常量">常量</h1><h1 id="赋值">赋值</h1><h1 id="广义赋值">广义赋值</h1><h1 id="其他修改位置的方式">其他修改位置的方式</h1><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="引子">引子</h1><p>基本程序构造单元——变量。</p>
<p>Common Lisp支持两种类型的变量:词法（lexical）变量和动态（dynamic）变量。（动态变量有时也叫做特殊变量 special variable）这两中变量对应类型分别对应其他语言的局部变量和全局变量，<strong>不过，只能说是大致相似</strong>一方面某些语言中的局部变量更像是Common Lisp的动态变量。另一方面，某些语言中的局部变量虽然是词法作用域的，但并没有提供由Common Lisp的词法变量所提供的所有功能，尤其是并非所有语言都提供了支持闭包的词法作用域变量。</p>
<p><del>许多含有变量表达式都可以同时使用词法变量和动态变量</del></p>
<h1 id="变量的基础知识">变量的基础知识</h1><p>和其他语言一样，Common Lisp中的变量是一些可以保存值得具名位置，但是在Common Lisp中，变量并非像在Java和c++等语言中那样带有确定的类型，也就是不需要为每一个变量声明其可以保存对象的类型，相反，一个变量可以保存任何类型的值，并且这些值带有可用于运行期类检查的类型信息。因此 Common Lisp是动态类型的——类型错误会被动态的检测到。</p>
<p>比如，给+函数传递个字符串，Common Lisp就会报类型错误。而另一方面，Common Lisp是一种强类型语言，因为所有的类型错误都将被检测到——无法将一个对象作为其不属于的类型的实列来对待。</p>
<p>至少从概念上来说，Common Lisp中所有值都是对象的引用，因此，将一个变量赋予新值就会改变变量所指向的对象，而对之前被引用的对象没有影响。（如果一个变量保存了对一个可变对象的引用，那么久可以用该引用来修改此对象，而这种改动将应用于任何带有相同对象引用的代码。）</p>
<p>而另一种已经用到的引入新变量的方式是定义函数形参。在用DEFUN来定义函数时，形参列表定义了当函数被调用时用来保存实参的变量。列如，下列函数定义了三个变量x y和z，用来保存其实参:</p>
<p><code>(defun foo (x y z) (+ x y z))</code></p>
<p>每当函数被调用时，Lisp将会创建新的绑定来保存由函数调用者所传递的实参。绑定代表了变量在运行期的存在。单个变量就是可以在程序源代码中所指出的那种东西，在程序运行过程中可以有多个不同的绑定，单个变量甚至可以同时带有多重绑定。例如，一个递归函数的形参会在每一次函数调用中被重新绑定。</p>
<p>和所有Common Lisp变量一样，函数形参也可以保存对象引用。因此，可以在函数体内为一个函数形参赋予新值，而这并不会影响到同样函数的另一个调用所创建的绑定。但如果改变了传递给函数的可变对象，则这些改动将会被调用者看到，因为无论调用者还是被调用者都在引用同一个对象。</p>
<p>引入新变量的另一种方式是使用LET特殊操作符。下面就是一个LET形式的结构:</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">let</span></span> <span class="list">(<span class="keyword">variable*</span>)</span>
    body-form*)</span>
</code></pre><p>其中每一个variable都是一耳光变量初始化形式，每一个初始化形式要么是一个含有变量名和初值形式的列表，要么就是一个简单的变量名——作为将变量初始化到NIL得简略写法。列如，下面的LET形式会将三个变量x y z绑定到初始值10 20 和NIL上:</p>
<p><code>(let ((x 10) (y 20) z)
    ...)</code></p>
<p>当这个LET形式被求值时，所有的初始值形式都将首先被求值，然后创建出新的绑定，并在形式体被执行之前这些绑定将初始化到适当的初始值上。在LET形式体中，变量名将引用新创建的绑定。在LET形式体执行结束后，这些变量名将重新引用在执行LET之前它们所引用的内容，如果有的话。</p>
<p>形式体中最后一个表达式的值将作为LET表达式的值返回，和函数形参一眼，由LET所引入的变量将在每次进入LET时被重新绑定。</p>
<p>函数形参和LET变量的作用域（变量名可用来引用该绑定的程序区域）被限定在引入该变量的形式之内，该形式即函数定义或LET，被称为绑定形式。很快将看到，词法变量和动态变量使用两种略有不同的作用域机制，但两者的作用域都被界定在绑定形式之内。</p>
<p>如果嵌套了引入同名变量的绑定形式，那么最内层的变量绑定将<em>覆盖</em>外层的绑定。例如，在调用下面的函数时，将创建一个形参x的绑定来保存函数的实参。第一个LET创建了一个带有初始值2的新绑定，而内层的LET创建了另外一个绑定，其初始值为3。右边的竖线标记出了每一个绑定的作用域。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;;;;第二杭的x为实参，第四行为<span class="number">2</span> 第六行为<span class="number">3</span></span><br><span class="line"><span class="comment">(defun foo (x)</span></span><br><span class="line">	<span class="comment">(format t "Parameter: ~a~%" x)</span></span><br><span class="line">	<span class="comment">(let ((x 2)</span>)</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span></span><br><span class="line">		<span class="comment">(let ((x 3)</span>)</span><br><span class="line">			<span class="comment">(format t "Inner LET: ~a~%" x)</span>))</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span>)</span><br><span class="line">	<span class="comment">(foramt t "Parameter: ~a~%" x)</span>)</span><br></pre></td></tr></table></figure>
<p>每一次对x的引用都将指向最小封闭作用域中的绑定。一旦程序控制离开了一个绑定形式的作用域，其最近的闭合作用域中的绑定就被解除覆盖，并且x将转而指向它。因此，调用foo将得到这样的输出:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (foo <span class="number">1</span>)</span><br><span class="line">Parameter: <span class="number">1</span></span><br><span class="line">Outer LET: <span class="number">2</span></span><br><span class="line">Inner LET: <span class="number">3</span></span><br><span class="line">Outer LET: <span class="number">1</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>后面学习其他可以作为绑定形式使用的程序构造，其特点在于所引入的新变量只能用于该构造。</p>
<p><del>DOTIMES循环和LET*需要后面学习</del></p>
<h1 id="词法变量和闭包">词法变量和闭包</h1><h1 id="动态变量">动态变量</h1><h1 id="常量">常量</h1><h1 id="赋值">赋值</h1><h1 id="广义赋值">广义赋值</h1><h1 id="其他修改位置的方式">其他修改位置的方式</h1>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数]]></title>
    <link href="http://ioschen.com/2014/03/25/function/"/>
    <id>http://ioschen.com/2014/03/25/function/</id>
    <published>2014-03-25T12:57:35.000Z</published>
    <updated>2014-03-27T08:02:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="书接上文">书接上文</h1><p>有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 </p>
<p>（宏是用来生成代码，不是用来完成实际操作的）</p>
<h1 id="定义新函数">定义新函数</h1><h2 id="定义方式">定义方式</h2><p>函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">name</span> （<span class="type">parameter</span>*）</span><br><span class="line">	<span class="string">"Optional documentating string."</span></span><br><span class="line">	body-<span class="keyword">form</span>）</span><br></pre></td></tr></table></figure>
<h2 id="命名方式">命名方式</h2><p>任何符号都可以用作函数名。通常函数名包含字典字符和连字符。但是在特定的命名约定里，其它字符也允许使用。列如，将值得一种类型转换成另一种函数有时会在名字中使用-&gt;</p>
<p>一个将字符串转换成微件（widget）的函数可能叫做string-&gt;widget  最重要的一个命名约定是用连字符而不是下划线或者内部大小写</p>
<p>因此是a-b而不是a_b或者aB</p>
<h2 id="定义参数">定义参数</h2><p>一个函数的形参列表定义了一些变量，将用来保存函数在调用时所传递的实参。如果函数是不带有实参，则该列表就是空得，写成（）。不同种类的形参分别负责处理必要的，可选的，多重的以及关键字实参。</p>
<h2 id="参数说明">参数说明</h2><p>如果一个字符串紧跟在形参列表之后，那么它应该就是一个用来描述函数用途的文档字符串。当定义函数时，该文档字符串将被关联到函数名上，并且以后可以通过DOCUMENTATION函数来获取</p>
<h2 id="最后总结">最后总结</h2><p>一个DEFUN的主体可由任意数量的lisp表达式所构成，他们将在函数被调用时依次求值，而最后一个表达式的值将被作为整个函数的值返回，另外RETURN-FROM特殊操作符可用于从函数的任何位置立即返回。</p>
<p>一开始学习的时候写的hello-world，形式如下</p>
<p><code>（defun hello-world () (format t &quot;hello, world&quot;)）</code></p>
<p>分析如下</p>
<ol>
<li>名字是hello-world</li>
<li>形式列表为空，因此不接受任何参数</li>
<li>没有文档字符串</li>
<li>函数体由一个表达式所构成（format t “hello，world”）</li>
</ol>
<p>另一个列子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> verbose-sum <span class="list">(<span class="keyword">x</span> y)</span></span><br><span class="line">      <span class="string">"Sum any two numbers after printing a message."</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"Summing ~d and ~d.~%"</span> x y)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数称为verbose-sum 接受两个实参分别为形参x和y一一对应并且带有一个文档字符串，以及一个由两个表达式所组成的主体。有“+”调用所返回的值将成为verbose-sum的返回值。</p>
<h1 id="函数形参列表">函数形参列表</h1><p>函数名和文档字符串差不多了，现在了解形参列表</p>
<p>形参列表的基本用途是为了声明一些变量用来接收传递给函数的实参，当形参列表是一个由变量名所组成的简单列表时，如同在verbose-sum里那样，这些形参叫必要形参。当函数调用时候，必须为每个必要形参都提供一个实参。每一个形参被绑定到对应的实参上。</p>
<p>但是，形参列表也给了更灵活的方法将函数调用实参映射到函数形参。除了必要形参以外，一个函数还可以有可选形参，或者也可以用单一形参绑定到含有任意多个额外参数的列表上。最后，参数还可以通过关键字而不是位置来映射到形参上，这样Commom lisp的形参列表对于集中常见的编码问题提供了一种便利的解决方案。</p>
<h1 id="可选形参">可选形参</h1><h2 id="定义">定义</h2><p>为了定义一个可选形参的函数，在必要形参的名字后放置符号&amp;optional后接可选形参的名字</p>
<h2 id="列子">列子</h2><p><code>（defun foo （a b &amp;optional c d）(list a b c d)）</code></p>
<p>当函数被调用时，实参被首先绑定到必要形参上，在所有必要形参都被赋值以后，如果还有任何实参剩余，它们的值被赋给可选形参。如果实参在所有可选形参被赋值前用完了，那么其余的可选形参将自动绑定到NIL上。这样，列子定义的函数会给出下面的结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 NIL NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3 4） -&gt; （1 2 3 4）</li>
</ul>
<p>lisp任然可以确保适当的数量的实参被传递给函数——在本列中是2-4个。而如果函数用太少或太多的参数来调用的话，会报错。</p>
<p>当然，我们经常想要一个不同于NIL的默认值，这时可以通过将新参名替换成一个含有名字跟一个表达式的列表来制定该默认值。只有在调用者没有传递足够的实参来为可选形参提供值得时候，这个表达式才会被求值，通常情况只是简单的提供一个值作为表达式：</p>
<p><code>(defun foo (a &amp;optional（b 10)) (list  a b))</code></p>
<p>上述函数要求将一个实参绑定到形参a上，当存在第二个实参时，第二个形参b将使用其值，否则使用10</p>
<ul>
<li>（foo 1 2） -&gt; （1 2）</li>
<li>（foo 1）-&gt; （1 10）</li>
</ul>
<p>不过，有时可能需要更灵活选择默认值，比如可能想要基于其他形参来计算默认值，默认值表达式可以引用早先出现在形参列表中的形参。如果要编写一个返回矩形的某种表示的函数，并且想要使它可以特别的产生正方形，那么可以使用一个像这样的形参列表。</p>
<p><code>(defun make-rectangle (width &amp;optional (height width)) ...)</code><br>除非明确知道否则这将导致height形参带有和width形参相同的值。</p>
<p>有时，有必要去了解一个可选形参的值究竟是被调用者明确指定还是使用了默认值。除了代码检查是否默认值（假如调用者碰巧显式传递了默认值，那么这样做终归是无效的）以外，还可以通过在形参标示符的默认值表达式之后添加另一个变量名来做到这点。该变量将在调用者实际为该形参提供了一个实参是被绑定到真值，否则为NIL 通常约定，这种变量的名字与对应的真实形参相同，但是带有一个 -supplied-p后缀<br>列如:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">a</span> b <span class="keyword">&amp;optional</span> <span class="list">(<span class="keyword">c</span> <span class="number">3</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">lisp</span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这将给出类似下面结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 T）</li>
<li>（foo 1 2 4） -&gt; （1 2 4 T）</li>
</ul>
<h1 id="剩余形参">剩余形参</h1><p>可选形参仅适用于一些较为分散并且不能确定调用者是否会提供值得形参。但某些函数需要接收可变数量的实参，比如前面已经出现过的内置函数。FORMAT有两个必要实参，即流合控制串。单在这两个之后，它还需要一组可变数量的实参，这取决于控制串需要插入多少个值。</p>
<p>+函数也接受可变数量的实参——没有特别的理由限制它只能在两个数之间相加，它可以对任意数量的值做加法运算（它甚至可以没有实参，此时返回0——加法的底数）。下面这些都是这两个函数的合法调用:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, ~a"</span> name)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"x: ~d y: ~d"</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>很明显，也可以通过简单给它一些可选形参来写出接受可变数量实参的函数，但这样将会非常麻烦，光是写形参列表就已经够麻烦了，何况还要在函数体中处理所有这些形参。为了做好这件事，还不得不使用一个合法函数调用所能够传递的那么多的可选形参。这一具体数量与具体实现相关，但可以保证至少有50个。在当前所有实现中，它的最大值范围从4096到536870911</p>
<p>相反，Lisp允许在符合&amp;rest之后<em>包括</em>一揽子形参。如果函数带有&amp;rest形参，那么任何满足了必要可选形参之后其余所有实参就将被收集到一个列表里成为该&amp;rest形参的值。这样，FORMAT和+的形参列表可能看起来会是这样:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> format <span class="list">(<span class="keyword">stream</span> string <span class="keyword">&amp;rest</span> values)</span> ...)</span></span><br><span class="line"><span class="list">(<span class="keyword">defun</span> + <span class="list">(<span class="keyword">&amp;rest</span> nmbers)</span> ...)</span></span><br></pre></td></tr></table></figure>
<h1 id="关键字形参">关键字形参</h1><p>如果我想给第四个形参提供值，其余不给，怎么办呢，关键字形参就起作用了。（这个没有描述清楚）</p>
<p>如果用可选形参的话。如果给第四个可选形参传递一个显式值，就会导致前面三个可选形参对于调用者来说变成了必要形参。</p>
<p>定义：在任何必要的&amp;optional和&amp;rest形参之后，可以加上符号&amp;key以及任意数量的关键字形参标示符，后者的格式类似于可选形参标示符。下面就是一个只有关键字形参的函数:</p>
<p><code>(defun foo (&amp;key a b c) (list a b c))</code></p>
<p>当调用这个函数时，每一个关键字形参将绑定到紧跟在同名键字后面的那个值上，如前面所说，关键字以冒号开始的名字，并且他们被自动定义为自求值常量。</p>
<p>如果一个给定的关键字没有出现在实参列表中，那么对应的形参将被赋予其默认值，如同可选形参那样。因为关键字实参带有标签，所以他们在必要实参之后可按任意顺序进行传递。例如foo可以用下列形式调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">foo</span>)</span>  -&gt; <span class="list">(<span class="keyword">NIL</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:c</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> NIL <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:b</span> <span class="number">2</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span> <span class="keyword">:b</span> <span class="number">2</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>如同可选形参那样，关键字形参也可以提供一个默认值形式以及一个supplied-p变量名。</p>
<p>在关键字形参和可选形参中，这个默认值形式都可以引用那些早先出现在形参列表中的形参。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="keyword">a</span> <span class="number">0</span>)</span> <span class="list">(<span class="keyword">b</span> <span class="number">0</span> b-supplied-p)</span> <span class="list">(<span class="keyword">c</span> <span class="list">(<span class="keyword">+</span> a b)</span>)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">list</span> a b c b-supplied-p)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">2</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt; <span class="list">(<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br></pre></td></tr></table></figure>
<p>同样，出于某种原因想让调用者用来指定形参的关键字不同于实际形参名，那么可以将形参名替换成一个列表，令其含有调用函数时使用的关键字以及用作形参的名字，比如说下面这个foo的定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="list">(<span class="attribute">:apple</span> a)</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:box</span> b)</span> <span class="number">0</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:charlie</span> c)</span> <span class="number">0</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">list</span></span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以让调用者这样调用它:</p>
<p><code>(foo :apple 10 :box 20 :charlie 30)  -&gt; (10 20 30 T)</code></p>
<p>这种风格在想要完全将函数的公共API与其内部细节相隔离时特别有用，通常是因为想要在内部使用段变量名，而不是API中的描述性关键字。不过该特性不常被用到。</p>
<h1 id="混合不同的形参类型">混合不同的形参类型</h1><p>四个混合使用，多种混合使用时候：必须以这样的顺序声明:首先是<em>必要形参</em> 其次是<em>可选形参</em> 再次是<em>剩余形参</em> 最后才是<em>关键字形参</em>。但在使用多种类型形参的函数中，一般情况是将必要和另外一种类型形参组合使用，或者可能是组合&amp;optional形参和&amp;rest形参。其它两种组合方式，无论是&amp;optional形参还是&amp;rest形参，当与&amp;key形参组合使用时，都可能导致某种奇怪的行为。</p>
<p>将&amp;optional形参和&amp;key形参组合使用时将产生非常奇怪的结果，因此也许应该避免将他们一起使用，问题出现在如果调用者没有为所有可选形参提供值时，那么没有得到值得可选形参将吃掉原本用于关键字形参的关键字和值。列如，下面这个函数很不明智地混合了&amp;optional形参和&amp;key形参:</p>
<p><code>（defun foo （x &amp;optional y &amp;key z）（list x y z））</code></p>
<p>如果像这样调用的话，就没问题:</p>
<p><code>(foo 1) -&gt; (1 nil nil)</code></p>
<p>但是这样的话将报错:</p>
<p><code>(foo 1 :z 3) -&gt; ERROR</code></p>
<p>这是因为关键字:z被作为一个值填入到可选的y形参中了，只留下了参数3被处理。在这里，Lisp期待一个成对的关键字/值，或者什么也没有，否则就会报错，也许更坏的是，如果该函数带有两个&amp;optional形参，上面最后一个调用将导致值:z和3分别被绑定到两个&amp;optional形参上，而&amp;key形参z将得到默认值NIL 而不声明缺失了东西。</p>
<p>一般而言，如果正在编写一个同时使用&amp;optional形参和&amp;key形参的函数，可能就应该将它变成全部使用&amp;key形参的形式——他们更灵活，并且总会可以在不破坏该函数的已有调用的情况下添加新的关键字形参。也可以移除关键字形参，只要没人在使用他们，一般而言，使用关键字形参就uhui使代码相对易于维护和拓展——如果需要为函数添加一些需要用到新参数的新行为，就可以直接添加关键字形参，而无需修改甚至重新编译任何调用该函数的已有代码。</p>
<p>虽然可以安全的组合使用&amp;rest形参和&amp;key形参    ，但其行为初看起来可能会有一点奇怪。正常的来讲，无论是&amp;rest还是&amp;key出现在形参列表中，都将导致所有出现在必要形参和&amp;optional形参之后的那些值被特别处理——要么作为&amp;rest和&amp;key同时出现在形参列表中，那么两件事都会发生——所有剩余的值，包括关键字本身，都将被收集到一个列表里，然后绑定到&amp;rest形参上，而适当的值，也会同时被绑定到&amp;key形参上，因此给定下列函数:</p>
<p><code>(defun foo (&amp;rest rest &amp;key a b c) (list rest a b c))</code></p>
<p>将会得到如下结果:</p>
<p><code>(foo :a 1 :b 2 :c 3) -&gt; ((:A 1 :B 2 :C 3) 1 2 3)</code></p>
<h1 id="函数返回值">函数返回值</h1><p>目前所有函数都使用了默认的返回值行为，既<em>最后一个表达式的值</em>被作为整个函数的<strong>返回值</strong>。这是从函数中返回值得最常见方式。</p>
<p>有些时候，尤其是想要从嵌套的控制结构中脱身时，如果有办法从函数中间返回，那就是非常便利的。在这种情况下，你可以使用RETURN-FROM特殊操作符，它能够立即以任何职从函数中间返回。<del>RETURN-FROM事实上不只用于函数，还可以用来从一个由BLOCK特殊操作符所定义的代码块中返回。</del>不过DEFUN会自动将其整个函数体包装在一个与其函数同名的代码块中，因此，对一个带有当前函数名和想要返回的值的RETURN-FROM是一个特殊操作符，其第一个“参数”是它想要返回的代码块名。该名字不被求值，因此无需引用。</p>
<p>下面这个函数使用了嵌套循环来发现第一个数对——每个都小于10，并且其成绩大于函数的参数，它使用RETURN-FROM在发现后立即返回该数对;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">n</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">i</span> <span class="number">10</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">j</span> <span class="number">10</span>)</span></span><br><span class="line">			<span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> i j)</span> n)</span></span><br><span class="line">				<span class="list">(<span class="keyword">return-from</span> foo <span class="list">(<span class="keyword"><span class="built_in">list</span></span> i j)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>必须承认的是，不得不指定正在返回的函数名多少会有些不便——比如改变了函数的名字，就需要同时改变RETURN-FROM中所使用的名字，但是在事实上，显式的RETURN-FROM调用在Lisp中出现的频率远小于return语句在源自C的语言里出现的频率，因为所有的Lisp表达式，包括诸如循环和条件语句这样的控制结构，都会求值得到一个值，因此在实践中这不是什么问题。</p>
<h1 id="作为数据的函数————高阶函数">作为数据的函数————高阶函数</h1><p>使用函数主要方式—-<strong>通过名字来调用</strong> 但有时将函数作为数据看待也是很有用的。列如，可以将一个函数作为参数传递给另一个函数，从而能写出一个通用的排序函数，允许调用者提供一个比较任意两元素的函数，这样通用的底层算法就可以跟许多不同的比较函数配合使用了。</p>
<p>类似的，回调函数（callback）和钩子（hook）也需要能够保存代码引用便于以后运行。由于函数已经是一种对代码比特进行抽象的标准方式，因此允许把函数视为数据也是合理的。</p>
<p>在Lisp中，函数只是另一种类型的对象，在用DEFUN定义一个函数时，实际上做了两件事：创建一个新的函数对象以及赋予其一个名字，前面说过，也可以使用LAMBDA表达式来创建一个函数而无需为其指定一个名字。一个函数对象的实际表示，无论是有名的还是匿名的，都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。只需要知道如何保持它们以及需要时如何调用它们。</p>
<p>特殊操作符FUNCTION提供了用来获取一个函数对象的方法，它接受单一实参并返回与该参数同名的函数。这个名字是不被引用的。因此如果一个函数foo的定义如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? (defun foo (x) (* x x))</span><br><span class="line">FOO</span><br><span class="line">就可以得到如下的函数对象</span><br><span class="line">? (<span class="function"><span class="keyword">function</span></span> foo)</span><br><span class="line">#&lt;Compiled-<span class="function"><span class="keyword">function</span></span> FOO #x302000F99E4F&gt;</span><br></pre></td></tr></table></figure>
<p>事实上前面已经用过FUNCTION了，但是它以伪装的形式出现的，前面用到的#’语法就是FUNCTION的语法糖，正如’是QUOTE的语法糖一样。因此也可以像这样得到foo的函数对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="preprocessor">#'foo</span></span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;Compiled-function FOO #x302000ECB11F&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一旦得到了函数对象，就只剩下一件事可做了——调用它。Common Lisp提供了两个函数用来调用函数: FUNCALL和APPLY 它们的区别仅在于如何获取传递给函数的实参。</p>
<p>FUNCALL用于在编写代码时确切知道传递给函数多少实参时，FUNCALL的第一个实参是被调用的函数对象，其余的实参被传递到该函数中。因此，下面两个表达式是等价的:</p>
<p><code>（foo 1 2 3）= （funcall #&#39;foo 1 2 3）</code></p>
<p>不过，用FUNCALL来调用一个写代码时名字已知的函数毫无意义。事实上，前面的两个表达式很可能被编译成相同的机器指令。</p>
<p>下面这个函数演示了FUNCALL的另一个更有建设性的用法。它接受一个函数对象作为实参，并使用实参函数在min和max之间以step为步长的返回值绘制一个简单的ASCII式柱状图:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L-USER&gt; <span class="list">(<span class="keyword">defun</span> plot <span class="list">(<span class="keyword">fn</span> min max step)</span></span><br><span class="line">	   <span class="list">(<span class="keyword">loop</span> for i from min to max by step do</span><br><span class="line">		<span class="list">(<span class="keyword">loop</span> repeat <span class="list">(<span class="keyword">funcall</span> fn i)</span> do <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"*"</span>)</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~%"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>FUNCALL表达式在每个i值上计算函数的值，内层LOOP循环使用计算得到的值来决定向标准输出打印多少星号。</p>
<p>请注意，不需要使用FUNCTION或#‘来得到fn的函数值，因为它是作为函数对象的变量的值，所以你需要它解释成一个变量。可以用任何接受单一数值实参的函数来调用plot，列如内置的函数EXP，它返回以e为底以其实参为指数的值。</p>
<pre><code>(plot <span class="comment">#'exp 0 4 1/2)</span>
<span class="keyword">*</span>
<span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
NIL
</code></pre><p>然而，当实参列表只在运行期已知时，FUNCALL的表现不佳，列如，为了再次调用plot函数，假设你已有一个列表，其包括一个函数对象，一个最小值和一个最大值以及一个步长。换句话说，这个列表包含了你想要作为实参传给plot的所有值，假设这个列表保存在变量plot-data中，可以像这样用列表中的值来调用plot:</p>
<p><code>(plot (first plot-data) (second plot-data) (third plot-data) (fourth plot-data))</code></p>
<p>这样固然可以，但仅仅为了将实参传给plot而显式地将其解开，看起来相当不爽。</p>
<p>这样就需要APPLY的原因，和FUNCTION一样，APPLY的第一个参数是一个函数对象，但在这个函数对象之后，它期待一个列表而非单独的实参。它将函数应用在列表中的值上，这就使你可以写出下面的替代版本:</p>
<p><code>(apply #&#39;plot plot-data)</code></p>
<p>更方便的是，APPLY还接受“孤立”（loose）的实参，只要最后一个参数是个列表，因此，加入plot-data只含有最小，最大和步长值，那么你仍然可以像这样来使用APPLY在该范围上绘制EXP函数:</p>
<p><code>(apply #&#39;plot exp plot-data)</code></p>
<p>APPLY并不关心所用的函数是否接受&amp;optional &amp;rest 或&amp;key实参——由任何孤立实参和最后的列表所组合而成的实参列表必定是一个合法的实参列表，其对于该函数来说带有足够的实参用于所有必要形参和适当的关键字形参。</p>
<h1 id="匿名函数">匿名函数</h1><p>一开始编写或只是使用那些可以接受其它函数作为实参的函数，你就必然发现，有时不得不去定义和命名一个仅使用一次的函数，尤其是你可能从不用名字来调用它时，这会让人相当恼火。</p>
<p>觉得没必要用DEFUN来定义一个新函数时，可以使用一个LAMBDA表达式创建匿名的函数。前面讨论过，一个LAMBDA表达式形式如下:</p>
<p><code>(lambda (parameters) body)</code></p>
<p>可以将LAMBDA表达式视为一种特殊类型的函数名，其名字本身直接描述函数的用途，这就解释了为什么可以使用一个带有#’的LAMBDA表达式来代替一个函数名。</p>
<p><code>(funcall #&#39;(lambda (x y) (+ x y)) 2 3)  -&gt;5</code></p>
<p>甚至可以在一个函数调用表达式中将LAMBDA表达式用作函数名，由此一来，我们可以在需要时以更简洁方式来书写前面的FUNCALL表达式如下:</p>
<p><code>((lambda (x y) (+ x y)) 2 3) -&gt; 5</code></p>
<p>但是几乎没人这样做，它唯一的用途是来强调将LAMBDA表达式用在任何一个正常函数名可以出现的场合是合法的。</p>
<p>在需要传递一个作为实参的函数给另一个函数，并且需要传递的这个函数简单到可以内联表达时，匿名函数特别有用，列如，假设想要绘制函数2x 你可以定义下面的函数:</p>
<p><code>defun double (x) (* 2 x))</code></p>
<p>并随后将其传给plot</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'double 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">Nil</span><br></pre></td></tr></table></figure>
<p>但如果写成这样就会更简单和清晰:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'(lambda (x) (* 2 x)) 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>LAMBDA表达式的另一项重要用途是制作闭包（closure），即捕捉了其创建时环境信息的函数。前面也使用了一点闭包，但是要想深入了解闭包的工作原理和用途，更多地还是要从变量而非函数的角度去考察，下面在研究吧。</p>
<p><del>也可以不带前缀#’来使用一个LAMBDA表达式作为FUNCALL的参数</del></p>
<p><del>关于这个。。。</del></p>
<hr>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="书接上文">书接上文</h1><p>有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 </p>
<p>（宏是用来生成代码，不是用来完成实际操作的）</p>
<h1 id="定义新函数">定义新函数</h1><h2 id="定义方式">定义方式</h2><p>函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">name</span> （<span class="type">parameter</span>*）</span><br><span class="line">	<span class="string">"Optional documentating string."</span></span><br><span class="line">	body-<span class="keyword">form</span>）</span><br></pre></td></tr></table></figure>
<h2 id="命名方式">命名方式</h2><p>任何符号都可以用作函数名。通常函数名包含字典字符和连字符。但是在特定的命名约定里，其它字符也允许使用。列如，将值得一种类型转换成另一种函数有时会在名字中使用-&gt;</p>
<p>一个将字符串转换成微件（widget）的函数可能叫做string-&gt;widget  最重要的一个命名约定是用连字符而不是下划线或者内部大小写</p>
<p>因此是a-b而不是a_b或者aB</p>
<h2 id="定义参数">定义参数</h2><p>一个函数的形参列表定义了一些变量，将用来保存函数在调用时所传递的实参。如果函数是不带有实参，则该列表就是空得，写成（）。不同种类的形参分别负责处理必要的，可选的，多重的以及关键字实参。</p>
<h2 id="参数说明">参数说明</h2><p>如果一个字符串紧跟在形参列表之后，那么它应该就是一个用来描述函数用途的文档字符串。当定义函数时，该文档字符串将被关联到函数名上，并且以后可以通过DOCUMENTATION函数来获取</p>
<h2 id="最后总结">最后总结</h2><p>一个DEFUN的主体可由任意数量的lisp表达式所构成，他们将在函数被调用时依次求值，而最后一个表达式的值将被作为整个函数的值返回，另外RETURN-FROM特殊操作符可用于从函数的任何位置立即返回。</p>
<p>一开始学习的时候写的hello-world，形式如下</p>
<p><code>（defun hello-world () (format t &quot;hello, world&quot;)）</code></p>
<p>分析如下</p>
<ol>
<li>名字是hello-world</li>
<li>形式列表为空，因此不接受任何参数</li>
<li>没有文档字符串</li>
<li>函数体由一个表达式所构成（format t “hello，world”）</li>
</ol>
<p>另一个列子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> verbose-sum <span class="list">(<span class="keyword">x</span> y)</span></span><br><span class="line">      <span class="string">"Sum any two numbers after printing a message."</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"Summing ~d and ~d.~%"</span> x y)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数称为verbose-sum 接受两个实参分别为形参x和y一一对应并且带有一个文档字符串，以及一个由两个表达式所组成的主体。有“+”调用所返回的值将成为verbose-sum的返回值。</p>
<h1 id="函数形参列表">函数形参列表</h1><p>函数名和文档字符串差不多了，现在了解形参列表</p>
<p>形参列表的基本用途是为了声明一些变量用来接收传递给函数的实参，当形参列表是一个由变量名所组成的简单列表时，如同在verbose-sum里那样，这些形参叫必要形参。当函数调用时候，必须为每个必要形参都提供一个实参。每一个形参被绑定到对应的实参上。</p>
<p>但是，形参列表也给了更灵活的方法将函数调用实参映射到函数形参。除了必要形参以外，一个函数还可以有可选形参，或者也可以用单一形参绑定到含有任意多个额外参数的列表上。最后，参数还可以通过关键字而不是位置来映射到形参上，这样Commom lisp的形参列表对于集中常见的编码问题提供了一种便利的解决方案。</p>
<h1 id="可选形参">可选形参</h1><h2 id="定义">定义</h2><p>为了定义一个可选形参的函数，在必要形参的名字后放置符号&amp;optional后接可选形参的名字</p>
<h2 id="列子">列子</h2><p><code>（defun foo （a b &amp;optional c d）(list a b c d)）</code></p>
<p>当函数被调用时，实参被首先绑定到必要形参上，在所有必要形参都被赋值以后，如果还有任何实参剩余，它们的值被赋给可选形参。如果实参在所有可选形参被赋值前用完了，那么其余的可选形参将自动绑定到NIL上。这样，列子定义的函数会给出下面的结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 NIL NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3 4） -&gt; （1 2 3 4）</li>
</ul>
<p>lisp任然可以确保适当的数量的实参被传递给函数——在本列中是2-4个。而如果函数用太少或太多的参数来调用的话，会报错。</p>
<p>当然，我们经常想要一个不同于NIL的默认值，这时可以通过将新参名替换成一个含有名字跟一个表达式的列表来制定该默认值。只有在调用者没有传递足够的实参来为可选形参提供值得时候，这个表达式才会被求值，通常情况只是简单的提供一个值作为表达式：</p>
<p><code>(defun foo (a &amp;optional（b 10)) (list  a b))</code></p>
<p>上述函数要求将一个实参绑定到形参a上，当存在第二个实参时，第二个形参b将使用其值，否则使用10</p>
<ul>
<li>（foo 1 2） -&gt; （1 2）</li>
<li>（foo 1）-&gt; （1 10）</li>
</ul>
<p>不过，有时可能需要更灵活选择默认值，比如可能想要基于其他形参来计算默认值，默认值表达式可以引用早先出现在形参列表中的形参。如果要编写一个返回矩形的某种表示的函数，并且想要使它可以特别的产生正方形，那么可以使用一个像这样的形参列表。</p>
<p><code>(defun make-rectangle (width &amp;optional (height width)) ...)</code><br>除非明确知道否则这将导致height形参带有和width形参相同的值。</p>
<p>有时，有必要去了解一个可选形参的值究竟是被调用者明确指定还是使用了默认值。除了代码检查是否默认值（假如调用者碰巧显式传递了默认值，那么这样做终归是无效的）以外，还可以通过在形参标示符的默认值表达式之后添加另一个变量名来做到这点。该变量将在调用者实际为该形参提供了一个实参是被绑定到真值，否则为NIL 通常约定，这种变量的名字与对应的真实形参相同，但是带有一个 -supplied-p后缀<br>列如:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">a</span> b <span class="keyword">&amp;optional</span> <span class="list">(<span class="keyword">c</span> <span class="number">3</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">lisp</span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这将给出类似下面结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 T）</li>
<li>（foo 1 2 4） -&gt; （1 2 4 T）</li>
</ul>
<h1 id="剩余形参">剩余形参</h1><p>可选形参仅适用于一些较为分散并且不能确定调用者是否会提供值得形参。但某些函数需要接收可变数量的实参，比如前面已经出现过的内置函数。FORMAT有两个必要实参，即流合控制串。单在这两个之后，它还需要一组可变数量的实参，这取决于控制串需要插入多少个值。</p>
<p>+函数也接受可变数量的实参——没有特别的理由限制它只能在两个数之间相加，它可以对任意数量的值做加法运算（它甚至可以没有实参，此时返回0——加法的底数）。下面这些都是这两个函数的合法调用:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, ~a"</span> name)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"x: ~d y: ~d"</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>很明显，也可以通过简单给它一些可选形参来写出接受可变数量实参的函数，但这样将会非常麻烦，光是写形参列表就已经够麻烦了，何况还要在函数体中处理所有这些形参。为了做好这件事，还不得不使用一个合法函数调用所能够传递的那么多的可选形参。这一具体数量与具体实现相关，但可以保证至少有50个。在当前所有实现中，它的最大值范围从4096到536870911</p>
<p>相反，Lisp允许在符合&amp;rest之后<em>包括</em>一揽子形参。如果函数带有&amp;rest形参，那么任何满足了必要可选形参之后其余所有实参就将被收集到一个列表里成为该&amp;rest形参的值。这样，FORMAT和+的形参列表可能看起来会是这样:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> format <span class="list">(<span class="keyword">stream</span> string <span class="keyword">&amp;rest</span> values)</span> ...)</span></span><br><span class="line"><span class="list">(<span class="keyword">defun</span> + <span class="list">(<span class="keyword">&amp;rest</span> nmbers)</span> ...)</span></span><br></pre></td></tr></table></figure>
<h1 id="关键字形参">关键字形参</h1><p>如果我想给第四个形参提供值，其余不给，怎么办呢，关键字形参就起作用了。（这个没有描述清楚）</p>
<p>如果用可选形参的话。如果给第四个可选形参传递一个显式值，就会导致前面三个可选形参对于调用者来说变成了必要形参。</p>
<p>定义：在任何必要的&amp;optional和&amp;rest形参之后，可以加上符号&amp;key以及任意数量的关键字形参标示符，后者的格式类似于可选形参标示符。下面就是一个只有关键字形参的函数:</p>
<p><code>(defun foo (&amp;key a b c) (list a b c))</code></p>
<p>当调用这个函数时，每一个关键字形参将绑定到紧跟在同名键字后面的那个值上，如前面所说，关键字以冒号开始的名字，并且他们被自动定义为自求值常量。</p>
<p>如果一个给定的关键字没有出现在实参列表中，那么对应的形参将被赋予其默认值，如同可选形参那样。因为关键字实参带有标签，所以他们在必要实参之后可按任意顺序进行传递。例如foo可以用下列形式调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">foo</span>)</span>  -&gt; <span class="list">(<span class="keyword">NIL</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:c</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> NIL <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:b</span> <span class="number">2</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span> <span class="keyword">:b</span> <span class="number">2</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>如同可选形参那样，关键字形参也可以提供一个默认值形式以及一个supplied-p变量名。</p>
<p>在关键字形参和可选形参中，这个默认值形式都可以引用那些早先出现在形参列表中的形参。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="keyword">a</span> <span class="number">0</span>)</span> <span class="list">(<span class="keyword">b</span> <span class="number">0</span> b-supplied-p)</span> <span class="list">(<span class="keyword">c</span> <span class="list">(<span class="keyword">+</span> a b)</span>)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">list</span> a b c b-supplied-p)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">2</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt; <span class="list">(<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br></pre></td></tr></table></figure>
<p>同样，出于某种原因想让调用者用来指定形参的关键字不同于实际形参名，那么可以将形参名替换成一个列表，令其含有调用函数时使用的关键字以及用作形参的名字，比如说下面这个foo的定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="list">(<span class="attribute">:apple</span> a)</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:box</span> b)</span> <span class="number">0</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:charlie</span> c)</span> <span class="number">0</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">list</span></span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以让调用者这样调用它:</p>
<p><code>(foo :apple 10 :box 20 :charlie 30)  -&gt; (10 20 30 T)</code></p>
<p>这种风格在想要完全将函数的公共API与其内部细节相隔离时特别有用，通常是因为想要在内部使用段变量名，而不是API中的描述性关键字。不过该特性不常被用到。</p>
<h1 id="混合不同的形参类型">混合不同的形参类型</h1><p>四个混合使用，多种混合使用时候：必须以这样的顺序声明:首先是<em>必要形参</em> 其次是<em>可选形参</em> 再次是<em>剩余形参</em> 最后才是<em>关键字形参</em>。但在使用多种类型形参的函数中，一般情况是将必要和另外一种类型形参组合使用，或者可能是组合&amp;optional形参和&amp;rest形参。其它两种组合方式，无论是&amp;optional形参还是&amp;rest形参，当与&amp;key形参组合使用时，都可能导致某种奇怪的行为。</p>
<p>将&amp;optional形参和&amp;key形参组合使用时将产生非常奇怪的结果，因此也许应该避免将他们一起使用，问题出现在如果调用者没有为所有可选形参提供值时，那么没有得到值得可选形参将吃掉原本用于关键字形参的关键字和值。列如，下面这个函数很不明智地混合了&amp;optional形参和&amp;key形参:</p>
<p><code>（defun foo （x &amp;optional y &amp;key z）（list x y z））</code></p>
<p>如果像这样调用的话，就没问题:</p>
<p><code>(foo 1) -&gt; (1 nil nil)</code></p>
<p>但是这样的话将报错:</p>
<p><code>(foo 1 :z 3) -&gt; ERROR</code></p>
<p>这是因为关键字:z被作为一个值填入到可选的y形参中了，只留下了参数3被处理。在这里，Lisp期待一个成对的关键字/值，或者什么也没有，否则就会报错，也许更坏的是，如果该函数带有两个&amp;optional形参，上面最后一个调用将导致值:z和3分别被绑定到两个&amp;optional形参上，而&amp;key形参z将得到默认值NIL 而不声明缺失了东西。</p>
<p>一般而言，如果正在编写一个同时使用&amp;optional形参和&amp;key形参的函数，可能就应该将它变成全部使用&amp;key形参的形式——他们更灵活，并且总会可以在不破坏该函数的已有调用的情况下添加新的关键字形参。也可以移除关键字形参，只要没人在使用他们，一般而言，使用关键字形参就uhui使代码相对易于维护和拓展——如果需要为函数添加一些需要用到新参数的新行为，就可以直接添加关键字形参，而无需修改甚至重新编译任何调用该函数的已有代码。</p>
<p>虽然可以安全的组合使用&amp;rest形参和&amp;key形参    ，但其行为初看起来可能会有一点奇怪。正常的来讲，无论是&amp;rest还是&amp;key出现在形参列表中，都将导致所有出现在必要形参和&amp;optional形参之后的那些值被特别处理——要么作为&amp;rest和&amp;key同时出现在形参列表中，那么两件事都会发生——所有剩余的值，包括关键字本身，都将被收集到一个列表里，然后绑定到&amp;rest形参上，而适当的值，也会同时被绑定到&amp;key形参上，因此给定下列函数:</p>
<p><code>(defun foo (&amp;rest rest &amp;key a b c) (list rest a b c))</code></p>
<p>将会得到如下结果:</p>
<p><code>(foo :a 1 :b 2 :c 3) -&gt; ((:A 1 :B 2 :C 3) 1 2 3)</code></p>
<h1 id="函数返回值">函数返回值</h1><p>目前所有函数都使用了默认的返回值行为，既<em>最后一个表达式的值</em>被作为整个函数的<strong>返回值</strong>。这是从函数中返回值得最常见方式。</p>
<p>有些时候，尤其是想要从嵌套的控制结构中脱身时，如果有办法从函数中间返回，那就是非常便利的。在这种情况下，你可以使用RETURN-FROM特殊操作符，它能够立即以任何职从函数中间返回。<del>RETURN-FROM事实上不只用于函数，还可以用来从一个由BLOCK特殊操作符所定义的代码块中返回。</del>不过DEFUN会自动将其整个函数体包装在一个与其函数同名的代码块中，因此，对一个带有当前函数名和想要返回的值的RETURN-FROM是一个特殊操作符，其第一个“参数”是它想要返回的代码块名。该名字不被求值，因此无需引用。</p>
<p>下面这个函数使用了嵌套循环来发现第一个数对——每个都小于10，并且其成绩大于函数的参数，它使用RETURN-FROM在发现后立即返回该数对;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">n</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">i</span> <span class="number">10</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">j</span> <span class="number">10</span>)</span></span><br><span class="line">			<span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> i j)</span> n)</span></span><br><span class="line">				<span class="list">(<span class="keyword">return-from</span> foo <span class="list">(<span class="keyword"><span class="built_in">list</span></span> i j)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>必须承认的是，不得不指定正在返回的函数名多少会有些不便——比如改变了函数的名字，就需要同时改变RETURN-FROM中所使用的名字，但是在事实上，显式的RETURN-FROM调用在Lisp中出现的频率远小于return语句在源自C的语言里出现的频率，因为所有的Lisp表达式，包括诸如循环和条件语句这样的控制结构，都会求值得到一个值，因此在实践中这不是什么问题。</p>
<h1 id="作为数据的函数————高阶函数">作为数据的函数————高阶函数</h1><p>使用函数主要方式—-<strong>通过名字来调用</strong> 但有时将函数作为数据看待也是很有用的。列如，可以将一个函数作为参数传递给另一个函数，从而能写出一个通用的排序函数，允许调用者提供一个比较任意两元素的函数，这样通用的底层算法就可以跟许多不同的比较函数配合使用了。</p>
<p>类似的，回调函数（callback）和钩子（hook）也需要能够保存代码引用便于以后运行。由于函数已经是一种对代码比特进行抽象的标准方式，因此允许把函数视为数据也是合理的。</p>
<p>在Lisp中，函数只是另一种类型的对象，在用DEFUN定义一个函数时，实际上做了两件事：创建一个新的函数对象以及赋予其一个名字，前面说过，也可以使用LAMBDA表达式来创建一个函数而无需为其指定一个名字。一个函数对象的实际表示，无论是有名的还是匿名的，都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。只需要知道如何保持它们以及需要时如何调用它们。</p>
<p>特殊操作符FUNCTION提供了用来获取一个函数对象的方法，它接受单一实参并返回与该参数同名的函数。这个名字是不被引用的。因此如果一个函数foo的定义如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? (defun foo (x) (* x x))</span><br><span class="line">FOO</span><br><span class="line">就可以得到如下的函数对象</span><br><span class="line">? (<span class="function"><span class="keyword">function</span></span> foo)</span><br><span class="line">#&lt;Compiled-<span class="function"><span class="keyword">function</span></span> FOO #x302000F99E4F&gt;</span><br></pre></td></tr></table></figure>
<p>事实上前面已经用过FUNCTION了，但是它以伪装的形式出现的，前面用到的#’语法就是FUNCTION的语法糖，正如’是QUOTE的语法糖一样。因此也可以像这样得到foo的函数对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="preprocessor">#'foo</span></span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;Compiled-function FOO #x302000ECB11F&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一旦得到了函数对象，就只剩下一件事可做了——调用它。Common Lisp提供了两个函数用来调用函数: FUNCALL和APPLY 它们的区别仅在于如何获取传递给函数的实参。</p>
<p>FUNCALL用于在编写代码时确切知道传递给函数多少实参时，FUNCALL的第一个实参是被调用的函数对象，其余的实参被传递到该函数中。因此，下面两个表达式是等价的:</p>
<p><code>（foo 1 2 3）= （funcall #&#39;foo 1 2 3）</code></p>
<p>不过，用FUNCALL来调用一个写代码时名字已知的函数毫无意义。事实上，前面的两个表达式很可能被编译成相同的机器指令。</p>
<p>下面这个函数演示了FUNCALL的另一个更有建设性的用法。它接受一个函数对象作为实参，并使用实参函数在min和max之间以step为步长的返回值绘制一个简单的ASCII式柱状图:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L-USER&gt; <span class="list">(<span class="keyword">defun</span> plot <span class="list">(<span class="keyword">fn</span> min max step)</span></span><br><span class="line">	   <span class="list">(<span class="keyword">loop</span> for i from min to max by step do</span><br><span class="line">		<span class="list">(<span class="keyword">loop</span> repeat <span class="list">(<span class="keyword">funcall</span> fn i)</span> do <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"*"</span>)</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~%"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>FUNCALL表达式在每个i值上计算函数的值，内层LOOP循环使用计算得到的值来决定向标准输出打印多少星号。</p>
<p>请注意，不需要使用FUNCTION或#‘来得到fn的函数值，因为它是作为函数对象的变量的值，所以你需要它解释成一个变量。可以用任何接受单一数值实参的函数来调用plot，列如内置的函数EXP，它返回以e为底以其实参为指数的值。</p>
<pre><code>(plot <span class="comment">#'exp 0 4 1/2)</span>
<span class="keyword">*</span>
<span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
NIL
</code></pre><p>然而，当实参列表只在运行期已知时，FUNCALL的表现不佳，列如，为了再次调用plot函数，假设你已有一个列表，其包括一个函数对象，一个最小值和一个最大值以及一个步长。换句话说，这个列表包含了你想要作为实参传给plot的所有值，假设这个列表保存在变量plot-data中，可以像这样用列表中的值来调用plot:</p>
<p><code>(plot (first plot-data) (second plot-data) (third plot-data) (fourth plot-data))</code></p>
<p>这样固然可以，但仅仅为了将实参传给plot而显式地将其解开，看起来相当不爽。</p>
<p>这样就需要APPLY的原因，和FUNCTION一样，APPLY的第一个参数是一个函数对象，但在这个函数对象之后，它期待一个列表而非单独的实参。它将函数应用在列表中的值上，这就使你可以写出下面的替代版本:</p>
<p><code>(apply #&#39;plot plot-data)</code></p>
<p>更方便的是，APPLY还接受“孤立”（loose）的实参，只要最后一个参数是个列表，因此，加入plot-data只含有最小，最大和步长值，那么你仍然可以像这样来使用APPLY在该范围上绘制EXP函数:</p>
<p><code>(apply #&#39;plot exp plot-data)</code></p>
<p>APPLY并不关心所用的函数是否接受&amp;optional &amp;rest 或&amp;key实参——由任何孤立实参和最后的列表所组合而成的实参列表必定是一个合法的实参列表，其对于该函数来说带有足够的实参用于所有必要形参和适当的关键字形参。</p>
<h1 id="匿名函数">匿名函数</h1><p>一开始编写或只是使用那些可以接受其它函数作为实参的函数，你就必然发现，有时不得不去定义和命名一个仅使用一次的函数，尤其是你可能从不用名字来调用它时，这会让人相当恼火。</p>
<p>觉得没必要用DEFUN来定义一个新函数时，可以使用一个LAMBDA表达式创建匿名的函数。前面讨论过，一个LAMBDA表达式形式如下:</p>
<p><code>(lambda (parameters) body)</code></p>
<p>可以将LAMBDA表达式视为一种特殊类型的函数名，其名字本身直接描述函数的用途，这就解释了为什么可以使用一个带有#’的LAMBDA表达式来代替一个函数名。</p>
<p><code>(funcall #&#39;(lambda (x y) (+ x y)) 2 3)  -&gt;5</code></p>
<p>甚至可以在一个函数调用表达式中将LAMBDA表达式用作函数名，由此一来，我们可以在需要时以更简洁方式来书写前面的FUNCALL表达式如下:</p>
<p><code>((lambda (x y) (+ x y)) 2 3) -&gt; 5</code></p>
<p>但是几乎没人这样做，它唯一的用途是来强调将LAMBDA表达式用在任何一个正常函数名可以出现的场合是合法的。</p>
<p>在需要传递一个作为实参的函数给另一个函数，并且需要传递的这个函数简单到可以内联表达时，匿名函数特别有用，列如，假设想要绘制函数2x 你可以定义下面的函数:</p>
<p><code>defun double (x) (* 2 x))</code></p>
<p>并随后将其传给plot</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'double 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">Nil</span><br></pre></td></tr></table></figure>
<p>但如果写成这样就会更简单和清晰:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'(lambda (x) (* 2 x)) 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>LAMBDA表达式的另一项重要用途是制作闭包（closure），即捕捉了其创建时环境信息的函数。前面也使用了一点闭包，但是要想深入了解闭包的工作原理和用途，更多地还是要从变量而非函数的角度去考察，下面在研究吧。</p>
<p><del>也可以不带前缀#’来使用一个LAMBDA表达式作为FUNCALL的参数</del></p>
<p><del>关于这个。。。</del></p>
<hr>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[语法]]></title>
    <link href="http://ioschen.com/2014/03/23/yufa/"/>
    <id>http://ioschen.com/2014/03/23/yufa/</id>
    <published>2014-03-23T06:28:09.000Z</published>
    <updated>2014-03-28T03:13:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="括号里都有神马">括号里都有神马</h1><h1 id="S-表达式">S-表达式</h1><p>s-表达式基本元素是列表和原子。列表由括号包围，并可包含任何数量的由空格所分隔的元素。</p>
<p>空列表（）也可写成NIL既是原子也是列表</p>
<h2 id="数字的表示方法">数字的表示方法</h2><ol>
<li>123  整数123</li>
<li>3/7  比值七分之三</li>
<li>1.0  默认精度的浮点数1</li>
<li>1.0e0  同一个浮点数的另一个写法</li>
<li>1.0d0  双精度的浮点数1</li>
<li>1.0e-4  等价于万分之一的浮点数</li>
<li>+42  整数42</li>
<li>-42  附属42</li>
<li>-1/4  比值负四分之一</li>
<li>-2/8  负四分之一另一种写法</li>
<li>246/2  123另一种写法</li>
<li>lisp复数后面第十章开始解说</li>
</ol>
<p>-2/8和246/2等价于-1/4和123  1.0 等同于1.0e0   1.0、1.0d0 和1是不一样的，因为精度不同，代表的是不同类型的对象</p>
<h2 id="字符串">字符串</h2><ol>
<li>字符川由双引号包括，在字符串中，一个反斜杠会转义接下来的任意字符。</li>
<li>两个在字符串中必须被转移的字符串是<code>双引号和反斜杠本身</code></li>
</ol>
<table>
<thead>
<tr>
<th>字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foo”</td>
<td>含有foo的字符串</td>
</tr>
<tr>
<td>“fo\o”</td>
<td>含有foo的字符串</td>
</tr>
<tr>
<td>“fo\\o”</td>
<td>含有fo\o的字符串</td>
</tr>
<tr>
<td>“fo\”o”</td>
<td>含有fo”和o的字符串</td>
</tr>
</tbody>
</table>
<pre><code>lisp中所使用的名字，诸如FORMAT  hello-world和<span class="keyword">*</span>db<span class="keyword">*</span>均由称为符号的对象所表示。空白字符不可以出现在列表里，只有一个句点的名字也不可以。这是个字符不能出现在名字里:开括号，闭括号，双引号和单引号，反引号，逗号，冒号，分号，反斜杠以及竖线。（加上反斜杠转义或者将有需要转义的字符串的字符名字用竖线包起来，还是可以使用的）
</code></pre><p>读取器将把foo Foo和FOO都读成FOO，但\f\o\o 和 |foo|都被读成foo这是和符号FOO不同的另一个对象，这就是为什么REPL中定义一个函数时，它的名字会被打印成大写形式的原因。</p>
<p>现在标准的编码风格是将代码全部写成小写形式，然后让读取器将名字转换为大写。</p>
<p>为了保证同一个名字总是被读取成相同的符号，读取器保留这个符号，在已读取名字将其全部转化成大写形式后，读取器在一个称为包得表里查询带有相同名字的已有符号，如果没有找到，就创建一个新符号并添加到表里，否则返回已在表中的那个符号。<code>无论在任何地方，同意的名字出现在任何s-表达式里，都会用同一个对象去表示它</code></p>
<blockquote>
<p>全局变量名字开始和结尾处有*</p>
<blockquote>
<p>常量名开始结尾处有+</p>
<blockquote>
<p>有些程序员将特别低层的函数名前面加%或者%%</p>
<blockquote>
<p>语言标准所定义的名字只能使用字母字符表（A-Z）外加* + - / 1 2 &lt; = &gt; 以及&amp;这些符号</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="目前要求">目前要求</h2><p>只用列表，数字，字符串和符号就可以描述很大一部分的lisp程序呢其他的后面说<font color="red">目前关键是要理解怎样用数字，字符串和由符号借助括号所组成的列表式构建s-表达式，从而表示任意的树状对象。</font>下面是一些简单的列子。</p>
<ol>
<li>x                  符号x</li>
<li>（）             空列表</li>
<li>（1 2 3）         三个数字组成的列表</li>
<li>（”foo” “bar”） 两个字符串组成的列表</li>
<li>（x y z）         三个符号所组成的列表</li>
<li>（x 1 “foo”）    一个符号，一个数字和一个字符串所组成的列表</li>
<li>（+ （* 2 3）4）一个符号，一个列表，一个数字组成的列表</li>
</ol>
<p>下面这种四元素列表就稍显复杂了，它含有两个符号，空列表以及另一个列表-其本身又含有两个符号和一个字符串:<br>    <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> hello-world <span class="list">()</span> <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="作为Lisp形式的S-表达式">作为Lisp形式的S-表达式</h1><ol>
<li><p>读取器把大量文本转化为s-表达式后，这些s-表达式随后可以作为lisp形式被求值。（有些没必要求值）<br>任何一个原子（非列表或空列表）都是一个合法的Lisp形式</p>
</li>
<li><p>作为最简单的lisp形式，原子可以被分成两个类别：符号和所有其他内容。符号在作为lisp形式被求值时会被视为一个变量名，并且会被求值为该变量的当前值。</p>
</li>
<li><p>所有其他的原子，包括数字和字符串都是自求值对象。<br>比如输入10和helloworld</p>
</li>
<li><p>把符号变成自求值对象也是可能的，它所命名的变量可以被赋值成符号本身的值。两个以这种方式定义的常量是T和NIL，既所谓的真值和假值</p>
</li>
<li>另一类自求值符号是<code>关键字</code>符号-以名字冒号开始的符号。当读取器保留这样一个名字时，它会自动定义一个以此命名的常值变量并以该符号作为其值。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们开始考虑列表的求值方式时候，事情变得更加有趣了，所有合法的列表形式均以一个符号开始，但是有三种类型的列表形式，他们会以三种相当不同的方式进行求值，为了确定一个给定的列表式哪种形式，求值器必须检测列表开始处的那个符号是一个函数，宏还是特殊操作符的名字。如果该符号尚未定义，比如说当你正在编译一段含有对尚未定义函数的引用代码时，它会被假设成一个函数的名字。我将把这三种类型的形式称为函数调用形式，宏形式和特殊形式。</span><br></pre></td></tr></table></figure>
<p>common lisp中一个符号可以同时为操作符（函数，宏或特殊操作符）和变量命名</p>
<h1 id="函数调用">函数调用</h1><p>函数调用形式的求值规则很简单，对以lisp形式存在的列表其余元素进行求值并将结果传递到命名函数中，这一规则明显有着附加的句法限制在函数调用形式上:除第一个以外，所有的列表元素他们自身必须是一个形态良好的lisp形式，换句话说，函数调用形式的基本语法应如下所示，其中每个参数本身也是lisp形式:<br>（function-name argument*）</p>
<ol>
<li>(+ 1 2)首先求值1，再求值2然后将得到的值传给+函数再返回3</li>
<li>（<em> （+ 1 2）（- 3 4））先求参数的值为3和-1最后传递到</em>函数里，从而得到-3</li>
</ol>
<h1 id="特殊操作符">特殊操作符</h1><p>并非所有操作都可以定义成函数，由于一个函数的所有参数在函数调用之前都将被求值，因此无法写出一个累世IF操作符那样的函数</p>
<p>当列表的第一个元素是一个由特殊操作符所命名的符号时，表达式的其余部分将按照该操作符的规则进行求值。</p>
<h2 id="IF操作符">IF操作符</h2><font color="red">IF的规则相当简单:求值第一个表达式。如果得到非NIL，那么求值下一个表达式并返回它的值，否则，返回第三个表达式的求值，或者如果第三个表达式被省略的话，返回NIL。换句话说，一个IF表达式的基本形式是像下面这样:</font>

<p>(if test-form then-form [else-form])</p>
<p>其中test-form将总是被求值 ，然后要么是then-form要么是else-form</p>
<h2 id="QUOTE操作符">QUOTE操作符</h2><p>一个更简单的操作符是QUOTE，它接受一个单一表达式作为其“参数”并简单的返回他，不经求值，列如，下面的表达式求值得到列表（+ 1 2），而不是值3:</p>
<p><code>(quote (+ 1 2))</code></p>
<p>QUOTE用得非常普遍，以至于读取器内置一个它的特别语法形式，还可以写成 ‘(+ 1 2) <del>该语法是读取器所理解的s-表达式语法的小扩展</del></p>
<p>一般来说，特殊操作符所实现的语言特性需要求职器操作出某些特殊处理。列如，有些的操作符修改了其他形式的求值环境，其中之一是LET，下面会详细解说，它用来创建新的变量绑定。下面的形式求值得到10，因为在第二个x的求值环境中，它是由LET赋值为10的变量名:</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">let</span></span> <span class="list">(<span class="list">(<span class="keyword">x</span> <span class="number">10</span>)</span>)</span> x)</span>
</code></pre><h1 id="宏">宏</h1><p>由于特殊操作符数量在标准语言中是固定的，然而宏却能提供给语言用户另一种语法扩展方式。宏是以一个s-表达式为其参数的函数，并返回一个lisp形式，然后对其求值并用该值取代宏形式。宏形式的求值过程包括两个阶段：<font color="red">首先，宏形式的袁术不经常求值既被传递到宏函数里，其次，由宏函数所返回的形式（展开式）按照正常的求值规则进行求值。</font></p>
<p>。。。</p>
<h1 id="真_假和等价">真 假和等价</h1><h2 id="真假">真假</h2><ol>
<li>符号NIL式唯一的假值，其他所有都是真值</li>
<li>符号T式标准的真值，可用于需要返回一个非    NIL值却又没有其他值可用的情况。</li>
<li>关于NIL唯一一个麻烦的一点是，它是唯一一个即是原子又是列表的对象：除了用来表示假以外，它还用来表示空列表。</li>
<li>nil （） ‘nil和’（）这四个求值结果一样的</li>
<li>t和‘t求值结果也完全相同：符号T</li>
</ol>
<h2 id="等价">等价</h2><ul>
<li>=用来比较数字</li>
<li>CHAR=用来比较字符</li>
</ul>
<p>等价时返回真，否则假</p>
<ol>
<li>EQ  只有两个对象相同时才是eq等价的（最好不是数字字符的比较时候用）</li>
<li>EQL  （eql 1 1）真    （eql 1 1.0）假</li>
<li>EQUAL 将在递归上具有相同结构和内容的表现视为等价，也认为含有相同字符的字符串是等价的，它对于位向量和路径名也定义了比eql更加宽松的等价性  </li>
<li>EQUALP  和equal相似，但是比较字符串忽略大小写区别，字母相同就是等价，只要数字表示相同数学意义上的值，他们在equalp下面就是等价的，因此（equalp 1 1.0）是真的。由equalp等价的元素组成的列表也是equalp等价的。同样的，带有equalp元素的数组也是equalp等价的，和equal一样，还有一些其他暂时没讲到的数据类型，equalp可认为两个对象是等价的，但是eql和equal则不会，对于所有其他数据类型，equalp会退到eql水平上。</li>
</ol>
<h1 id="格式化Lisp代码">格式化Lisp代码</h1><h2 id="代码缩进">代码缩进</h2><p>格式化代码关键在于正确缩进它，这一缩进应当反映出代码结构，这样就不用数括号了。一般而言，每一个新的嵌套层次都需要多缩进一点儿，并且如果折行是必须的，位于同一个嵌套层次的项应当按行对齐。<br>这样，一个需要跨越多行的函数调用可能就会被写成这样：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="keyword">some</span>-function arg-<span class="keyword">with</span>-a-long-<span class="property">name</span></span><br><span class="line">				 another-arg-<span class="keyword">with</span>-an-even-longer-					 <span class="property">name</span>）</span><br></pre></td></tr></table></figure>
<p>那些实现控制结构的宏和特殊形式在缩进上稍有不同：“主体”元素相对于整个形式的开括号缩进两个空格。就像这样</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">print</span>-<span class="keyword">list</span> （<span class="keyword">list</span>）</span><br><span class="line">	(dolist (i <span class="keyword">list</span>)</span><br><span class="line">		(<span class="keyword">format</span> t <span class="string">"item: ~a~%"</span> i))）</span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2><p><code>;;;;</code>   四个分号用于文件头注释</p>
<p><code>;;;</code>    带有三个分号的注释将通常作为段落注释应用到接下来的一大段代码上</p>
<p><code>;;</code>     两个分号说明该注释应用于接下来的代码上。注意，该注释与其所应用的代码具有相同的缩进</p>
<pre><code> ;;;这就是一大堆代码
（defun foo （x）
    （dotime （<span class="built_in">i</span> x）
         ;;这就是两个注释
        （some-<span class="function"><span class="keyword">function</span>-<span class="title">call</span>）</span>
        （another <span class="built_in">i</span>）
        （add-another）
        （baz）））
</code></pre><p>!–more–&gt;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="括号里都有神马">括号里都有神马</h1><h1 id="S-表达式">S-表达式</h1><p>s-表达式基本元素是列表和原子。列表由括号包围，并可包含任何数量的由空格所分隔的元素。</p>
<p>空列表（）也可写成NIL既是原子也是列表</p>
<h2 id=]]>
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iphoneSize]]></title>
    <link href="http://ioschen.com/2014/03/21/iphonesize/"/>
    <id>http://ioschen.com/2014/03/21/iphonesize/</id>
    <published>2014-03-21T00:53:44.000Z</published>
    <updated>2014-03-21T01:58:32.000Z</updated>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸未除2</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>head</td>
<td>(0,0,width,44)</td>
<td>(0,0,width,44)</td>
<td><font color="red">(0,20,width,44)</font></td>
<td><font color="red">(0,20,width,44)</font></td>
</tr>
<tr>
<td>center</td>
<td>(0,44,width,height-88)</td>
<td>(0,44,width,height-88)</td>
<td><font color="red">(0,64,width,height-108)</font></td>
<td><font color="red">(0,64,width,height-108)</font></td>
</tr>
<tr>
<td>foot</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>center大小</td>
<td>320*372</td>
<td>320*460</td>
<td>320*372</td>
<td>320*460</td>
</tr>
</tbody>
</table>
<h5 id="iphone4和iphone5只有高度相差88"><font color="red">iphone4和iphone5只有高度相差88</font></h5><p><del>表格中的height是self.view.frame.size.height，里面的width也是一样</del></p>
<p><del>ios6和ios7的self.view.frame.size是不一样的</del></p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸未除2</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>head</td>
<td>(0,0,width,44)</td>
<td>(0,0,width,44)</td>
<td><font color=red>(0,20,width,44)</font></td>
<td><font color=red>(0,20,width,44)</font></td>
</tr>
<tr>
<td>center</td>
<td>(0,44,width,height-88)</td>
<td>(0,44,width,height-88)</td>
<td><font color=red>(0,64,width,height-108)</font></td>
<td><font color=red>(0,64,width,height-108)</font></td>
</tr>
<tr>
<td>foot</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>center大小</td>
<td>320*372</td>
<td>320*460</td>
<td>320*372</td>
<td>320*460</td>
</tr>
</tbody>
</table>
<h5 id="iphone4和iphone5只有高度相差88"><font color=red>iphone4和iphone5只有高度相差88</font></h5><p><del>表格中的height是self.view.frame.size.height，里面的width也是一样</del></p>
<p><del>ios6和ios7的self.view.frame.size是不一样的</del></p>]]>
    
    </summary>
    
      <category term="ios" scheme="http://ioschen.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单的数据库]]></title>
    <link href="http://ioschen.com/2014/03/19/singlesql/"/>
    <id>http://ioschen.com/2014/03/19/singlesql/</id>
    <published>2014-03-19T12:31:31.000Z</published>
    <updated>2014-03-23T06:31:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CD和记录">CD和记录</h1><p>为了记录一些CD中MP3的信息，需要做一个数据库。<br>数据库每条记录包含CD标题和艺术家信息，一个多少用户喜欢它的评级，以及一个表示是否已经转换过的标记。<br>所以，需要一种方式表示一条数据库的记录（也就是一仗CD）最简单的就是使用列表</p>
<h2 id="列表">列表</h2><p><code>（list 1 2 3）</code>会得到（1 2 3）</p>
<h2 id="四元素列表">四元素列表</h2><h2 id="属性表">属性表</h2><p>以冒号开始的名字为关键字符号</p>
<p><code>（list :a 1 :b 2 :c 3）</code></p>
<p>(:A 1 :B 2 :C 3)</p>
<h2 id="GETF函数">GETF函数</h2><p>getf接受一个plist和一个符号，并返回plist中跟在那个符号后面的值</p>
<p>（getf （list :a 1 :b 2 :c 3）:a）得到1</p>
<p>（getf （list :a 1 :b 2 :c 3）:c）得到3</p>
<h2 id="make-cd函数">make-cd函数</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> make-cd <span class="list">(<span class="keyword">title</span> artist rating ripped)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">list</span></span> <span class="attribute">:title</span> title <span class="attribute">:artist</span> artist <span class="attribute">:rating</span> rating <span class="attribute">:ripped</span> ripped)</span>)</span></span><br></pre></td></tr></table></figure>
<p>defun告诉我们正在定义一个函数</p>
<p>函数名是make-cd，函数名都是-在中间命名，这个和其他语言区别啊</p>
<p>跟在名字后面的是形参列表，这个函数有四个形参 title artist rating 和ripped</p>
<p>形参列表后面的都是函数体，上面的函数体只有一个形式，即对list的调用，档make-cd被调用时，传递给调用的参数被绑定到形参列表中的变量上。</p>
<p>列如，为了建立一个关于Kathy Mattea的名为Roses的CD的记录，可以这样调用make-cd</p>
<p><code>(make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t)</code></p>
<p>回车返回(:TITLE “Roses” :ARTIST “Kathy Mattea” :RATING 7 :RIPPED T)</p>
<h1 id="录入CD">录入CD</h1><h2 id="DEFVAR宏定义全局变量*db*">DEFVAR宏定义全局变量*db*</h2><p>只有单一记录还不能算是一个数据库，需要一些更大的结构来保存记录，出于简化目的，可以使用一个全局变量*db*</p>
<p>命名中的*号是Lisp的全局变量命名约定</p>
<p><code>(defvar *db* nil)</code></p>
<p>可以用PUSH宏为*db*添加新的项，稍微抽象一些，因此可以定义一个函数add-record来给数据库增加一条记录</p>
<p>其实就是插入数据</p>
<p><code>(defun add-record (cd) (push cd *db*))</code></p>
<h2 id="插入数据">插入数据</h2><p>现在可以讲add-record和make-cd一起使用，为数据库添加新CD记录了</p>
<p><code>(add-record (make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t))</code></p>
<p><code>(add-record (make-cd &quot;Qoses&quot; &quot;Kathy Mattea&quot; 6 t))</code>    </p>
<p>每次都PUSH返回正在修改的变量的最新值</p>
<h1 id="查看数据库的内容">查看数据库的内容</h1><h2 id="无论如何，输入*db*都可以看到*db*的当前值">无论如何，输入*db*都可以看到*db*的当前值</h2><p>但是这个查看方式不爽，不是人类看的，可以用一个dump-db函数讲数据库变成有格式的，符合人类看的</p>
<p>比如</p>
<p>TITLE: home<br>ARTIST: da<br>RATING:     5<br>ROPPED: T</p>
<p>TITLE: homeqe<br>ARTIST: da<br>RATING:     6<br>ROPPED: T</p>
<p><del>全局变量一个缺点是每时每刻只能有一个数据库</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">	<span class="list">(<span class="keyword">dolist</span> <span class="list">(<span class="keyword">cd</span> <span class="variable">*db*</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~a: ~10t~a~%~&#125;~%"</span> cd)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的工作原理就是在使用DOLIST宏在*db*的所有元素上循环，依次绑定每个元素到变量cd上，然后使用format函数打印出每个cd的值</p>
<p>format至少接收两个参数，第一个是用来发送输出的流，t是标准输出流的简称。</p>
<p>第二个蚕食是一个格式字符串，内容既包括字面文本，也包括那些告诉format如何插入其余参数等信息的指令，。格式指令以~开始，类似于printf指令以%开始，</p>
<p>~a指令是美化指令，它的意图是消耗一个参数，然后将其输出成人类可读的形式，这将使得关键字被渲染成不带前导冒号的形式，而字符串也不再有引号呢，</p>
<p>比如<code>(format t &quot;~a&quot; &quot;jing yu&quot;)</code></p>
<p>输出 </p>
<pre><code>jing yu

 <span class="keyword">NIL</span>
</code></pre><p>~t指令用于制表，~10t告诉format产生足够的空格，以确保在处理下一个~a之前将光标移动10列。~t指令不适用任何参数</p>
<p><code>（format &quot;~a:~10t~a&quot; :artist &quot;Dixie Chicks&quot;）</code></p>
<p>输出</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dixie Chicks</span><br><span class="line"></span><br><span class="line"><span class="keyword">NIL</span></span><br></pre></td></tr></table></figure>
<p>现在事情复杂了，档format看到~{的时候，下一个被使用的实参必须是一个列表。format在列表上循环操作，处理位于~{和~}之间的指令，同时在每次需要时，从列表上使用尽可能多的元素，在dump-db里，format循环将每次循环时从列表上消耗一个关键字和一个值。</p>
<p>~%指令并不消耗任何实参，而只是告诉format来产生一个执行，然后再~{循环结束以后，最后一个~%告诉format再输出一个额外的换行，以便在每个cd数据间产生一个空行</p>
<p><del>从技术上来讲，也可以使用format在整个数据库本身循环，从而将dump-db函数变成只有一行</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~&#123;~a: ~10t~a~%~&#125;~%~&#125;"</span> <span class="variable">*db*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="最牛逼的FORMAT指令~R指令">最牛逼的FORMAT指令~R指令</h2><p>用英语说一个大数字</p>
<p><code>(format nil &quot;~r&quot; 3489142793724123341)</code></p>
<h1 id="改进用户交互">改进用户交互</h1><p>这个界面不友好对于普通用户 ，变成提示用户输入的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-read <span class="list">(<span class="keyword">prompt</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">format</span> <span class="variable">*query-io*</span> <span class="string">"~a: "</span> prompt)</span></span><br><span class="line">	<span class="list">(<span class="keyword">force-output</span> <span class="variable">*query-io*</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">read-line</span> <span class="variable">*query-io*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">    <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"ripped [y/n]"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword"><span class="built_in">or</span></span> <span class="list">(<span class="keyword">parse-integer</span> <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span> <span class="attribute">:junk-allowed</span> t)</span> <span class="number">0</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Ripped [y/n]: "</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> add-cds <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">loop</span></span> <span class="list">(<span class="keyword">add-record</span> <span class="list">(<span class="keyword">prompt-for-cd</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Another? [y/n]: "</span>)</span>)</span> <span class="list">(<span class="keyword">return</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="保存和加载数据库">保存和加载数据库</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> save-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">out</span> filename</span><br><span class="line">                           <span class="keyword">:direction</span> <span class="keyword">:output</span></span><br><span class="line">                           <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">print</span> <span class="variable">*db*</span> out)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果退出了下次数据没了就吊了，所以必须保存</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> load-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">in</span> filename)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">setf</span> *db* <span class="list">(<span class="keyword"><span class="built_in">read</span></span> in)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>读取数据</p>
<p>load-db之前要确保保存了，如果save-db后又加入了一些数据，这个时候load-db那么这些刚加入的数据就会丢失</p>
<h1 id="查询数据库">查询数据库</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">#'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"Dixie Chicks"</span>)</span>)</span> *db*)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> select-by-artist <span class="list">(<span class="keyword">artist</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">       #'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"sfada"</span>)</span>)</span> *db*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="更新已有记录">更新已有记录</h1><h1 id="消除重复，获益良多">消除重复，获益良多</h1><h1 id="总结">总结</h1><p>我已经不想写了，也没有完全看下去，最后的部分主要是加入数据库的几个功能-增加删除修改查询</p>
<p>昨天晚上今天晚上两个晚上没有看出什么，唯一的感觉就是这个好像真的很牛逼，几个方法就U可以实现增删查改</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CD和记录">CD和记录</h1><p>为了记录一些CD中MP3的信息，需要做一个数据库。<br>数据库每条记录包含CD标题和艺术家信息，一个多少用户喜欢它的评级，以及一个表示是否已经转换过的标记。<br>所以，需要一种方式表示一条数据库的记录（也就是一仗CD）最简单的就是使用列表</p>
<h2 id="列表">列表</h2><p><code>（list 1 2 3）</code>会得到（1 2 3）</p>
<h2 id="四元素列表">四元素列表</h2><h2 id="属性表">属性表</h2><p>以冒号开始的名字为关键字符号</p>
<p><code>（list :a 1 :b 2 :c 3）</code></p>
<p>(:A 1 :B 2 :C 3)</p>
<h2 id="GETF函数">GETF函数</h2><p>getf接受一个plist和一个符号，并返回plist中跟在那个符号后面的值</p>
<p>（getf （list :a 1 :b 2 :c 3）:a）得到1</p>
<p>（getf （list :a 1 :b 2 :c 3）:c）得到3</p>
<h2 id="make-cd函数">make-cd函数</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> make-cd <span class="list">(<span class="keyword">title</span> artist rating ripped)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">list</span></span> <span class="attribute">:title</span> title <span class="attribute">:artist</span> artist <span class="attribute">:rating</span> rating <span class="attribute">:ripped</span> ripped)</span>)</span></span><br></pre></td></tr></table></figure>
<p>defun告诉我们正在定义一个函数</p>
<p>函数名是make-cd，函数名都是-在中间命名，这个和其他语言区别啊</p>
<p>跟在名字后面的是形参列表，这个函数有四个形参 title artist rating 和ripped</p>
<p>形参列表后面的都是函数体，上面的函数体只有一个形式，即对list的调用，档make-cd被调用时，传递给调用的参数被绑定到形参列表中的变量上。</p>
<p>列如，为了建立一个关于Kathy Mattea的名为Roses的CD的记录，可以这样调用make-cd</p>
<p><code>(make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t)</code></p>
<p>回车返回(:TITLE “Roses” :ARTIST “Kathy Mattea” :RATING 7 :RIPPED T)</p>
<h1 id="录入CD">录入CD</h1><h2 id="DEFVAR宏定义全局变量*db*">DEFVAR宏定义全局变量*db*</h2><p>只有单一记录还不能算是一个数据库，需要一些更大的结构来保存记录，出于简化目的，可以使用一个全局变量*db*</p>
<p>命名中的*号是Lisp的全局变量命名约定</p>
<p><code>(defvar *db* nil)</code></p>
<p>可以用PUSH宏为*db*添加新的项，稍微抽象一些，因此可以定义一个函数add-record来给数据库增加一条记录</p>
<p>其实就是插入数据</p>
<p><code>(defun add-record (cd) (push cd *db*))</code></p>
<h2 id="插入数据">插入数据</h2><p>现在可以讲add-record和make-cd一起使用，为数据库添加新CD记录了</p>
<p><code>(add-record (make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t))</code></p>
<p><code>(add-record (make-cd &quot;Qoses&quot; &quot;Kathy Mattea&quot; 6 t))</code>    </p>
<p>每次都PUSH返回正在修改的变量的最新值</p>
<h1 id="查看数据库的内容">查看数据库的内容</h1><h2 id="无论如何，输入*db*都可以看到*db*的当前值">无论如何，输入*db*都可以看到*db*的当前值</h2><p>但是这个查看方式不爽，不是人类看的，可以用一个dump-db函数讲数据库变成有格式的，符合人类看的</p>
<p>比如</p>
<p>TITLE: home<br>ARTIST: da<br>RATING:     5<br>ROPPED: T</p>
<p>TITLE: homeqe<br>ARTIST: da<br>RATING:     6<br>ROPPED: T</p>
<p><del>全局变量一个缺点是每时每刻只能有一个数据库</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">	<span class="list">(<span class="keyword">dolist</span> <span class="list">(<span class="keyword">cd</span> <span class="variable">*db*</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~a: ~10t~a~%~&#125;~%"</span> cd)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的工作原理就是在使用DOLIST宏在*db*的所有元素上循环，依次绑定每个元素到变量cd上，然后使用format函数打印出每个cd的值</p>
<p>format至少接收两个参数，第一个是用来发送输出的流，t是标准输出流的简称。</p>
<p>第二个蚕食是一个格式字符串，内容既包括字面文本，也包括那些告诉format如何插入其余参数等信息的指令，。格式指令以~开始，类似于printf指令以%开始，</p>
<p>~a指令是美化指令，它的意图是消耗一个参数，然后将其输出成人类可读的形式，这将使得关键字被渲染成不带前导冒号的形式，而字符串也不再有引号呢，</p>
<p>比如<code>(format t &quot;~a&quot; &quot;jing yu&quot;)</code></p>
<p>输出 </p>
<pre><code>jing yu

 <span class="keyword">NIL</span>
</code></pre><p>~t指令用于制表，~10t告诉format产生足够的空格，以确保在处理下一个~a之前将光标移动10列。~t指令不适用任何参数</p>
<p><code>（format &quot;~a:~10t~a&quot; :artist &quot;Dixie Chicks&quot;）</code></p>
<p>输出</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dixie Chicks</span><br><span class="line"></span><br><span class="line"><span class="keyword">NIL</span></span><br></pre></td></tr></table></figure>
<p>现在事情复杂了，档format看到~{的时候，下一个被使用的实参必须是一个列表。format在列表上循环操作，处理位于~{和~}之间的指令，同时在每次需要时，从列表上使用尽可能多的元素，在dump-db里，format循环将每次循环时从列表上消耗一个关键字和一个值。</p>
<p>~%指令并不消耗任何实参，而只是告诉format来产生一个执行，然后再~{循环结束以后，最后一个~%告诉format再输出一个额外的换行，以便在每个cd数据间产生一个空行</p>
<p><del>从技术上来讲，也可以使用format在整个数据库本身循环，从而将dump-db函数变成只有一行</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~&#123;~a: ~10t~a~%~&#125;~%~&#125;"</span> <span class="variable">*db*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="最牛逼的FORMAT指令~R指令">最牛逼的FORMAT指令~R指令</h2><p>用英语说一个大数字</p>
<p><code>(format nil &quot;~r&quot; 3489142793724123341)</code></p>
<h1 id="改进用户交互">改进用户交互</h1><p>这个界面不友好对于普通用户 ，变成提示用户输入的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-read <span class="list">(<span class="keyword">prompt</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">format</span> <span class="variable">*query-io*</span> <span class="string">"~a: "</span> prompt)</span></span><br><span class="line">	<span class="list">(<span class="keyword">force-output</span> <span class="variable">*query-io*</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">read-line</span> <span class="variable">*query-io*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">    <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"ripped [y/n]"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword"><span class="built_in">or</span></span> <span class="list">(<span class="keyword">parse-integer</span> <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span> <span class="attribute">:junk-allowed</span> t)</span> <span class="number">0</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Ripped [y/n]: "</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> add-cds <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">loop</span></span> <span class="list">(<span class="keyword">add-record</span> <span class="list">(<span class="keyword">prompt-for-cd</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Another? [y/n]: "</span>)</span>)</span> <span class="list">(<span class="keyword">return</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="保存和加载数据库">保存和加载数据库</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> save-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">out</span> filename</span><br><span class="line">                           <span class="keyword">:direction</span> <span class="keyword">:output</span></span><br><span class="line">                           <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">print</span> <span class="variable">*db*</span> out)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果退出了下次数据没了就吊了，所以必须保存</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> load-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">in</span> filename)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">setf</span> *db* <span class="list">(<span class="keyword"><span class="built_in">read</span></span> in)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>读取数据</p>
<p>load-db之前要确保保存了，如果save-db后又加入了一些数据，这个时候load-db那么这些刚加入的数据就会丢失</p>
<h1 id="查询数据库">查询数据库</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">#'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"Dixie Chicks"</span>)</span>)</span> *db*)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> select-by-artist <span class="list">(<span class="keyword">artist</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">       #'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"sfada"</span>)</span>)</span> *db*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="更新已有记录">更新已有记录</h1><h1 id="消除重复，获益良多">消除重复，获益良多</h1><h1 id="总结">总结</h1><p>我已经不想写了，也没有完全看下去，最后的部分主要是加入数据库的几个功能-增加删除修改查询</p>
<p>昨天晚上今天晚上两个晚上没有看出什么，唯一的感觉就是这个好像真的很牛逼，几个方法就U可以实现增删查改</p>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Common lisp]]></title>
    <link href="http://ioschen.com/2014/03/18/lisp/"/>
    <id>http://ioschen.com/2014/03/18/lisp/</id>
    <published>2014-03-18T12:41:38.000Z</published>
    <updated>2014-03-19T12:30:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="我为什么学习lisp">我为什么学习lisp</h1><p>至于我为什么学习lisp，这一切都源于Emacs，因为Emacs我知道了lisp，知道它很牛逼，在一些unix论坛也发现很多人说lisp很牛逼。后来学习了几天就没有坚持下去，至于没有坚持下去可能是觉得这个没什么用处吧，这次看完黑客与画家又一次听说lisp很牛逼，实在无法忍受，于是这次开始学习lisp。看看到底有没有外界说的那么牛逼。思想上能有什么启发。</p>
<h1 id="lisp环境的安装">lisp环境的安装</h1><p>我对lisp的历史，分支什么的不是太感兴趣，只是在书中稍微了解了下，直接开始学习了。<br>Common lisp学习环境可以下载一个lispbox或者ccl（这个是Mac上面当今最主流的）。</p>
<p><a href="http://common-lisp.net/project/lispbox/" target="_blank" rel="external">lispbox下载链接</a><br>其实lispbox就是Emacs配置的</p>
<p>CCL可以直接从AppStore下载</p>
<p>这两个在Mac上面其实都很简单，不需要怎么配置就可以直接使用，但是我很喜欢CCL，因为它简单而又强大。</p>
<h1 id="Hello_World">Hello World</h1><ol>
<li><code>“hello，world”</code></li>
<li><code>（format t &quot;hello,world&quot;）</code></li>
<li><code>(write-line &quot;hello,world&quot;)</code></li>
<li><code>(print &quot;hello,world&quot;)</code><br>这四种各有含义。<a id="more"></a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="我为什么学习lisp">我为什么学习lisp</h1><p>至于我为什么学习lisp，这一切都源于Emacs，因为Emacs我知道了lisp，知道它很牛逼，在一些unix论坛也发现很多人说lisp很牛逼。后来学习了几天就没有坚持下去，至于没有坚持下去可能是觉得这个没什么用处吧，这次看完黑客与画家又一次听说lisp很牛逼，实在无法忍受，于是这次开始学习lisp。看看到底有没有外界说的那么牛逼。思想上能有什么启发。</p>
<h1 id="lisp环境的安装">lisp环境的安装</h1><p>我对lisp的历史，分支什么的不是太感兴趣，只是在书中稍微了解了下，直接开始学习了。<br>Common lisp学习环境可以下载一个lispbox或者ccl（这个是Mac上面当今最主流的）。</p>
<p><a href="http://common-lisp.net/project/lispbox/">lispbox下载链接</a><br>其实lispbox就是Emacs配置的</p>
<p>CCL可以直接从AppStore下载</p>
<p>这两个在Mac上面其实都很简单，不需要怎么配置就可以直接使用，但是我很喜欢CCL，因为它简单而又强大。</p>
<h1 id="Hello_World">Hello World</h1><ol>
<li><code>“hello，world”</code></li>
<li><code>（format t &quot;hello,world&quot;）</code></li>
<li><code>(write-line &quot;hello,world&quot;)</code></li>
<li><code>(print &quot;hello,world&quot;)</code><br>这四种各有含义。]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
</feed>
