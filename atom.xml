<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[忠良]]></title>
  <subtitle><![CDATA[得良哥一诺，如得黄金万两]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ioschen.com/"/>
  <updated>2015-11-03T16:23:44.000Z</updated>
  <id>http://ioschen.com/</id>
  
  <author>
    <name><![CDATA[忠良]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift获取WIFI的SSID 和Swift获取IP]]></title>
    <link href="http://ioschen.com/2015/08/17/swiftssid/"/>
    <id>http://ioschen.com/2015/08/17/swiftssid/</id>
    <published>2015-08-17T07:42:45.000Z</published>
    <updated>2015-11-03T16:23:44.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ioschen.com/images/emacs.png" alt="emacs"></p>
<a id="more"></a>
<h2 id="WIFI的SSID">WIFI的SSID</h2><p>先导入 import SystemConfiguration.CaptiveNetwork<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getSSID</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> interfaces: <span class="type">CFArray</span>! = <span class="type">CNCopySupportedInterfaces</span>()?.takeRetainedValue()</span><br><span class="line">        <span class="keyword">if</span> interfaces == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> if0: <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;? = <span class="type">CFArrayGetValueAtIndex</span>(interfaces, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> if0 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> interfaceName: <span class="type">CFStringRef</span> = <span class="built_in">unsafeBitCast</span>(if0!, <span class="type">CFStringRef</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> dictionary = <span class="type">CNCopyCurrentNetworkInfo</span>(interfaceName)?.takeRetainedValue() <span class="keyword">as</span> <span class="type">NSDictionary</span>?</span><br><span class="line">        <span class="keyword">if</span> dictionary == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dictionary?[kCNNetworkInfoKeySSID <span class="keyword">as</span> <span class="type">String</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Swift获取IP">Swift获取IP</h2><p>先在桥接文件中加入  <code>#include &lt;ifaddrs.h&gt;</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return IP address of WiFi interface (en0) as a String, or `nil`</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getWiFiAddress</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> address : <span class="type">String</span>?</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Get list of all interfaces on the local machine:</span></span><br><span class="line">        <span class="keyword">var</span> ifaddr : <span class="type">UnsafeMutablePointer</span>&lt;ifaddrs&gt; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> getifaddrs(&amp;ifaddr) == <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// For each interface ...</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> ptr = ifaddr; ptr != <span class="literal">nil</span>; ptr = ptr.memory.ifa_next) &#123;</span><br><span class="line">                <span class="keyword">let</span> interface = ptr.memory</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Check for IPv4 or IPv6 interface:</span></span><br><span class="line">                <span class="keyword">let</span> addrFamily = interface.ifa_addr.memory.sa_family</span><br><span class="line">                <span class="keyword">if</span> addrFamily == <span class="type">UInt8</span>(<span class="type">AF_INET</span>) || addrFamily == <span class="type">UInt8</span>(<span class="type">AF_INET6</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Check interface name:</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> name = <span class="type">String</span>.fromCString(interface.ifa_name) <span class="keyword">where</span> name == <span class="string">"en0"</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Convert interface address to a human readable string:</span></span><br><span class="line">                        <span class="keyword">var</span> addr = interface.ifa_addr.memory</span><br><span class="line">                        <span class="keyword">var</span> hostname = [<span class="type">CChar</span>](<span class="built_in">count</span>: <span class="type">Int</span>(<span class="type">NI_MAXHOST</span>), repeatedValue: <span class="number">0</span>)</span><br><span class="line">                        getnameinfo(&amp;addr, socklen_t(interface.ifa_addr.memory.sa_len),</span><br><span class="line">                            &amp;hostname, socklen_t(hostname.<span class="built_in">count</span>),</span><br><span class="line">                            <span class="literal">nil</span>, socklen_t(<span class="number">0</span>), <span class="type">NI_NUMERICHOST</span>)</span><br><span class="line">                        address = <span class="type">String</span>.fromCString(hostname)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            freeifaddrs(ifaddr)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> address</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ioschen.com/images/emacs.png" alt="emacs"></p>]]>
    
    </summary>
    
      <category term="swift ssid" scheme="http://ioschen.com/tags/swift-ssid/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac开发NSButton学习笔记]]></title>
    <link href="http://ioschen.com/2015/01/07/studyui/"/>
    <id>http://ioschen.com/2015/01/07/studyui/</id>
    <published>2015-01-07T13:36:10.000Z</published>
    <updated>2015-03-30T07:31:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="新建项目StudyUI">新建项目StudyUI</h3><ol>
<li>和IOS项目一样,新建工程StudyUI 不适用storyboard</li>
<li>新建文件MainMenuView继承NSView</li>
<li>设置如下图<br><img src="http://ioschen.com/images/mac/nsbutton/button1.jpg" alt="image"></li>
</ol>
<h3 id="NSButton属性">NSButton属性</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">drawRect:</span>(NSRect)dirtyRect &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">drawRect:</span>dirtyRect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Drawing code here.</span></span><br><span class="line">    </span><br><span class="line">    NSButton *button=[[NSButton alloc]<span class="string">initWithFrame:</span>NSMakeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    [button <span class="string">setButtonType:</span> NSMomentaryPushInButton];<span class="comment">//集中样式看API</span></span><br><span class="line">    button.bezelStyle=NSRoundRectBezelStyle;</span><br><span class="line">    [button <span class="string">setBordered:</span> NO];<span class="comment">//默认有边框 因为设置图片所有去掉边框</span></span><br><span class="line">    [button <span class="string">setTarget:</span>self];</span><br><span class="line">    [button <span class="string">setAction:</span><span class="annotation">@selector</span>(<span class="string">hehe:</span>)];<span class="comment">//设置按钮点击事件</span></span><br><span class="line">    [button <span class="string">setTag:</span><span class="number">10</span>];</span><br><span class="line">    <span class="comment">//[button setTitle:@"我不是按钮"];</span></span><br><span class="line">    [button <span class="string">setImage:</span>[NSImage <span class="string">imageNamed:</span>@<span class="string">"Emacs.png"</span>]];</span><br><span class="line">    <span class="comment">//下面这个是设置图片裁剪自适应 如果不加这句话图片是300*300 按钮大小是100*100那么现实的只是图片的局部</span></span><br><span class="line">    [[button cell] <span class="string">setImageScaling:</span>NSImageScaleAxesIndependently];</span><br><span class="line">    </span><br><span class="line">    [button <span class="string">setImagePosition:</span>NSImageOnly];</span><br><span class="line">    [self <span class="string">addSubview:</span>button];</span><br><span class="line"><span class="comment">//    [self.window.contentView addSubview: button];</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="typename">void</span>)<span class="string">hehe:</span>(id)sender&#123;</span><br><span class="line">    NSLog(@<span class="string">"hehe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用拖拽线的方式设置按钮事件 还可以设置属性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="新建项目StudyUI">新建项目StudyUI</h3><ol>
<li>和IOS项目一样,新建工程StudyUI 不适用storyboard</li>
<li>新建文件MainMenuView继承NSView</li>
<li>设置如下图<br><img sr]]>
    </summary>
    
      <category term="Mac软件" scheme="http://ioschen.com/tags/Mac%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的Mac定制软件]]></title>
    <link href="http://ioschen.com/2015/01/07/cly/"/>
    <id>http://ioschen.com/2015/01/07/cly/</id>
    <published>2015-01-07T13:36:10.000Z</published>
    <updated>2015-03-30T07:21:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="项目简介">项目简介</h3><p>新建项目CLY</p>
<h3 id="Mac图标">Mac图标</h3><p><img src="http://ioschen.com/images/cly.png" alt="image"></p>
<ol>
<li>icon_16x16.png</li>
<li>icon_16x16@2x.png</li>
<li>icon_32x32.png</li>
<li>icon_32x32@2x.png</li>
<li>icon_128x128.png</li>
<li>icon_128x128@2x.png</li>
<li>icon_256x256.png</li>
<li>icon_256x256@2x.png</li>
<li>icon_512x512.png</li>
<li>icon_512x512@2x.png</li>
</ol>
<h3 id="设置图标">设置图标</h3><p><img src="http://ioschen.com/images/cly_icon.png" alt="image"></p>
<h3 id="Git">Git</h3><p><a href="https://github.com/ioschen/OnlyYou" target="_blank" rel="external">Github地址</a></p>
<p>持续更新！</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="项目简介">项目简介</h3><p>新建项目CLY</p>
<h3 id="Mac图标">Mac图标</h3><p><img src="http://ioschen.com/images/cly.png" alt="image"></p>
<ol>
<li>icon_16x16.png</li>
<li>icon_16x16@2x.png</li>
<li>icon_32x32.png</li>
<li>icon_32x32@2x.png</li>
<li>icon_128x128.png</li>
<li>icon_128x128@2x.png</li>
<li>icon_256x256.png</li>
<li>icon_256x256@2x.png</li>
<li>icon_512x512.png</li>
<li>icon_512x512@2x.png</li>
</ol>
<h3 id="设置图标">设置图标</h3><p><img src="http://ioschen.com/images/cly_icon.png" alt="image"></p>
<h3 id="Git">Git</h3><p><a href="https://github.com/ioschen/OnlyYou">Github地址</a></p>
<p>持续更新！</p>]]>
    
    </summary>
    
      <category term="Mac软件" scheme="http://ioschen.com/tags/Mac%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BestApp]]></title>
    <link href="http://ioschen.com/2014/12/10/bestapp/"/>
    <id>http://ioschen.com/2014/12/10/bestapp/</id>
    <published>2014-12-10T03:14:23.000Z</published>
    <updated>2015-11-02T08:36:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="必备软件">必备软件</h2><ol>
<li>dropbox</li>
<li>mou</li>
<li>1password</li>
<li>readkit</li>
<li>colorsnapper</li>
</ol>
<a id="more"></a>
<h2 id="快捷键组合">快捷键组合</h2><ol>
<li>Shift+Command+G 三个组合按键查找文件</li>
<li>在你创建仓库的目录下有个隐藏文件叫”.git”把这个文件删除就可以了。</li>
</ol>
<h2 id="网站">网站</h2><p>dnspod</p>
<hr>
<h1 id="超链接，页面设置">超链接，页面设置</h1><h1 id="定位技术（表格、层、框架）。">定位技术（表格、层、框架）。</h1><!--more-->]]></content>
    <summary type="html">
    <![CDATA[你对本页的描述]]>
    
    </summary>
    
      <category term="APP" scheme="http://ioschen.com/tags/APP/"/>
    
      <category term="技巧" scheme="http://ioschen.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="default" scheme="http://ioschen.com/categories/default/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[one]]></title>
    <link href="http://ioschen.com/2014/08/31/one/"/>
    <id>http://ioschen.com/2014/08/31/one/</id>
    <published>2014-08-30T16:06:09.000Z</published>
    <updated>2014-08-30T16:12:00.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚灵光一闪，想到一个绝佳创意。建立一个网站叫做壹元购，每天推一到两款产品，比如iPhone5s手机5000元。只要超过5230个人购买就生效，否则参与的一元钱退还。超过的话就抽奖，抽中的人得到。为了公平起见，抽中的人根据当天的彩票号码或者其他号码进行算法处理，保证只能一个人中奖。</p>
<h5 id="这个最大的问题就是属于博彩。">这个最大的问题就是属于博彩。</h5><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚灵光一闪，想到一个绝佳创意。建立一个网站叫做壹元购，每天推一到两款产品，比如iPhone5s手机5000元。只要超过5230个人购买就生效，否则参与的一元钱退还。超过的话就抽奖，抽中的人得到。为了公平起见，抽中的人根据当天的彩票号码或者其他号码进行算法处理，保证只能一个人中奖。</p>
<h5 id="这个最大的问题就是属于博彩。">这个最大的问题就是属于博彩。</h5>]]>
    
    </summary>
    
      <category term="灵感" scheme="http://ioschen.com/tags/%E7%81%B5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bug]]></title>
    <link href="http://ioschen.com/2014/06/21/bug/"/>
    <id>http://ioschen.com/2014/06/21/bug/</id>
    <published>2014-06-21T14:05:04.000Z</published>
    <updated>2014-06-21T14:08:28.000Z</updated>
    <content type="html"><![CDATA[<p>今天出现一个问题</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> Symbol not <span class="string">found:</span> _OBJC_CLASS_$_NSMutableURLRequest</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br><span class="line">  Expected <span class="string">in:</span> <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CFNetwork.framework/CFNetwork</span><br><span class="line"> <span class="keyword">in</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br></pre></td></tr></table></figure>
<p>正好我升级了ios8 xcode的sdk也是ios8<br>照成这个原因是我用的smartlink已经在包里引用了CFNetwork.framework而我重复引用了。最后删掉就解决了<br>ps:奇怪的是我平时调试都没有出问题。今天拿到朋友手机就出现了。</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>今天出现一个问题</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> Symbol not <span class="string">found:</span> _OBJC_CLASS_$_NSMutableURLRequest</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br><span class="line">  Expected <span class="string">in:</span> <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CFNetwork.framework/CFNetwork</span><br><span class="line"> <span class="keyword">in</span> <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>A730B070-<span class="number">0</span>A0B-<span class="number">4345</span>-<span class="number">9398</span>-DA2C53DCC31D<span class="regexp">/scb.app/</span>scb</span><br></pre></td></tr></table></figure>
<p>正好我升级了ios8 xcode的sdk也是ios8<br>照成这个原因是我用的smartlink已经在包里引用了CFNetwork.framework而我重复引用了。最后删掉就解决了<br>ps:奇怪的是我平时调试都没有出问题。今天拿到朋友手机就出现了。</p>]]>
    
    </summary>
    
      <category term="ios" scheme="http://ioschen.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[freebsd 10.0安装]]></title>
    <link href="http://ioschen.com/2014/04/05/freebsd/"/>
    <id>http://ioschen.com/2014/04/05/freebsd/</id>
    <published>2014-04-05T11:20:06.000Z</published>
    <updated>2014-04-05T12:36:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="理由">理由</h1><h1 id="下载">下载</h1><p><a href="http://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.0/" target="_blank" rel="external">下载地址</a></p>
<p>找到64为的这个</p>
<ol>
<li>FreeBSD-10.0-RELEASE-amd64-bootonly.iso    </li>
<li>FreeBSD-10.0-RELEASE-amd64-disc1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-dvd1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-memstick.img</li>
</ol>
<p>四个镜像文件</p>
<ol>
<li>第一个FreeBSD-10.0-RELEASE-amd64-bootonly.iso是可以引导的光盘，只能引导系统，通常用于网络安装。基本没用。</li>
<li>第二个FreeBSD-10.0-RELEASE-amd64-disc1.iso是系统光盘的第一张。用这张就可以安装一个基本的系统。其他的软件，在系统安装完之后安装。</li>
<li>第三个FreeBSD-10.0-RELEASE-amd64-dvd1.iso是系统盘的DVD版本。包括的软件比上一个多一点。不过这些软件通过网络也可以安装。看你的网速了。快的话，没用必要用这个。</li>
<li>第四个FreeBSD-10.0-RELEASE-amd64-memstick.img个是U盘镜像。用相关工具写入U盘就行。<br>还有一个是LiveCD。可以用它启动计算机进入系统。用来进行系统的演示，而不用进行硬盘的改动。当然了，也可以用它安装系统。</li>
</ol>
<p>这里我选择第三个,因为我的网络不是太好.<br><a id="more"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="理由">理由</h1><h1 id="下载">下载</h1><p><a href="http://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.0/">下载地址</a></p>
<p>找到64为的这个</p>
<ol>
<li>FreeBSD-10.0-RELEASE-amd64-bootonly.iso    </li>
<li>FreeBSD-10.0-RELEASE-amd64-disc1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-dvd1.iso</li>
<li>FreeBSD-10.0-RELEASE-amd64-memstick.img</li>
</ol>
<p>四个镜像文件</p>
<ol>
<li>第一个FreeBSD-10.0-RELEASE-amd64-bootonly.iso是可以引导的光盘，只能引导系统，通常用于网络安装。基本没用。</li>
<li>第二个FreeBSD-10.0-RELEASE-amd64-disc1.iso是系统光盘的第一张。用这张就可以安装一个基本的系统。其他的软件，在系统安装完之后安装。</li>
<li>第三个FreeBSD-10.0-RELEASE-amd64-dvd1.iso是系统盘的DVD版本。包括的软件比上一个多一点。不过这些软件通过网络也可以安装。看你的网速了。快的话，没用必要用这个。</li>
<li>第四个FreeBSD-10.0-RELEASE-amd64-memstick.img个是U盘镜像。用相关工具写入U盘就行。<br>还有一个是LiveCD。可以用它启动计算机进入系统。用来进行系统的演示，而不用进行硬盘的改动。当然了，也可以用它安装系统。</li>
</ol>
<p>这里我选择第三个,因为我的网络不是太好.<br>]]>
    
    </summary>
    
      <category term="freebsd" scheme="http://ioschen.com/tags/freebsd/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎样才能改变一个人]]></title>
    <link href="http://ioschen.com/2014/04/03/jing/"/>
    <id>http://ioschen.com/2014/04/03/jing/</id>
    <published>2014-04-03T13:04:05.000Z</published>
    <updated>2015-11-02T08:17:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="怎样才能改变一个人">怎样才能改变一个人</h1><ul>
<li>自然改变</li>
<li>人为改变</li>
<li>环境改变</li>
</ul>
<p>到学校几天改变，比如一个人以前上课穿衬衫，但是学校要求必须裸体去上课，开始有一个人反对，这个人被退学了（或者主动离开了），忽然学生人群中有一个人带头脱掉上衣去上课。大家就都裸体了，随着时间的推移，大家就觉得这个很正常了，而看到别的学校都穿上衣上课就会感觉很鄙视，感觉别人是外星人。这个在军队，公司都是这样子吧，</p>
<a id="more"></a>
<p>一个人以前没见过米饭，只吃过面条，忽然有一天，有一个偶然的机会，去了一个城市，吃到了米饭，忽然觉得米饭才是人吃的，面条是什么啊，决定再也不回去了。</p>
<p>从小父母说去考公务员，考上了就可以为人民服务呢，经过十年寒窗苦读后发现事实并不是这个样子，我的领导做非法的，我的同事做非法的，我的下属也做非法的，我到底做不做呢，大家都这么做，我该不该做呢</p>
<p>一个学校裸体上课，老师想反正不是我的孩子，裸体有什么关系呢，根我没有关系都行，我什么都不管，只当娱乐吧，变态的娱乐吧。</p>
<p>什么才是对什么才是错</p>
<p>一个人一直坚信一个东西，忽然有一天大显自己坚信的东西被一个人所击败后，会是什么样子呢</p>
<p>一个人坚守一件事情很多年，忽然有一天这个坚守的东西被别人告知是不存在的，一开始肯定是极力不相信，非要找证据，找来找去，发现别人是对的，一直找不到证据，反而发现事实就是这个样子的，而最有理的证据就是这个打破事实的人，她简直就是恶魔啊，应该怎么对待 她呢，事实往往就是这么的无聊啊，你们说怎么做呢啊，你们什么时候发现就是这个样子的呢啊，什么人才是真的呢，了解一个人真的很重要，，高山流水啊，就是高山流水，高山流水，</p>
<p>知己知彼，百战不殆，我只想知道一个了解自己的人，了解真的很重要啊，你们说是不是啊，你们说是不是啊，我们就是脸皮后啊，你们说是不是啊，你们说是不是啊，我们就是这个意思啊，装逼有那么必要吗，，，，装逼的几个原则我已经全部做到了，我就是装逼的原则啊，</p>
<p>事情的真相往往就是让别人吐的，你们说是不是啊，我们就是这个意思啊，你们说呢啊，我们就是这个啊，你们这个我们就是这个啊，你们手是不是啊，我们的啊，是什么呢啊，你们什么的啊，没主意赢写了三签字呢啊，我们什么时候才能够整整的斯卡过uge人味儿啊，</p>
<p>我现在是不是有点犯浑呢啊， 我已经不想要毕业证呢啊，我开始思考人活着是为什么呢啊，到底要不要同流合污，还是做最干脆的自己。这个就会与一开始被盗相次啊，你们是不了解这个社会啊，什么时候的事情啊 ，你们说是不是啊，我们就是开始研究的啊，开始研讨会的啊，你们说是不是啊，我们就是这个意思ia，你们什么时候的事情那个啊，你们不知道啊，怎么知道啊，你们是什么的呢啊，是不是啊我们什么时候人才就是作贼做做你们什么时候</p>
<h3 id="人是不分年龄的，不分大小，我不管这个人多大，其实就是兄弟啊，你们说是不是啊，我们兄弟之间就是这个样子的啊，你们说是不死你们，为什么灰色这样字的啊_，我们就是不知道呢啊，你们手是什么圆瑛呢啊，">人是不分年龄的，不分大小，我不管这个人多大，其实就是兄弟啊，你们说是不是啊，我们兄弟之间就是这个样子的啊，你们说是不死你们，为什么灰色这样字的啊 ，我们就是不知道呢啊，你们手是什么圆瑛呢啊，</h3><p>我想去当兵啊，我不知道我为什么这么想呢啊， 我到底想干嘛啊，两年后我就24呢啊，我今年22两年后就是15呢啊，是不是啊，我们的大雾怎么样子呢啊，你们说是不是啊，我能够看出来她不喜欢当兵的，啊，，但是我喜欢它啊，你握手怎么办呢啊，这个人真的额是这个样子的按摩，你说再呢吗做呢啊，我就是喜欢她啊，我已经无法子吧呢啊，你们说是不是我么明年就是这个沿海字的啊吗，人怎么往往就是这么喜欢着iji的文章啊，很多时候都一几个不知道打了多少个字呢啊，你们什么时候你們什麼手是的我們就是中國兒女啊，你們什麼時候開始的啊，　</p>
<hr>
<h1 id="为什么要改变一个人">为什么要改变一个人</h1><hr>
<h1 id="正义">正义</h1><p>在我很小的时候，师长经常问我们想做什么，大多数都说做科学家，医生，解放军，而我当年说的什么我已经记不清楚了，按道理说自己的梦想印象能不深吗？还能忘记？这个怎么可能？但是事实往往就是如此，一个很小的孩子怎么可能知道梦想呢，（我不研究概率）</p>
<p>为什么上学？<br>很多时候我疑问为什么要上学，上学是干嘛的，我一直觉得上学是成年人为了甩开小孩，让小孩不再成为负担，但是 以前不是这样的，新中国之前，小孩可以打打下手，比如木匠可以拿木头，学学技术，而现在研究化学，智能学习</p>
<h4 id="正式话题">正式话题</h4><p>其实我想说的是怎样判定一个人是好人还是坏人，</p>
<p>恐怖组织是什么意思，如果我就是想死，但是死之前杀掉一些人，这个难道不对吗？我只想说站在杀人者的角度来想，这个一点也没有错，因为他们就是这个样子的啊。你说是不是啊，</p>
<p>怎样才能改变一个人，</p>
<h1 id="计划，事情没有计划做不好。">计划，事情没有计划做不好。</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="怎样才能改变一个人">怎样才能改变一个人</h1><ul>
<li>自然改变</li>
<li>人为改变</li>
<li>环境改变</li>
</ul>
<p>到学校几天改变，比如一个人以前上课穿衬衫，但是学校要求必须裸体去上课，开始有一个人反对，这个人被退学了（或者主动离开了），忽然学生人群中有一个人带头脱掉上衣去上课。大家就都裸体了，随着时间的推移，大家就觉得这个很正常了，而看到别的学校都穿上衣上课就会感觉很鄙视，感觉别人是外星人。这个在军队，公司都是这样子吧，</p>]]>
    
    </summary>
    
      <category term="人性" scheme="http://ioschen.com/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[宏:标准控制结构]]></title>
    <link href="http://ioschen.com/2014/04/01/ifelseand/"/>
    <id>http://ioschen.com/2014/04/01/ifelseand/</id>
    <published>2014-04-01T01:32:28.000Z</published>
    <updated>2015-11-02T08:51:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="引导">引导</h1><p>lisp和其他语言一样，有条件表达式，垃圾收集，但是lisp的宏系统却始终使他保持了在语言风格上的独特性。lisp的宏和任何语言的“宏”是不一样的。这个东西很难解释。</p>
<p>语言都有一个“核心”语言实现的标准功能库（java的JDK），如果某些功能没有定义在标准库中，可以自己实现。（求平凡实现列子）</p>
<p>。。。。。。</p>
<h1 id="WHEN和UNLESS">WHEN和UNLESS</h1><p>最基本的条件执行形式是IF特殊操作符，其基本形式是:如果x成立，那么执行y，否则执行z。</p>
<p><code>(if condition then-form [else-form])</code></p>
<p>condition被求值，如果其值非NIL，那么then-form会被求值并返回其结果。否则，如果有else-form，他将被求值并返回其结果。如果condition是NIL并且没有else-form，那么IF返回NIL。（<font color="red">condition是判断条件，如果为nil就返回then-form的值，否则要是有else-form就返回else-form的值。如果只有condition并且值是nil就返回nil</font>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"YES"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"no"</span></span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"yes"</span>)</span></span><br><span class="line">NIL</span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">3</span> <span class="number">2</span>)</span><span class="string">"yes"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"yes"</span></span><br></pre></td></tr></table></figure>
<p>有一个情况不行，当条件成立，连续执行两个就不可以，因为会被当成else执行。要想在条件语句执行多个就必须使用progn特殊操作符。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">progn</span></span><br><span class="line"> 		<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line"> 		<span class="list">(<span class="keyword">update</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如上面，这样才会在a成立的时候执行into再执行update。</p>
<p>其lisp提供了一个标准宏WHEN 就是解决这个问题的。上面的可以写成这个样子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">update</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果它没有被内置到标准库中，你也可以像下面这样用一个宏来定义WHEN<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> ,condition <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>与WHEN宏同系列的另一个宏是UNLESS 它取相反条件，只有条件假的时候才求值其形式体。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> ,condition)</span> <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><del>其实上面的定义不对，因为重新定义when所在的common-lisp包中的名字是非法的，如果非要这么做，可以修改名字，比如my-when</del></p>
<h1 id="COND">COND</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> a</span><br><span class="line">	<span class="list">(<span class="keyword">do-x</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> b</span><br><span class="line">		<span class="list">(<span class="keyword">do-y</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">do-z</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>多重分支用if是可以，但是比较丑陋</p>
<p>如果子句再分很多就更丑了，但是lisp提供了一个<code>用于表达多重分支条件的宏COND</code>基本结构如下</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">cond</span></span></span><br><span class="line">	<span class="list">(<span class="keyword">test-1</span> form*)</span></span><br><span class="line">	<span class="list">(<span class="keyword">test-2</span> form*)</span></span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	<span class="list">(<span class="keyword">test-N</span> form*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="AND、OR和NOT">AND、OR和NOT</h1><h1 id="循环">循环</h1><h1 id="DOLIST和DOTIMES">DOLIST和DOTIMES</h1><h1 id="DO">DO</h1><h1 id="强大的LOOP">强大的LOOP</h1><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="引导">引导</h1><p>lisp和其他语言一样，有条件表达式，垃圾收集，但是lisp的宏系统却始终使他保持了在语言风格上的独特性。lisp的宏和任何语言的“宏”是不一样的。这个东西很难解释。</p>
<p>语言都有一个“核心”语言实现的标准功能库（java的JDK），如果某些功能没有定义在标准库中，可以自己实现。（求平凡实现列子）</p>
<p>。。。。。。</p>
<h1 id="WHEN和UNLESS">WHEN和UNLESS</h1><p>最基本的条件执行形式是IF特殊操作符，其基本形式是:如果x成立，那么执行y，否则执行z。</p>
<p><code>(if condition then-form [else-form])</code></p>
<p>condition被求值，如果其值非NIL，那么then-form会被求值并返回其结果。否则，如果有else-form，他将被求值并返回其结果。如果condition是NIL并且没有else-form，那么IF返回NIL。（<font color=red>condition是判断条件，如果为nil就返回then-form的值，否则要是有else-form就返回else-form的值。如果只有condition并且值是nil就返回nil</font>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"YES"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"no"</span></span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">2</span> <span class="number">3</span>)</span> <span class="string">"yes"</span>)</span></span><br><span class="line">NIL</span><br><span class="line">CL-USER&gt; <span class="list">(<span class="keyword">if</span> <span class="list">(<span class="keyword">&gt;</span> <span class="number">3</span> <span class="number">2</span>)</span><span class="string">"yes"</span> <span class="string">"no"</span>)</span></span><br><span class="line"><span class="string">"yes"</span></span><br></pre></td></tr></table></figure>
<p>有一个情况不行，当条件成立，连续执行两个就不可以，因为会被当成else执行。要想在条件语句执行多个就必须使用progn特殊操作符。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">progn</span></span><br><span class="line"> 		<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line"> 		<span class="list">(<span class="keyword">update</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如上面，这样才会在a成立的时候执行into再执行update。</p>
<p>其lisp提供了一个标准宏WHEN 就是解决这个问题的。上面的可以写成这个样子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword">a</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">into</span></span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">update</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果它没有被内置到标准库中，你也可以像下面这样用一个宏来定义WHEN<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> ,condition <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>与WHEN宏同系列的另一个宏是UNLESS 它取相反条件，只有条件假的时候才求值其形式体。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defnacro</span> when <span class="list">(<span class="keyword">condition</span> &amp;rest body)</span></span><br><span class="line">	`<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> ,condition)</span> <span class="list">(<span class="keyword">progn</span> ,@body)</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><del>其实上面的定义不对，因为重新定义when所在的common-lisp包中的名字是非法的，如果非要这么做，可以修改名字，比如my-when</del></p>
<h1 id="COND">COND</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">if</span></span> a</span><br><span class="line">	<span class="list">(<span class="keyword">do-x</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> b</span><br><span class="line">		<span class="list">(<span class="keyword">do-y</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">do-z</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>多重分支用if是可以，但是比较丑陋</p>
<p>如果子句再分很多就更丑了，但是lisp提供了一个<code>用于表达多重分支条件的宏COND</code>基本结构如下</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">cond</span></span></span><br><span class="line">	<span class="list">(<span class="keyword">test-1</span> form*)</span></span><br><span class="line">	<span class="list">(<span class="keyword">test-2</span> form*)</span></span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	   .</span><br><span class="line">	<span class="list">(<span class="keyword">test-N</span> form*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="AND、OR和NOT">AND、OR和NOT</h1><h1 id="循环">循环</h1><h1 id="DOLIST和DOTIMES">DOLIST和DOTIMES</h1><h1 id="DO">DO</h1><h1 id="强大的LOOP">强大的LOOP</h1>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[freebook]]></title>
    <link href="http://ioschen.com/2014/03/30/freebook/"/>
    <id>http://ioschen.com/2014/03/30/freebook/</id>
    <published>2014-03-30T12:57:31.000Z</published>
    <updated>2015-11-03T13:26:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="免费的编程中文书籍索引">免费的编程中文书籍索引</h1><h3 id="转载地点"><a href="https://github.com/Yixiaohan/free-programming-books-zh_CN" target="_blank" rel="external">转载地点</a></h3><hr>
<p>免费的编程中文书籍索引，欢迎投稿。</p>
<ul>
<li>国外程序员在 <a href="http://stackoverflow.com/a/1713/343194" target="_blank" rel="external">stackoverflow</a> 推荐的程序员必读书籍，<a href="http://justjavac.com/other/2012/05/15/qualified-programmer-should-read-what-books.html" title="一个合格的程序员应该读过哪些书" target="_blank" rel="external">中文版</a>。</li>
<li><a href="http://stackoverflow.com/q/38210/343194" target="_blank" rel="external">stackoverflow</a> 上的程序员应该阅读的非编程类书籍有哪些？ <a href="what-non-programming-books-should-programmers-read.md">中文版</a></li>
<li><a href="https://github.com/vhf/free-programming-books" target="_blank" rel="external">github</a> 上的一个流行的编程书籍索引  <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-ch.md" target="_blank" rel="external">中文版</a></li>
</ul>
<a id="more"></a>
<h2 id="参与交流">参与交流</h2><p>欢迎大家讲珍藏已久的经典免费书籍共享出来，您可以：</p>
<ul>
<li>使用 <a href="https://github.com/justjavac/free-programming-books-zh_CN/issues" target="_blank" rel="external">Issues</a> 以及 Pull Request </li>
<li>发邮箱给我 <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#106;&#x75;&#x73;&#x74;&#x6a;&#97;&#118;&#97;&#99;&#x2b;&#103;&#104;&#98;&#x6f;&#111;&#107;&#115;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#106;&#x75;&#x73;&#x74;&#x6a;&#97;&#118;&#97;&#99;&#x2b;&#103;&#104;&#98;&#x6f;&#111;&#107;&#115;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></li>
<li>来 <a href="http://segmentfault.com/q/1010000000329895" target="_blank" rel="external">SegmentFault</a> 交流</li>
</ul>
<p><strong>注</strong>：看到有人 fork 此 repository，其实如果觉得有帮助，可以 star 或者 watch，<br>如果 fork 到你的 repositories 下则不能保证你的 repo 是最新的，除非是主动定期的 pull。</p>
<ul>
<li>star 的作用是收藏，目的是方便以后查找。</li>
<li>watch 的作用是关注，目的是等我更新的时候，你可以收到通知。</li>
<li>fork 的作用是参与，目的是你增加新的内容，然后 Pull Request，我会考虑把你的修改和我原来的内容合并。</li>
</ul>
<p>请选择合理的方式。（上面的内容是写给一些 fork 狂的，很多开发者喜欢 fork 一些 linux 内核，jquery之类的东东，其实这些东东完全没有必要 fork）</p>
<h2 id="捐赠与福利">捐赠与福利</h2><p>如果觉得我收录的内容对你有帮助，可以捐赠我点比特币 <code>15hfB3YMe31TkLz9vS8ybY7NFGHRXr2HyP</code>。</p>
<p>如果你没有可以去这儿<strong>免费领取</strong>：<a href="https://github.com/freebitcoin/freebitcoin" target="_blank" rel="external">如何免费获得比特币？</a></p>
<h2 id="目录">目录</h2><ul>
<li><p><a href="#语言无关类">语言无关类</a></p>
<ul>
<li><a href="#操作系统">操作系统</a></li>
<li><a href="#web服务器">WEB服务器</a></li>
<li><a href="#版本控制">版本控制</a></li>
<li><a href="#nosql">NoSQL</a></li>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#项目相关">项目相关</a></li>
<li><a href="#web">Web</a></li>
</ul>
</li>
<li><p><a href="#语言相关类">语言相关类</a></p>
<ul>
<li><a href="#cc">C/C++</a></li>
<li><a href="$css">CSS</a></li>
<li><a href="#dart">Dart</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#ios">iOS</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#shell">Shell</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#groovy">Groovy</a></li>
<li><a href="#lisp">LISP</a></li>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#scala">Scala</a></li>
</ul>
</li>
<li><p><a href="#读书笔记及其它">读书笔记及其它</a></p>
</li>
</ul>
<h2 id="语言无关类">语言无关类</h2><h3 id="操作系统">操作系统</h3><ul>
<li><a href="http://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="external">开源世界旅行手册</a></li>
<li><a href="http://vbird.dic.ksu.edu.tw/" target="_blank" rel="external">鸟哥的Linux私房菜</a> (简体)</li>
<li><a href="http://sourceforge.net/apps/trac/elpi/wiki/ALP" target="_blank" rel="external">Linux 系统高级编程</a></li>
<li><a href="http://billie66.github.io/TLCL/index.html" target="_blank" rel="external">The Linux Command Line</a> (中英文版)</li>
</ul>
<h3 id="WEB服务器">WEB服务器</h3><ul>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="external">Nginx开发从入门到精通</a> (淘宝团队出品)</li>
</ul>
<h3 id="版本控制">版本控制</h3><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简易指南</a></li>
<li><a href="http://gitref.justjavac.com" target="_blank" rel="external">Git 参考手册</a></li>
<li><a href="http://git-scm.com/book/zh" target="_blank" rel="external">Pro Git</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git Magic</a></li>
</ul>
<h3 id="NoSQL">NoSQL</h3><ul>
<li><a href="http://www.yankay.com/wp-content/NoSql_Database_Note.html" target="_blank" rel="external">NoSQL数据库笔谈</a> (<a href="http://yankaycom-wordpress.stor.sinaapp.com/uploads/2012/12/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%B0%88v2.pdf" target="_blank" rel="external">PDF</a>)</li>
<li><a href="http://www.redisbook.com/en/latest/" target="_blank" rel="external">Redis 设计与实现</a></li>
<li><a href="http://www.redisdoc.com/en/latest/" target="_blank" rel="external">Redis 命令参考</a></li>
<li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md" target="_blank" rel="external">The Little MongoDB Book</a></li>
<li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md" target="_blank" rel="external">The Little Redis Book</a></li>
</ul>
<h3 id="MySQL">MySQL</h3><ul>
<li><a href="http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></li>
</ul>
<h3 id="项目相关">项目相关</h3><ul>
<li><a href="http://article.yeeyan.org/view/2251/94882" target="_blank" rel="external">持续集成（第二版）</a> (译言网)</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-ap/" target="_blank" rel="external">让开发自动化系列专栏</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-cq/" target="_blank" rel="external">追求代码质量</a></li>
<li><a href="https://github.com/fool2fish/selenium-doc" target="_blank" rel="external">selenium 中文文档</a></li>
</ul>
<h3 id="Web">Web</h3><ul>
<li><a href="http://www.20thingsilearned.com/zh-CN/home" target="_blank" rel="external">关于浏览器和网络的 20 项须知</a> </li>
<li><a href="http://knowledge.ecomfe.com/" target="_blank" rel="external">前端知识体系</a></li>
<li><a href="http://jinlong.github.io/blog/2013/08/29/devtoolsecrets/" target="_blank" rel="external">浏览器开发工具的秘密</a></li>
<li><a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">Chrome扩展开发文档</a></li>
</ul>
<h2 id="语言相关类">语言相关类</h2><h3 id="C/C++">C/C++</h3><ul>
<li><a href="https://github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial" target="_blank" rel="external">C++ 并发编程指南</a> (<a href="http://weibo.com/1702076100" target="_blank" rel="external">@傅海平ICT</a>)</li>
<li><a href="http://learn.akae.cn/media/index.html" target="_blank" rel="external">Linux C编程一站式学习</a> (宋劲杉, 北京亚嵌教育研究中心)</li>
<li><a href="https://github.com/leeyiw/cgdb-manual-in-chinese" target="_blank" rel="external">CGDB中文手册</a></li>
<li><a href="https://github.com/anjuke/zguide-cn" target="_blank" rel="external">ZMQ 指南</a></li>
</ul>
<h3 id="CSS">CSS</h3><ul>
<li><a href="http://zh.learnlayout.com/" target="_blank" rel="external">学习CSS布局</a></li>
<li><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md" target="_blank" rel="external">通用 CSS 笔记、建议与指导</a></li>
</ul>
<h3 id="Dart">Dart</h3><ul>
<li><a href="http://dart.lidian.info/wiki/Language_Tour" target="_blank" rel="external">Dart 语言导览</a></li>
</ul>
<h3 id="Java">Java</h3><ul>
<li><p><a href="http://www.ibm.com/developerworks/cn/java/j-rtj/?ca=j-h-p" target="_blank" rel="external">实时 Java 系列</a></p>
</li>
<li><p>使用 Eclipse 和 Java SE 6 创建独立 Web Services 应用程序</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/webservices/ws-eclipse-javase1/index.html" target="_blank" rel="external">第 1 部分: Web Services 服务端应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/webservices/tutorials/ws-jse/index.html" target="_blank" rel="external">第 2 部分: Web 服务客户端应用程序</a></li>
</ul>
</li>
<li>JavaServer Faces 1.2 入门<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jsf1/index.html" target="_blank" rel="external">第 1 部分: 构建基本应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jsf2/index.html" target="_blank" rel="external">第 2 部分: JSF 生命周期、转换、检验和阶段监听器</a></li>
</ul>
</li>
<li>用 Eclipse Europa 进行 Web 开发<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa1/index.html" target="_blank" rel="external">第 1 部分: Eclipse Java EE</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa2/index.html" target="_blank" rel="external">第 2 部分: PHP 开发工具</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-eclipse-europa3/index.html" target="_blank" rel="external">第 3 部分: Ruby Development Toolkit 和 RadRails</a></li>
</ul>
</li>
<li>使用 JavaServer Faces 构建 Apache Geronimo 应用程序<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf1/index.html" target="_blank" rel="external">第 1 部分: 使用 Eclipse 和 Apache MyFaces Core 构建基本的应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf2/index.html" target="_blank" rel="external">第 2 部分: 在 JavaServer Faces 中使用 Tomahawk</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf3/index.html" target="_blank" rel="external">第 3 部分: 使用 ajax4jsf 添加 Ajax 功能</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf4/index.html" target="_blank" rel="external">第 4 部分: 使用 Apache Trinidad 组件扩展 JSF</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-jsf5/index.html" target="_blank" rel="external">第 5 部分: 将 JSF 应用程序与 Spring 集成</a></li>
</ul>
</li>
<li>Apache Geronimo 和 Spring 框架<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe1/index.html" target="_blank" rel="external">第 1 部分: 开发方法学</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe2/index.html" target="_blank" rel="external">第 2 部分: 构建第一个应用程序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe3/index.html" target="_blank" rel="external">第 3 部分: 集成 DAO 与 ORM</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe4/index.html" target="_blank" rel="external">第 4 部分: 混合使用 Spring AOP 和 Spring Web Flow</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe5/index.html" target="_blank" rel="external">第 5 部分: Spring MVC</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/opensource/os-ag-springframe6/index.html" target="_blank" rel="external">第 6 部分: Spring MVC：使用 Web 视图技术</a></li>
</ul>
</li>
<li>终极 mashup —— Web 服务和语义 Web<ul>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup1/index.html" target="_blank" rel="external">第 1 部分: 使用与组合 Web 服务</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup2/index.html" target="_blank" rel="external">第 2 部分: 管理 Mashup 数据缓存</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup3/index.html" target="_blank" rel="external">第 3 部分: 理解 RDF 和 RDFs</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup4/index.html" target="_blank" rel="external">第 4 部分: 创建本体</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/xml/x-ultimashup5/index.html" target="_blank" rel="external">第 5 部分: 切换 Web 服务</a></li>
</ul>
</li>
</ul>
<h3 id="JavaScript">JavaScript</h3><ul>
<li><a href="http://chajn.org/jsguide/javascriptguide.html" target="_blank" rel="external">Google JavaScript 代码风格指南</a></li>
<li><a href="https://github.com/adamlu/javascript-style-guide" target="_blank" rel="external">Airbnb JavaScript 规范</a></li>
<li><a href="https://github.com/justjavac/12-javascript-quirks" target="_blank" rel="external">javascript 的 12 个怪癖</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="external">JavaScript 秘密花园</a></li>
<li><a href="http://icodeit.org/jsccp/" target="_blank" rel="external">JavaScript核心概念及实践</a> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</li>
<li><a href="http://justjavac.com/named-function-expressions-demystified.html" target="_blank" rel="external">命名函数表达式探秘</a>  (注:原文由<a href="http://www.cn-cuckoo.com" target="_blank" rel="external">为之漫笔</a>翻译，原始地址无法打开，所以此处地址为我博客上的备份)</li>
<li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns" target="_blank" rel="external">学用 JavaScript 设计模式</a> (开源中国)</li>
<li>Node.js<ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">Node入门</a></li>
<li><a href="https://github.com/nodejs-tw/nodejs-wiki-book" target="_blank" rel="external">Nodejs Wiki Book</a> (繁体中文)</li>
<li><a href="http://sofish.github.io/express-guide/" target="_blank" rel="external">express.js 指南</a></li>
</ul>
</li>
<li>backbone.js<ul>
<li><a href="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html" target="_blank" rel="external">backbone.js入门教程</a> (PDF)</li>
<li><a href="https://github.com/the5fire/backbonejs-learning-note" target="_blank" rel="external">Backbone.js入门教程第二版</a></li>
<li><a href="http://feliving.github.io/developing-backbone-applications" target="_blank" rel="external">Developing Backbone.js Applications(中文版)</a></li>
</ul>
</li>
<li>AngularJS<ul>
<li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md" target="_blank" rel="external">AngularJS最佳实践和风格指南</a></li>
<li><a href="https://github.com/basestyle/angularjs-cn" target="_blank" rel="external">AngularJS中译本</a> </li>
</ul>
</li>
<li><a href="http://www.360weboy.com/handbook/zepto/index.html" target="_blank" rel="external">zepto 简明中文手册</a> </li>
</ul>
<h3 id="PHP">PHP</h3><ul>
<li><a href="http://www.laruence.com/2010/06/21/1608.html" target="_blank" rel="external">PHP调试技术手册</a>(PDF)</li>
<li><a href="https://github.com/wulijun/php-the-right-way" target="_blank" rel="external">PHP之道</a></li>
<li><a href="https://github.com/justjavac/PHP-Best-Practices-zh_CN" target="_blank" rel="external">PHP 最佳实践</a></li>
<li><a href="https://github.com/reeze/tipi" target="_blank" rel="external">深入理解PHP内核</a></li>
<li><a href="http://www.walu.cc/phpbook/" target="_blank" rel="external">PHP扩展开发及内核应用</a></li>
<li><a href="http://codeigniter.org.cn/user_guide/index.html" target="_blank" rel="external">CodeIgniter 用户指南</a></li>
<li><a href="http://www.golaravel.com/docs/" target="_blank" rel="external">Laravel4 中文文档</a></li>
<li><a href="http://symfony-docs-chs.readthedocs.org/en/latest/" target="_blank" rel="external">Symfony2中文文档</a> (未译完)</li>
</ul>
<h3 id="iOS">iOS</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md" target="_blank" rel="external">iOS开发60分钟入门</a></li>
</ul>
<h3 id="Python">Python</h3><ul>
<li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/" target="_blank" rel="external">简明Python教程</a></li>
<li><a href="http://liam0205.me/Python-tutorial-zh_cn/" target="_blank" rel="external">Python入门教程</a> (<a href="http://liam0205.me/attachment/Python/The_Python_Tutorial_zh-cn.pdf" target="_blank" rel="external">PDF</a>)</li>
<li><a href="http://article.yeeyan.org/view/311527/287706" target="_blank" rel="external">Python的神奇方法指南</a></li>
<li><a href="https://django-document-cn.readthedocs.org/en/latest/" target="_blank" rel="external">Django 文档中文版</a></li>
<li><a href="https://github.com/brantyoung/zh-django-best-practices" target="_blank" rel="external">Django 最佳实践</a></li>
<li><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="external">The Django Book 中文版</a></li>
<li><a href="http://webpy.org/tutorial3.zh-cn" target="_blank" rel="external">web.py 0.3 新手指南</a></li>
<li><a href="http://webpy.org/cookbook/index.zh-cn" target="_blank" rel="external">Web.py Cookbook 简体中文版</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython/" target="_blank" rel="external">Dive Into Python 中文版</a></li>
<li><a href="http://bottlepy.org/docs/dev-cn/" target="_blank" rel="external">Bottle 文档中文版</a></li>
<li><a href="http://docs.torriacg.org/docs/flask/" target="_blank" rel="external">Flask 文档中文版</a></li>
</ul>
<h3 id="Ruby">Ruby</h3><ul>
<li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Ruby 风格指南</a></li>
<li><a href="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Rails 风格指南</a></li>
<li><a href="http://railstutorial-china.org/" target="_blank" rel="external">Ruby on Rails Tutorial 原书第 2 版</a> (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元)</li>
</ul>
<h3 id="Shell">Shell</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="external">Shell脚本编程30分钟入门</a></li>
</ul>
<h3 id="Go">Go</h3><ul>
<li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="external">Go编程基础</a></li>
<li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="external">Go入门指南</a></li>
<li><a href="http://mikespook.com/learning-go/" target="_blank" rel="external">学习Go语言</a> (<a href="http://xxiyy.qiniudn.com/%E5%AD%A6%E4%B9%A0%20Go%20%E8%AF%AD%E8%A8%80\(Golang\" target="_blank" rel="external">PDF</a>.pdf?download))</li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="external">Go Web 编程</a> (此书已经出版，希望开发者们去购买，支持作者的创作)</li>
<li><a href="https://github.com/astaxie/Go-in-Action" target="_blank" rel="external">Go实战开发</a> (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者<a href="https://me.alipay.com/astaxie" target="_blank" rel="external">捐赠</a>，以鼓励作者的继续创作)</li>
<li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="external">Network programming with Go 中文翻译版本</a></li>
</ul>
<h3 id="Groovy">Groovy</h3><ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-pg/" target="_blank" rel="external">实战 Groovy 系列</a></li>
</ul>
<h3 id="LISP">LISP</h3><ul>
<li><a href="http://acl.readthedocs.org/en/latest/" target="_blank" rel="external">ANSI Common Lisp 中文翻譯版</a></li>
</ul>
<h3 id="Haskell">Haskell</h3><ul>
<li><a href="http://rwh.readthedocs.org/en/latest/" target="_blank" rel="external">Real World Haskell 中文版</a></li>
</ul>
<h3 id="Scala">Scala</h3><ul>
<li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="external">Scala课堂</a> (Twitter的Scala中文教程)</li>
</ul>
<h3 id="读书笔记及其它">读书笔记及其它</h3><ul>
<li><a href="https://github.com/fool2fish/dragon-book-exercise-answers" target="_blank" rel="external">编译原理（紫龙书）中文第2版习题答案</a></li>
<li><a href="http://hawstein.com/posts/make-thiner-programming-pearls.html" target="_blank" rel="external">把《编程珠玑》读薄</a></li>
<li><a href="https://github.com/XiaolongJason/ReadingNote/blob/master/Effective%20C%2B%2B/Effective%20C%2B%2B.md" target="_blank" rel="external">Effective C++读书笔记</a></li>
<li><a href="https://github.com/qyuhen/book" target="_blank" rel="external">Golang 学习笔记、Python 学习笔记、C 学习笔记</a> (PDF)</li>
<li><a href="https://github.com/code4craft/jsoup-learning" target="_blank" rel="external">Jsoup 学习笔记</a></li>
<li><a href="https://github.com/lzjun567/note" target="_blank" rel="external">学习笔记: Vim、Python、memcached</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="免费的编程中文书籍索引">免费的编程中文书籍索引</h1><h3 id="转载地点"><a href="https://github.com/Yixiaohan/free-programming-books-zh_CN">转载地点</a></h3><hr>
<p>免费的编程中文书籍索引，欢迎投稿。</p>
<ul>
<li>国外程序员在 <a href="http://stackoverflow.com/a/1713/343194">stackoverflow</a> 推荐的程序员必读书籍，<a href="http://justjavac.com/other/2012/05/15/qualified-programmer-should-read-what-books.html" title="一个合格的程序员应该读过哪些书">中文版</a>。</li>
<li><a href="http://stackoverflow.com/q/38210/343194">stackoverflow</a> 上的程序员应该阅读的非编程类书籍有哪些？ <a href="what-non-programming-books-should-programmers-read.md">中文版</a></li>
<li><a href="https://github.com/vhf/free-programming-books">github</a> 上的一个流行的编程书籍索引  <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-ch.md">中文版</a></li>
</ul>]]>
    
    </summary>
    
      <category term="资料分享" scheme="http://ioschen.com/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ruby]]></title>
    <link href="http://ioschen.com/2014/03/30/ruby/"/>
    <id>http://ioschen.com/2014/03/30/ruby/</id>
    <published>2014-03-30T12:13:11.000Z</published>
    <updated>2014-03-30T12:13:51.000Z</updated>
    <content type="html"><![CDATA[<p>ruby</p>
<p>当年应该学兽医</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>ruby</p>
<p>当年应该学兽医</p>]]>
    
    </summary>
    
      <category term="ruby" scheme="http://ioschen.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[变量]]></title>
    <link href="http://ioschen.com/2014/03/26/variable/"/>
    <id>http://ioschen.com/2014/03/26/variable/</id>
    <published>2014-03-25T18:11:27.000Z</published>
    <updated>2014-04-06T11:12:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="引子">引子</h1><p>基本程序构造单元——变量。</p>
<p>Common Lisp支持两种类型的变量:词法（lexical）变量和动态（dynamic）变量。（动态变量有时也叫做特殊变量 special variable）这两中变量对应类型分别对应其他语言的局部变量和全局变量，<strong>不过，只能说是大致相似</strong>一方面某些语言中的局部变量更像是Common Lisp的动态变量。另一方面，某些语言中的局部变量虽然是词法作用域的，但并没有提供由Common Lisp的词法变量所提供的所有功能，尤其是并非所有语言都提供了支持闭包的词法作用域变量。</p>
<p><del>许多含有变量表达式都可以同时使用词法变量和动态变量</del></p>
<h1 id="变量的基础知识">变量的基础知识</h1><p>和其他语言一样，Common Lisp中的变量是一些可以保存值得具名位置，但是在Common Lisp中，变量并非像在Java和c++等语言中那样带有确定的类型，也就是不需要为每一个变量声明其可以保存对象的类型，相反，一个变量可以保存任何类型的值，并且这些值带有可用于运行期类检查的类型信息。因此 Common Lisp是动态类型的——类型错误会被动态的检测到。</p>
<p>比如，给+函数传递个字符串，Common Lisp就会报类型错误。而另一方面，Common Lisp是一种强类型语言，因为所有的类型错误都将被检测到——无法将一个对象作为其不属于的类型的实列来对待。</p>
<p>至少从概念上来说，Common Lisp中所有值都是对象的引用，因此，将一个变量赋予新值就会改变变量所指向的对象，而对之前被引用的对象没有影响。（如果一个变量保存了对一个可变对象的引用，那么久可以用该引用来修改此对象，而这种改动将应用于任何带有相同对象引用的代码。）</p>
<p>而另一种已经用到的引入新变量的方式是定义函数形参。在用DEFUN来定义函数时，形参列表定义了当函数被调用时用来保存实参的变量。列如，下列函数定义了三个变量x y和z，用来保存其实参:</p>
<p><code>(defun foo (x y z) (+ x y z))</code></p>
<p>每当函数被调用时，Lisp将会创建新的绑定来保存由函数调用者所传递的实参。绑定代表了变量在运行期的存在。单个变量就是可以在程序源代码中所指出的那种东西，在程序运行过程中可以有多个不同的绑定，单个变量甚至可以同时带有多重绑定。例如，一个递归函数的形参会在每一次函数调用中被重新绑定。</p>
<p>和所有Common Lisp变量一样，函数形参也可以保存对象引用。因此，可以在函数体内为一个函数形参赋予新值，而这并不会影响到同样函数的另一个调用所创建的绑定。但如果改变了传递给函数的可变对象，则这些改动将会被调用者看到，因为无论调用者还是被调用者都在引用同一个对象。</p>
<p>引入新变量的另一种方式是使用LET特殊操作符。下面就是一个LET形式的结构:</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">let</span></span> <span class="list">(<span class="keyword">variable*</span>)</span>
    body-form*)</span>
</code></pre><p>其中每一个variable都是一耳光变量初始化形式，每一个初始化形式要么是一个含有变量名和初值形式的列表，要么就是一个简单的变量名——作为将变量初始化到NIL得简略写法。列如，下面的LET形式会将三个变量x y z绑定到初始值10 20 和NIL上:</p>
<p><code>(let ((x 10) (y 20) z)
    ...)</code></p>
<p>当这个LET形式被求值时，所有的初始值形式都将首先被求值，然后创建出新的绑定，并在形式体被执行之前这些绑定将初始化到适当的初始值上。在LET形式体中，变量名将引用新创建的绑定。在LET形式体执行结束后，这些变量名将重新引用在执行LET之前它们所引用的内容，如果有的话。</p>
<p>形式体中最后一个表达式的值将作为LET表达式的值返回，和函数形参一眼，由LET所引入的变量将在每次进入LET时被重新绑定。</p>
<p>函数形参和LET变量的作用域（变量名可用来引用该绑定的程序区域）被限定在引入该变量的形式之内，该形式即函数定义或LET，被称为绑定形式。很快将看到，词法变量和动态变量使用两种略有不同的作用域机制，但两者的作用域都被界定在绑定形式之内。</p>
<p>如果嵌套了引入同名变量的绑定形式，那么最内层的变量绑定将<em>覆盖</em>外层的绑定。例如，在调用下面的函数时，将创建一个形参x的绑定来保存函数的实参。第一个LET创建了一个带有初始值2的新绑定，而内层的LET创建了另外一个绑定，其初始值为3。右边的竖线标记出了每一个绑定的作用域。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;;;;第二杭的x为实参，第四行为<span class="number">2</span> 第六行为<span class="number">3</span></span><br><span class="line"><span class="comment">(defun foo (x)</span></span><br><span class="line">	<span class="comment">(format t "Parameter: ~a~%" x)</span></span><br><span class="line">	<span class="comment">(let ((x 2)</span>)</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span></span><br><span class="line">		<span class="comment">(let ((x 3)</span>)</span><br><span class="line">			<span class="comment">(format t "Inner LET: ~a~%" x)</span>))</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span>)</span><br><span class="line">	<span class="comment">(foramt t "Parameter: ~a~%" x)</span>)</span><br></pre></td></tr></table></figure>
<p>每一次对x的引用都将指向最小封闭作用域中的绑定。一旦程序控制离开了一个绑定形式的作用域，其最近的闭合作用域中的绑定就被解除覆盖，并且x将转而指向它。因此，调用foo将得到这样的输出:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (foo <span class="number">1</span>)</span><br><span class="line">Parameter: <span class="number">1</span></span><br><span class="line">Outer LET: <span class="number">2</span></span><br><span class="line">Inner LET: <span class="number">3</span></span><br><span class="line">Outer LET: <span class="number">1</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>后面学习其他可以作为绑定形式使用的程序构造，其特点在于所引入的新变量只能用于该构造。</p>
<p><del>DOTIMES循环和LET*需要后面学习</del></p>
<h1 id="词法变量和闭包">词法变量和闭包</h1><h1 id="动态变量">动态变量</h1><h1 id="常量">常量</h1><h1 id="赋值">赋值</h1><h1 id="广义赋值">广义赋值</h1><h1 id="其他修改位置的方式">其他修改位置的方式</h1><a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="引子">引子</h1><p>基本程序构造单元——变量。</p>
<p>Common Lisp支持两种类型的变量:词法（lexical）变量和动态（dynamic）变量。（动态变量有时也叫做特殊变量 special variable）这两中变量对应类型分别对应其他语言的局部变量和全局变量，<strong>不过，只能说是大致相似</strong>一方面某些语言中的局部变量更像是Common Lisp的动态变量。另一方面，某些语言中的局部变量虽然是词法作用域的，但并没有提供由Common Lisp的词法变量所提供的所有功能，尤其是并非所有语言都提供了支持闭包的词法作用域变量。</p>
<p><del>许多含有变量表达式都可以同时使用词法变量和动态变量</del></p>
<h1 id="变量的基础知识">变量的基础知识</h1><p>和其他语言一样，Common Lisp中的变量是一些可以保存值得具名位置，但是在Common Lisp中，变量并非像在Java和c++等语言中那样带有确定的类型，也就是不需要为每一个变量声明其可以保存对象的类型，相反，一个变量可以保存任何类型的值，并且这些值带有可用于运行期类检查的类型信息。因此 Common Lisp是动态类型的——类型错误会被动态的检测到。</p>
<p>比如，给+函数传递个字符串，Common Lisp就会报类型错误。而另一方面，Common Lisp是一种强类型语言，因为所有的类型错误都将被检测到——无法将一个对象作为其不属于的类型的实列来对待。</p>
<p>至少从概念上来说，Common Lisp中所有值都是对象的引用，因此，将一个变量赋予新值就会改变变量所指向的对象，而对之前被引用的对象没有影响。（如果一个变量保存了对一个可变对象的引用，那么久可以用该引用来修改此对象，而这种改动将应用于任何带有相同对象引用的代码。）</p>
<p>而另一种已经用到的引入新变量的方式是定义函数形参。在用DEFUN来定义函数时，形参列表定义了当函数被调用时用来保存实参的变量。列如，下列函数定义了三个变量x y和z，用来保存其实参:</p>
<p><code>(defun foo (x y z) (+ x y z))</code></p>
<p>每当函数被调用时，Lisp将会创建新的绑定来保存由函数调用者所传递的实参。绑定代表了变量在运行期的存在。单个变量就是可以在程序源代码中所指出的那种东西，在程序运行过程中可以有多个不同的绑定，单个变量甚至可以同时带有多重绑定。例如，一个递归函数的形参会在每一次函数调用中被重新绑定。</p>
<p>和所有Common Lisp变量一样，函数形参也可以保存对象引用。因此，可以在函数体内为一个函数形参赋予新值，而这并不会影响到同样函数的另一个调用所创建的绑定。但如果改变了传递给函数的可变对象，则这些改动将会被调用者看到，因为无论调用者还是被调用者都在引用同一个对象。</p>
<p>引入新变量的另一种方式是使用LET特殊操作符。下面就是一个LET形式的结构:</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">let</span></span> <span class="list">(<span class="keyword">variable*</span>)</span>
    body-form*)</span>
</code></pre><p>其中每一个variable都是一耳光变量初始化形式，每一个初始化形式要么是一个含有变量名和初值形式的列表，要么就是一个简单的变量名——作为将变量初始化到NIL得简略写法。列如，下面的LET形式会将三个变量x y z绑定到初始值10 20 和NIL上:</p>
<p><code>(let ((x 10) (y 20) z)
    ...)</code></p>
<p>当这个LET形式被求值时，所有的初始值形式都将首先被求值，然后创建出新的绑定，并在形式体被执行之前这些绑定将初始化到适当的初始值上。在LET形式体中，变量名将引用新创建的绑定。在LET形式体执行结束后，这些变量名将重新引用在执行LET之前它们所引用的内容，如果有的话。</p>
<p>形式体中最后一个表达式的值将作为LET表达式的值返回，和函数形参一眼，由LET所引入的变量将在每次进入LET时被重新绑定。</p>
<p>函数形参和LET变量的作用域（变量名可用来引用该绑定的程序区域）被限定在引入该变量的形式之内，该形式即函数定义或LET，被称为绑定形式。很快将看到，词法变量和动态变量使用两种略有不同的作用域机制，但两者的作用域都被界定在绑定形式之内。</p>
<p>如果嵌套了引入同名变量的绑定形式，那么最内层的变量绑定将<em>覆盖</em>外层的绑定。例如，在调用下面的函数时，将创建一个形参x的绑定来保存函数的实参。第一个LET创建了一个带有初始值2的新绑定，而内层的LET创建了另外一个绑定，其初始值为3。右边的竖线标记出了每一个绑定的作用域。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;;;;第二杭的x为实参，第四行为<span class="number">2</span> 第六行为<span class="number">3</span></span><br><span class="line"><span class="comment">(defun foo (x)</span></span><br><span class="line">	<span class="comment">(format t "Parameter: ~a~%" x)</span></span><br><span class="line">	<span class="comment">(let ((x 2)</span>)</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span></span><br><span class="line">		<span class="comment">(let ((x 3)</span>)</span><br><span class="line">			<span class="comment">(format t "Inner LET: ~a~%" x)</span>))</span><br><span class="line">		<span class="comment">(format t "Outer LET: ~a~%" x)</span>)</span><br><span class="line">	<span class="comment">(foramt t "Parameter: ~a~%" x)</span>)</span><br></pre></td></tr></table></figure>
<p>每一次对x的引用都将指向最小封闭作用域中的绑定。一旦程序控制离开了一个绑定形式的作用域，其最近的闭合作用域中的绑定就被解除覆盖，并且x将转而指向它。因此，调用foo将得到这样的输出:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (foo <span class="number">1</span>)</span><br><span class="line">Parameter: <span class="number">1</span></span><br><span class="line">Outer LET: <span class="number">2</span></span><br><span class="line">Inner LET: <span class="number">3</span></span><br><span class="line">Outer LET: <span class="number">1</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>后面学习其他可以作为绑定形式使用的程序构造，其特点在于所引入的新变量只能用于该构造。</p>
<p><del>DOTIMES循环和LET*需要后面学习</del></p>
<h1 id="词法变量和闭包">词法变量和闭包</h1><h1 id="动态变量">动态变量</h1><h1 id="常量">常量</h1><h1 id="赋值">赋值</h1><h1 id="广义赋值">广义赋值</h1><h1 id="其他修改位置的方式">其他修改位置的方式</h1>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数]]></title>
    <link href="http://ioschen.com/2014/03/25/function/"/>
    <id>http://ioschen.com/2014/03/25/function/</id>
    <published>2014-03-25T12:57:35.000Z</published>
    <updated>2014-03-27T08:02:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="书接上文">书接上文</h1><p>有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 </p>
<p>（宏是用来生成代码，不是用来完成实际操作的）</p>
<h1 id="定义新函数">定义新函数</h1><h2 id="定义方式">定义方式</h2><p>函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">name</span> （<span class="type">parameter</span>*）</span><br><span class="line">	<span class="string">"Optional documentating string."</span></span><br><span class="line">	body-<span class="keyword">form</span>）</span><br></pre></td></tr></table></figure>
<h2 id="命名方式">命名方式</h2><p>任何符号都可以用作函数名。通常函数名包含字典字符和连字符。但是在特定的命名约定里，其它字符也允许使用。列如，将值得一种类型转换成另一种函数有时会在名字中使用-&gt;</p>
<p>一个将字符串转换成微件（widget）的函数可能叫做string-&gt;widget  最重要的一个命名约定是用连字符而不是下划线或者内部大小写</p>
<p>因此是a-b而不是a_b或者aB</p>
<h2 id="定义参数">定义参数</h2><p>一个函数的形参列表定义了一些变量，将用来保存函数在调用时所传递的实参。如果函数是不带有实参，则该列表就是空得，写成（）。不同种类的形参分别负责处理必要的，可选的，多重的以及关键字实参。</p>
<h2 id="参数说明">参数说明</h2><p>如果一个字符串紧跟在形参列表之后，那么它应该就是一个用来描述函数用途的文档字符串。当定义函数时，该文档字符串将被关联到函数名上，并且以后可以通过DOCUMENTATION函数来获取</p>
<h2 id="最后总结">最后总结</h2><p>一个DEFUN的主体可由任意数量的lisp表达式所构成，他们将在函数被调用时依次求值，而最后一个表达式的值将被作为整个函数的值返回，另外RETURN-FROM特殊操作符可用于从函数的任何位置立即返回。</p>
<p>一开始学习的时候写的hello-world，形式如下</p>
<p><code>（defun hello-world () (format t &quot;hello, world&quot;)）</code></p>
<p>分析如下</p>
<ol>
<li>名字是hello-world</li>
<li>形式列表为空，因此不接受任何参数</li>
<li>没有文档字符串</li>
<li>函数体由一个表达式所构成（format t “hello，world”）</li>
</ol>
<p>另一个列子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> verbose-sum <span class="list">(<span class="keyword">x</span> y)</span></span><br><span class="line">      <span class="string">"Sum any two numbers after printing a message."</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"Summing ~d and ~d.~%"</span> x y)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数称为verbose-sum 接受两个实参分别为形参x和y一一对应并且带有一个文档字符串，以及一个由两个表达式所组成的主体。有“+”调用所返回的值将成为verbose-sum的返回值。</p>
<h1 id="函数形参列表">函数形参列表</h1><p>函数名和文档字符串差不多了，现在了解形参列表</p>
<p>形参列表的基本用途是为了声明一些变量用来接收传递给函数的实参，当形参列表是一个由变量名所组成的简单列表时，如同在verbose-sum里那样，这些形参叫必要形参。当函数调用时候，必须为每个必要形参都提供一个实参。每一个形参被绑定到对应的实参上。</p>
<p>但是，形参列表也给了更灵活的方法将函数调用实参映射到函数形参。除了必要形参以外，一个函数还可以有可选形参，或者也可以用单一形参绑定到含有任意多个额外参数的列表上。最后，参数还可以通过关键字而不是位置来映射到形参上，这样Commom lisp的形参列表对于集中常见的编码问题提供了一种便利的解决方案。</p>
<h1 id="可选形参">可选形参</h1><h2 id="定义">定义</h2><p>为了定义一个可选形参的函数，在必要形参的名字后放置符号&amp;optional后接可选形参的名字</p>
<h2 id="列子">列子</h2><p><code>（defun foo （a b &amp;optional c d）(list a b c d)）</code></p>
<p>当函数被调用时，实参被首先绑定到必要形参上，在所有必要形参都被赋值以后，如果还有任何实参剩余，它们的值被赋给可选形参。如果实参在所有可选形参被赋值前用完了，那么其余的可选形参将自动绑定到NIL上。这样，列子定义的函数会给出下面的结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 NIL NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3 4） -&gt; （1 2 3 4）</li>
</ul>
<p>lisp任然可以确保适当的数量的实参被传递给函数——在本列中是2-4个。而如果函数用太少或太多的参数来调用的话，会报错。</p>
<p>当然，我们经常想要一个不同于NIL的默认值，这时可以通过将新参名替换成一个含有名字跟一个表达式的列表来制定该默认值。只有在调用者没有传递足够的实参来为可选形参提供值得时候，这个表达式才会被求值，通常情况只是简单的提供一个值作为表达式：</p>
<p><code>(defun foo (a &amp;optional（b 10)) (list  a b))</code></p>
<p>上述函数要求将一个实参绑定到形参a上，当存在第二个实参时，第二个形参b将使用其值，否则使用10</p>
<ul>
<li>（foo 1 2） -&gt; （1 2）</li>
<li>（foo 1）-&gt; （1 10）</li>
</ul>
<p>不过，有时可能需要更灵活选择默认值，比如可能想要基于其他形参来计算默认值，默认值表达式可以引用早先出现在形参列表中的形参。如果要编写一个返回矩形的某种表示的函数，并且想要使它可以特别的产生正方形，那么可以使用一个像这样的形参列表。</p>
<p><code>(defun make-rectangle (width &amp;optional (height width)) ...)</code><br>除非明确知道否则这将导致height形参带有和width形参相同的值。</p>
<p>有时，有必要去了解一个可选形参的值究竟是被调用者明确指定还是使用了默认值。除了代码检查是否默认值（假如调用者碰巧显式传递了默认值，那么这样做终归是无效的）以外，还可以通过在形参标示符的默认值表达式之后添加另一个变量名来做到这点。该变量将在调用者实际为该形参提供了一个实参是被绑定到真值，否则为NIL 通常约定，这种变量的名字与对应的真实形参相同，但是带有一个 -supplied-p后缀<br>列如:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">a</span> b <span class="keyword">&amp;optional</span> <span class="list">(<span class="keyword">c</span> <span class="number">3</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">lisp</span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这将给出类似下面结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 T）</li>
<li>（foo 1 2 4） -&gt; （1 2 4 T）</li>
</ul>
<h1 id="剩余形参">剩余形参</h1><p>可选形参仅适用于一些较为分散并且不能确定调用者是否会提供值得形参。但某些函数需要接收可变数量的实参，比如前面已经出现过的内置函数。FORMAT有两个必要实参，即流合控制串。单在这两个之后，它还需要一组可变数量的实参，这取决于控制串需要插入多少个值。</p>
<p>+函数也接受可变数量的实参——没有特别的理由限制它只能在两个数之间相加，它可以对任意数量的值做加法运算（它甚至可以没有实参，此时返回0——加法的底数）。下面这些都是这两个函数的合法调用:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, ~a"</span> name)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"x: ~d y: ~d"</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>很明显，也可以通过简单给它一些可选形参来写出接受可变数量实参的函数，但这样将会非常麻烦，光是写形参列表就已经够麻烦了，何况还要在函数体中处理所有这些形参。为了做好这件事，还不得不使用一个合法函数调用所能够传递的那么多的可选形参。这一具体数量与具体实现相关，但可以保证至少有50个。在当前所有实现中，它的最大值范围从4096到536870911</p>
<p>相反，Lisp允许在符合&amp;rest之后<em>包括</em>一揽子形参。如果函数带有&amp;rest形参，那么任何满足了必要可选形参之后其余所有实参就将被收集到一个列表里成为该&amp;rest形参的值。这样，FORMAT和+的形参列表可能看起来会是这样:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> format <span class="list">(<span class="keyword">stream</span> string <span class="keyword">&amp;rest</span> values)</span> ...)</span></span><br><span class="line"><span class="list">(<span class="keyword">defun</span> + <span class="list">(<span class="keyword">&amp;rest</span> nmbers)</span> ...)</span></span><br></pre></td></tr></table></figure>
<h1 id="关键字形参">关键字形参</h1><p>如果我想给第四个形参提供值，其余不给，怎么办呢，关键字形参就起作用了。（这个没有描述清楚）</p>
<p>如果用可选形参的话。如果给第四个可选形参传递一个显式值，就会导致前面三个可选形参对于调用者来说变成了必要形参。</p>
<p>定义：在任何必要的&amp;optional和&amp;rest形参之后，可以加上符号&amp;key以及任意数量的关键字形参标示符，后者的格式类似于可选形参标示符。下面就是一个只有关键字形参的函数:</p>
<p><code>(defun foo (&amp;key a b c) (list a b c))</code></p>
<p>当调用这个函数时，每一个关键字形参将绑定到紧跟在同名键字后面的那个值上，如前面所说，关键字以冒号开始的名字，并且他们被自动定义为自求值常量。</p>
<p>如果一个给定的关键字没有出现在实参列表中，那么对应的形参将被赋予其默认值，如同可选形参那样。因为关键字实参带有标签，所以他们在必要实参之后可按任意顺序进行传递。例如foo可以用下列形式调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">foo</span>)</span>  -&gt; <span class="list">(<span class="keyword">NIL</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:c</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> NIL <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:b</span> <span class="number">2</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span> <span class="keyword">:b</span> <span class="number">2</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>如同可选形参那样，关键字形参也可以提供一个默认值形式以及一个supplied-p变量名。</p>
<p>在关键字形参和可选形参中，这个默认值形式都可以引用那些早先出现在形参列表中的形参。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="keyword">a</span> <span class="number">0</span>)</span> <span class="list">(<span class="keyword">b</span> <span class="number">0</span> b-supplied-p)</span> <span class="list">(<span class="keyword">c</span> <span class="list">(<span class="keyword">+</span> a b)</span>)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">list</span> a b c b-supplied-p)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">2</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt; <span class="list">(<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br></pre></td></tr></table></figure>
<p>同样，出于某种原因想让调用者用来指定形参的关键字不同于实际形参名，那么可以将形参名替换成一个列表，令其含有调用函数时使用的关键字以及用作形参的名字，比如说下面这个foo的定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="list">(<span class="attribute">:apple</span> a)</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:box</span> b)</span> <span class="number">0</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:charlie</span> c)</span> <span class="number">0</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">list</span></span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以让调用者这样调用它:</p>
<p><code>(foo :apple 10 :box 20 :charlie 30)  -&gt; (10 20 30 T)</code></p>
<p>这种风格在想要完全将函数的公共API与其内部细节相隔离时特别有用，通常是因为想要在内部使用段变量名，而不是API中的描述性关键字。不过该特性不常被用到。</p>
<h1 id="混合不同的形参类型">混合不同的形参类型</h1><p>四个混合使用，多种混合使用时候：必须以这样的顺序声明:首先是<em>必要形参</em> 其次是<em>可选形参</em> 再次是<em>剩余形参</em> 最后才是<em>关键字形参</em>。但在使用多种类型形参的函数中，一般情况是将必要和另外一种类型形参组合使用，或者可能是组合&amp;optional形参和&amp;rest形参。其它两种组合方式，无论是&amp;optional形参还是&amp;rest形参，当与&amp;key形参组合使用时，都可能导致某种奇怪的行为。</p>
<p>将&amp;optional形参和&amp;key形参组合使用时将产生非常奇怪的结果，因此也许应该避免将他们一起使用，问题出现在如果调用者没有为所有可选形参提供值时，那么没有得到值得可选形参将吃掉原本用于关键字形参的关键字和值。列如，下面这个函数很不明智地混合了&amp;optional形参和&amp;key形参:</p>
<p><code>（defun foo （x &amp;optional y &amp;key z）（list x y z））</code></p>
<p>如果像这样调用的话，就没问题:</p>
<p><code>(foo 1) -&gt; (1 nil nil)</code></p>
<p>但是这样的话将报错:</p>
<p><code>(foo 1 :z 3) -&gt; ERROR</code></p>
<p>这是因为关键字:z被作为一个值填入到可选的y形参中了，只留下了参数3被处理。在这里，Lisp期待一个成对的关键字/值，或者什么也没有，否则就会报错，也许更坏的是，如果该函数带有两个&amp;optional形参，上面最后一个调用将导致值:z和3分别被绑定到两个&amp;optional形参上，而&amp;key形参z将得到默认值NIL 而不声明缺失了东西。</p>
<p>一般而言，如果正在编写一个同时使用&amp;optional形参和&amp;key形参的函数，可能就应该将它变成全部使用&amp;key形参的形式——他们更灵活，并且总会可以在不破坏该函数的已有调用的情况下添加新的关键字形参。也可以移除关键字形参，只要没人在使用他们，一般而言，使用关键字形参就uhui使代码相对易于维护和拓展——如果需要为函数添加一些需要用到新参数的新行为，就可以直接添加关键字形参，而无需修改甚至重新编译任何调用该函数的已有代码。</p>
<p>虽然可以安全的组合使用&amp;rest形参和&amp;key形参    ，但其行为初看起来可能会有一点奇怪。正常的来讲，无论是&amp;rest还是&amp;key出现在形参列表中，都将导致所有出现在必要形参和&amp;optional形参之后的那些值被特别处理——要么作为&amp;rest和&amp;key同时出现在形参列表中，那么两件事都会发生——所有剩余的值，包括关键字本身，都将被收集到一个列表里，然后绑定到&amp;rest形参上，而适当的值，也会同时被绑定到&amp;key形参上，因此给定下列函数:</p>
<p><code>(defun foo (&amp;rest rest &amp;key a b c) (list rest a b c))</code></p>
<p>将会得到如下结果:</p>
<p><code>(foo :a 1 :b 2 :c 3) -&gt; ((:A 1 :B 2 :C 3) 1 2 3)</code></p>
<h1 id="函数返回值">函数返回值</h1><p>目前所有函数都使用了默认的返回值行为，既<em>最后一个表达式的值</em>被作为整个函数的<strong>返回值</strong>。这是从函数中返回值得最常见方式。</p>
<p>有些时候，尤其是想要从嵌套的控制结构中脱身时，如果有办法从函数中间返回，那就是非常便利的。在这种情况下，你可以使用RETURN-FROM特殊操作符，它能够立即以任何职从函数中间返回。<del>RETURN-FROM事实上不只用于函数，还可以用来从一个由BLOCK特殊操作符所定义的代码块中返回。</del>不过DEFUN会自动将其整个函数体包装在一个与其函数同名的代码块中，因此，对一个带有当前函数名和想要返回的值的RETURN-FROM是一个特殊操作符，其第一个“参数”是它想要返回的代码块名。该名字不被求值，因此无需引用。</p>
<p>下面这个函数使用了嵌套循环来发现第一个数对——每个都小于10，并且其成绩大于函数的参数，它使用RETURN-FROM在发现后立即返回该数对;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">n</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">i</span> <span class="number">10</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">j</span> <span class="number">10</span>)</span></span><br><span class="line">			<span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> i j)</span> n)</span></span><br><span class="line">				<span class="list">(<span class="keyword">return-from</span> foo <span class="list">(<span class="keyword"><span class="built_in">list</span></span> i j)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>必须承认的是，不得不指定正在返回的函数名多少会有些不便——比如改变了函数的名字，就需要同时改变RETURN-FROM中所使用的名字，但是在事实上，显式的RETURN-FROM调用在Lisp中出现的频率远小于return语句在源自C的语言里出现的频率，因为所有的Lisp表达式，包括诸如循环和条件语句这样的控制结构，都会求值得到一个值，因此在实践中这不是什么问题。</p>
<h1 id="作为数据的函数————高阶函数">作为数据的函数————高阶函数</h1><p>使用函数主要方式—-<strong>通过名字来调用</strong> 但有时将函数作为数据看待也是很有用的。列如，可以将一个函数作为参数传递给另一个函数，从而能写出一个通用的排序函数，允许调用者提供一个比较任意两元素的函数，这样通用的底层算法就可以跟许多不同的比较函数配合使用了。</p>
<p>类似的，回调函数（callback）和钩子（hook）也需要能够保存代码引用便于以后运行。由于函数已经是一种对代码比特进行抽象的标准方式，因此允许把函数视为数据也是合理的。</p>
<p>在Lisp中，函数只是另一种类型的对象，在用DEFUN定义一个函数时，实际上做了两件事：创建一个新的函数对象以及赋予其一个名字，前面说过，也可以使用LAMBDA表达式来创建一个函数而无需为其指定一个名字。一个函数对象的实际表示，无论是有名的还是匿名的，都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。只需要知道如何保持它们以及需要时如何调用它们。</p>
<p>特殊操作符FUNCTION提供了用来获取一个函数对象的方法，它接受单一实参并返回与该参数同名的函数。这个名字是不被引用的。因此如果一个函数foo的定义如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? (defun foo (x) (* x x))</span><br><span class="line">FOO</span><br><span class="line">就可以得到如下的函数对象</span><br><span class="line">? (<span class="function"><span class="keyword">function</span></span> foo)</span><br><span class="line">#&lt;Compiled-<span class="function"><span class="keyword">function</span></span> FOO #x302000F99E4F&gt;</span><br></pre></td></tr></table></figure>
<p>事实上前面已经用过FUNCTION了，但是它以伪装的形式出现的，前面用到的#’语法就是FUNCTION的语法糖，正如’是QUOTE的语法糖一样。因此也可以像这样得到foo的函数对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="preprocessor">#'foo</span></span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;Compiled-function FOO #x302000ECB11F&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一旦得到了函数对象，就只剩下一件事可做了——调用它。Common Lisp提供了两个函数用来调用函数: FUNCALL和APPLY 它们的区别仅在于如何获取传递给函数的实参。</p>
<p>FUNCALL用于在编写代码时确切知道传递给函数多少实参时，FUNCALL的第一个实参是被调用的函数对象，其余的实参被传递到该函数中。因此，下面两个表达式是等价的:</p>
<p><code>（foo 1 2 3）= （funcall #&#39;foo 1 2 3）</code></p>
<p>不过，用FUNCALL来调用一个写代码时名字已知的函数毫无意义。事实上，前面的两个表达式很可能被编译成相同的机器指令。</p>
<p>下面这个函数演示了FUNCALL的另一个更有建设性的用法。它接受一个函数对象作为实参，并使用实参函数在min和max之间以step为步长的返回值绘制一个简单的ASCII式柱状图:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L-USER&gt; <span class="list">(<span class="keyword">defun</span> plot <span class="list">(<span class="keyword">fn</span> min max step)</span></span><br><span class="line">	   <span class="list">(<span class="keyword">loop</span> for i from min to max by step do</span><br><span class="line">		<span class="list">(<span class="keyword">loop</span> repeat <span class="list">(<span class="keyword">funcall</span> fn i)</span> do <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"*"</span>)</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~%"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>FUNCALL表达式在每个i值上计算函数的值，内层LOOP循环使用计算得到的值来决定向标准输出打印多少星号。</p>
<p>请注意，不需要使用FUNCTION或#‘来得到fn的函数值，因为它是作为函数对象的变量的值，所以你需要它解释成一个变量。可以用任何接受单一数值实参的函数来调用plot，列如内置的函数EXP，它返回以e为底以其实参为指数的值。</p>
<pre><code>(plot <span class="comment">#'exp 0 4 1/2)</span>
<span class="keyword">*</span>
<span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
NIL
</code></pre><p>然而，当实参列表只在运行期已知时，FUNCALL的表现不佳，列如，为了再次调用plot函数，假设你已有一个列表，其包括一个函数对象，一个最小值和一个最大值以及一个步长。换句话说，这个列表包含了你想要作为实参传给plot的所有值，假设这个列表保存在变量plot-data中，可以像这样用列表中的值来调用plot:</p>
<p><code>(plot (first plot-data) (second plot-data) (third plot-data) (fourth plot-data))</code></p>
<p>这样固然可以，但仅仅为了将实参传给plot而显式地将其解开，看起来相当不爽。</p>
<p>这样就需要APPLY的原因，和FUNCTION一样，APPLY的第一个参数是一个函数对象，但在这个函数对象之后，它期待一个列表而非单独的实参。它将函数应用在列表中的值上，这就使你可以写出下面的替代版本:</p>
<p><code>(apply #&#39;plot plot-data)</code></p>
<p>更方便的是，APPLY还接受“孤立”（loose）的实参，只要最后一个参数是个列表，因此，加入plot-data只含有最小，最大和步长值，那么你仍然可以像这样来使用APPLY在该范围上绘制EXP函数:</p>
<p><code>(apply #&#39;plot exp plot-data)</code></p>
<p>APPLY并不关心所用的函数是否接受&amp;optional &amp;rest 或&amp;key实参——由任何孤立实参和最后的列表所组合而成的实参列表必定是一个合法的实参列表，其对于该函数来说带有足够的实参用于所有必要形参和适当的关键字形参。</p>
<h1 id="匿名函数">匿名函数</h1><p>一开始编写或只是使用那些可以接受其它函数作为实参的函数，你就必然发现，有时不得不去定义和命名一个仅使用一次的函数，尤其是你可能从不用名字来调用它时，这会让人相当恼火。</p>
<p>觉得没必要用DEFUN来定义一个新函数时，可以使用一个LAMBDA表达式创建匿名的函数。前面讨论过，一个LAMBDA表达式形式如下:</p>
<p><code>(lambda (parameters) body)</code></p>
<p>可以将LAMBDA表达式视为一种特殊类型的函数名，其名字本身直接描述函数的用途，这就解释了为什么可以使用一个带有#’的LAMBDA表达式来代替一个函数名。</p>
<p><code>(funcall #&#39;(lambda (x y) (+ x y)) 2 3)  -&gt;5</code></p>
<p>甚至可以在一个函数调用表达式中将LAMBDA表达式用作函数名，由此一来，我们可以在需要时以更简洁方式来书写前面的FUNCALL表达式如下:</p>
<p><code>((lambda (x y) (+ x y)) 2 3) -&gt; 5</code></p>
<p>但是几乎没人这样做，它唯一的用途是来强调将LAMBDA表达式用在任何一个正常函数名可以出现的场合是合法的。</p>
<p>在需要传递一个作为实参的函数给另一个函数，并且需要传递的这个函数简单到可以内联表达时，匿名函数特别有用，列如，假设想要绘制函数2x 你可以定义下面的函数:</p>
<p><code>defun double (x) (* 2 x))</code></p>
<p>并随后将其传给plot</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'double 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">Nil</span><br></pre></td></tr></table></figure>
<p>但如果写成这样就会更简单和清晰:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'(lambda (x) (* 2 x)) 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>LAMBDA表达式的另一项重要用途是制作闭包（closure），即捕捉了其创建时环境信息的函数。前面也使用了一点闭包，但是要想深入了解闭包的工作原理和用途，更多地还是要从变量而非函数的角度去考察，下面在研究吧。</p>
<p><del>也可以不带前缀#’来使用一个LAMBDA表达式作为FUNCALL的参数</del></p>
<p><del>关于这个。。。</del></p>
<hr>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="书接上文">书接上文</h1><p>有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 </p>
<p>（宏是用来生成代码，不是用来完成实际操作的）</p>
<h1 id="定义新函数">定义新函数</h1><h2 id="定义方式">定义方式</h2><p>函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">name</span> （<span class="type">parameter</span>*）</span><br><span class="line">	<span class="string">"Optional documentating string."</span></span><br><span class="line">	body-<span class="keyword">form</span>）</span><br></pre></td></tr></table></figure>
<h2 id="命名方式">命名方式</h2><p>任何符号都可以用作函数名。通常函数名包含字典字符和连字符。但是在特定的命名约定里，其它字符也允许使用。列如，将值得一种类型转换成另一种函数有时会在名字中使用-&gt;</p>
<p>一个将字符串转换成微件（widget）的函数可能叫做string-&gt;widget  最重要的一个命名约定是用连字符而不是下划线或者内部大小写</p>
<p>因此是a-b而不是a_b或者aB</p>
<h2 id="定义参数">定义参数</h2><p>一个函数的形参列表定义了一些变量，将用来保存函数在调用时所传递的实参。如果函数是不带有实参，则该列表就是空得，写成（）。不同种类的形参分别负责处理必要的，可选的，多重的以及关键字实参。</p>
<h2 id="参数说明">参数说明</h2><p>如果一个字符串紧跟在形参列表之后，那么它应该就是一个用来描述函数用途的文档字符串。当定义函数时，该文档字符串将被关联到函数名上，并且以后可以通过DOCUMENTATION函数来获取</p>
<h2 id="最后总结">最后总结</h2><p>一个DEFUN的主体可由任意数量的lisp表达式所构成，他们将在函数被调用时依次求值，而最后一个表达式的值将被作为整个函数的值返回，另外RETURN-FROM特殊操作符可用于从函数的任何位置立即返回。</p>
<p>一开始学习的时候写的hello-world，形式如下</p>
<p><code>（defun hello-world () (format t &quot;hello, world&quot;)）</code></p>
<p>分析如下</p>
<ol>
<li>名字是hello-world</li>
<li>形式列表为空，因此不接受任何参数</li>
<li>没有文档字符串</li>
<li>函数体由一个表达式所构成（format t “hello，world”）</li>
</ol>
<p>另一个列子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> verbose-sum <span class="list">(<span class="keyword">x</span> y)</span></span><br><span class="line">      <span class="string">"Sum any two numbers after printing a message."</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"Summing ~d and ~d.~%"</span> x y)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数称为verbose-sum 接受两个实参分别为形参x和y一一对应并且带有一个文档字符串，以及一个由两个表达式所组成的主体。有“+”调用所返回的值将成为verbose-sum的返回值。</p>
<h1 id="函数形参列表">函数形参列表</h1><p>函数名和文档字符串差不多了，现在了解形参列表</p>
<p>形参列表的基本用途是为了声明一些变量用来接收传递给函数的实参，当形参列表是一个由变量名所组成的简单列表时，如同在verbose-sum里那样，这些形参叫必要形参。当函数调用时候，必须为每个必要形参都提供一个实参。每一个形参被绑定到对应的实参上。</p>
<p>但是，形参列表也给了更灵活的方法将函数调用实参映射到函数形参。除了必要形参以外，一个函数还可以有可选形参，或者也可以用单一形参绑定到含有任意多个额外参数的列表上。最后，参数还可以通过关键字而不是位置来映射到形参上，这样Commom lisp的形参列表对于集中常见的编码问题提供了一种便利的解决方案。</p>
<h1 id="可选形参">可选形参</h1><h2 id="定义">定义</h2><p>为了定义一个可选形参的函数，在必要形参的名字后放置符号&amp;optional后接可选形参的名字</p>
<h2 id="列子">列子</h2><p><code>（defun foo （a b &amp;optional c d）(list a b c d)）</code></p>
<p>当函数被调用时，实参被首先绑定到必要形参上，在所有必要形参都被赋值以后，如果还有任何实参剩余，它们的值被赋给可选形参。如果实参在所有可选形参被赋值前用完了，那么其余的可选形参将自动绑定到NIL上。这样，列子定义的函数会给出下面的结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 NIL NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3 4） -&gt; （1 2 3 4）</li>
</ul>
<p>lisp任然可以确保适当的数量的实参被传递给函数——在本列中是2-4个。而如果函数用太少或太多的参数来调用的话，会报错。</p>
<p>当然，我们经常想要一个不同于NIL的默认值，这时可以通过将新参名替换成一个含有名字跟一个表达式的列表来制定该默认值。只有在调用者没有传递足够的实参来为可选形参提供值得时候，这个表达式才会被求值，通常情况只是简单的提供一个值作为表达式：</p>
<p><code>(defun foo (a &amp;optional（b 10)) (list  a b))</code></p>
<p>上述函数要求将一个实参绑定到形参a上，当存在第二个实参时，第二个形参b将使用其值，否则使用10</p>
<ul>
<li>（foo 1 2） -&gt; （1 2）</li>
<li>（foo 1）-&gt; （1 10）</li>
</ul>
<p>不过，有时可能需要更灵活选择默认值，比如可能想要基于其他形参来计算默认值，默认值表达式可以引用早先出现在形参列表中的形参。如果要编写一个返回矩形的某种表示的函数，并且想要使它可以特别的产生正方形，那么可以使用一个像这样的形参列表。</p>
<p><code>(defun make-rectangle (width &amp;optional (height width)) ...)</code><br>除非明确知道否则这将导致height形参带有和width形参相同的值。</p>
<p>有时，有必要去了解一个可选形参的值究竟是被调用者明确指定还是使用了默认值。除了代码检查是否默认值（假如调用者碰巧显式传递了默认值，那么这样做终归是无效的）以外，还可以通过在形参标示符的默认值表达式之后添加另一个变量名来做到这点。该变量将在调用者实际为该形参提供了一个实参是被绑定到真值，否则为NIL 通常约定，这种变量的名字与对应的真实形参相同，但是带有一个 -supplied-p后缀<br>列如:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">a</span> b <span class="keyword">&amp;optional</span> <span class="list">(<span class="keyword">c</span> <span class="number">3</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">lisp</span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这将给出类似下面结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 T）</li>
<li>（foo 1 2 4） -&gt; （1 2 4 T）</li>
</ul>
<h1 id="剩余形参">剩余形参</h1><p>可选形参仅适用于一些较为分散并且不能确定调用者是否会提供值得形参。但某些函数需要接收可变数量的实参，比如前面已经出现过的内置函数。FORMAT有两个必要实参，即流合控制串。单在这两个之后，它还需要一组可变数量的实参，这取决于控制串需要插入多少个值。</p>
<p>+函数也接受可变数量的实参——没有特别的理由限制它只能在两个数之间相加，它可以对任意数量的值做加法运算（它甚至可以没有实参，此时返回0——加法的底数）。下面这些都是这两个函数的合法调用:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, ~a"</span> name)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"x: ~d y: ~d"</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>很明显，也可以通过简单给它一些可选形参来写出接受可变数量实参的函数，但这样将会非常麻烦，光是写形参列表就已经够麻烦了，何况还要在函数体中处理所有这些形参。为了做好这件事，还不得不使用一个合法函数调用所能够传递的那么多的可选形参。这一具体数量与具体实现相关，但可以保证至少有50个。在当前所有实现中，它的最大值范围从4096到536870911</p>
<p>相反，Lisp允许在符合&amp;rest之后<em>包括</em>一揽子形参。如果函数带有&amp;rest形参，那么任何满足了必要可选形参之后其余所有实参就将被收集到一个列表里成为该&amp;rest形参的值。这样，FORMAT和+的形参列表可能看起来会是这样:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> format <span class="list">(<span class="keyword">stream</span> string <span class="keyword">&amp;rest</span> values)</span> ...)</span></span><br><span class="line"><span class="list">(<span class="keyword">defun</span> + <span class="list">(<span class="keyword">&amp;rest</span> nmbers)</span> ...)</span></span><br></pre></td></tr></table></figure>
<h1 id="关键字形参">关键字形参</h1><p>如果我想给第四个形参提供值，其余不给，怎么办呢，关键字形参就起作用了。（这个没有描述清楚）</p>
<p>如果用可选形参的话。如果给第四个可选形参传递一个显式值，就会导致前面三个可选形参对于调用者来说变成了必要形参。</p>
<p>定义：在任何必要的&amp;optional和&amp;rest形参之后，可以加上符号&amp;key以及任意数量的关键字形参标示符，后者的格式类似于可选形参标示符。下面就是一个只有关键字形参的函数:</p>
<p><code>(defun foo (&amp;key a b c) (list a b c))</code></p>
<p>当调用这个函数时，每一个关键字形参将绑定到紧跟在同名键字后面的那个值上，如前面所说，关键字以冒号开始的名字，并且他们被自动定义为自求值常量。</p>
<p>如果一个给定的关键字没有出现在实参列表中，那么对应的形参将被赋予其默认值，如同可选形参那样。因为关键字实参带有标签，所以他们在必要实参之后可按任意顺序进行传递。例如foo可以用下列形式调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">foo</span>)</span>  -&gt; <span class="list">(<span class="keyword">NIL</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:c</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> NIL <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:b</span> <span class="number">2</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span> <span class="keyword">:b</span> <span class="number">2</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>如同可选形参那样，关键字形参也可以提供一个默认值形式以及一个supplied-p变量名。</p>
<p>在关键字形参和可选形参中，这个默认值形式都可以引用那些早先出现在形参列表中的形参。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="keyword">a</span> <span class="number">0</span>)</span> <span class="list">(<span class="keyword">b</span> <span class="number">0</span> b-supplied-p)</span> <span class="list">(<span class="keyword">c</span> <span class="list">(<span class="keyword">+</span> a b)</span>)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">list</span> a b c b-supplied-p)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">2</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt; <span class="list">(<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br></pre></td></tr></table></figure>
<p>同样，出于某种原因想让调用者用来指定形参的关键字不同于实际形参名，那么可以将形参名替换成一个列表，令其含有调用函数时使用的关键字以及用作形参的名字，比如说下面这个foo的定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="list">(<span class="attribute">:apple</span> a)</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:box</span> b)</span> <span class="number">0</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:charlie</span> c)</span> <span class="number">0</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">list</span></span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以让调用者这样调用它:</p>
<p><code>(foo :apple 10 :box 20 :charlie 30)  -&gt; (10 20 30 T)</code></p>
<p>这种风格在想要完全将函数的公共API与其内部细节相隔离时特别有用，通常是因为想要在内部使用段变量名，而不是API中的描述性关键字。不过该特性不常被用到。</p>
<h1 id="混合不同的形参类型">混合不同的形参类型</h1><p>四个混合使用，多种混合使用时候：必须以这样的顺序声明:首先是<em>必要形参</em> 其次是<em>可选形参</em> 再次是<em>剩余形参</em> 最后才是<em>关键字形参</em>。但在使用多种类型形参的函数中，一般情况是将必要和另外一种类型形参组合使用，或者可能是组合&amp;optional形参和&amp;rest形参。其它两种组合方式，无论是&amp;optional形参还是&amp;rest形参，当与&amp;key形参组合使用时，都可能导致某种奇怪的行为。</p>
<p>将&amp;optional形参和&amp;key形参组合使用时将产生非常奇怪的结果，因此也许应该避免将他们一起使用，问题出现在如果调用者没有为所有可选形参提供值时，那么没有得到值得可选形参将吃掉原本用于关键字形参的关键字和值。列如，下面这个函数很不明智地混合了&amp;optional形参和&amp;key形参:</p>
<p><code>（defun foo （x &amp;optional y &amp;key z）（list x y z））</code></p>
<p>如果像这样调用的话，就没问题:</p>
<p><code>(foo 1) -&gt; (1 nil nil)</code></p>
<p>但是这样的话将报错:</p>
<p><code>(foo 1 :z 3) -&gt; ERROR</code></p>
<p>这是因为关键字:z被作为一个值填入到可选的y形参中了，只留下了参数3被处理。在这里，Lisp期待一个成对的关键字/值，或者什么也没有，否则就会报错，也许更坏的是，如果该函数带有两个&amp;optional形参，上面最后一个调用将导致值:z和3分别被绑定到两个&amp;optional形参上，而&amp;key形参z将得到默认值NIL 而不声明缺失了东西。</p>
<p>一般而言，如果正在编写一个同时使用&amp;optional形参和&amp;key形参的函数，可能就应该将它变成全部使用&amp;key形参的形式——他们更灵活，并且总会可以在不破坏该函数的已有调用的情况下添加新的关键字形参。也可以移除关键字形参，只要没人在使用他们，一般而言，使用关键字形参就uhui使代码相对易于维护和拓展——如果需要为函数添加一些需要用到新参数的新行为，就可以直接添加关键字形参，而无需修改甚至重新编译任何调用该函数的已有代码。</p>
<p>虽然可以安全的组合使用&amp;rest形参和&amp;key形参    ，但其行为初看起来可能会有一点奇怪。正常的来讲，无论是&amp;rest还是&amp;key出现在形参列表中，都将导致所有出现在必要形参和&amp;optional形参之后的那些值被特别处理——要么作为&amp;rest和&amp;key同时出现在形参列表中，那么两件事都会发生——所有剩余的值，包括关键字本身，都将被收集到一个列表里，然后绑定到&amp;rest形参上，而适当的值，也会同时被绑定到&amp;key形参上，因此给定下列函数:</p>
<p><code>(defun foo (&amp;rest rest &amp;key a b c) (list rest a b c))</code></p>
<p>将会得到如下结果:</p>
<p><code>(foo :a 1 :b 2 :c 3) -&gt; ((:A 1 :B 2 :C 3) 1 2 3)</code></p>
<h1 id="函数返回值">函数返回值</h1><p>目前所有函数都使用了默认的返回值行为，既<em>最后一个表达式的值</em>被作为整个函数的<strong>返回值</strong>。这是从函数中返回值得最常见方式。</p>
<p>有些时候，尤其是想要从嵌套的控制结构中脱身时，如果有办法从函数中间返回，那就是非常便利的。在这种情况下，你可以使用RETURN-FROM特殊操作符，它能够立即以任何职从函数中间返回。<del>RETURN-FROM事实上不只用于函数，还可以用来从一个由BLOCK特殊操作符所定义的代码块中返回。</del>不过DEFUN会自动将其整个函数体包装在一个与其函数同名的代码块中，因此，对一个带有当前函数名和想要返回的值的RETURN-FROM是一个特殊操作符，其第一个“参数”是它想要返回的代码块名。该名字不被求值，因此无需引用。</p>
<p>下面这个函数使用了嵌套循环来发现第一个数对——每个都小于10，并且其成绩大于函数的参数，它使用RETURN-FROM在发现后立即返回该数对;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">n</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">i</span> <span class="number">10</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">j</span> <span class="number">10</span>)</span></span><br><span class="line">			<span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> i j)</span> n)</span></span><br><span class="line">				<span class="list">(<span class="keyword">return-from</span> foo <span class="list">(<span class="keyword"><span class="built_in">list</span></span> i j)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>必须承认的是，不得不指定正在返回的函数名多少会有些不便——比如改变了函数的名字，就需要同时改变RETURN-FROM中所使用的名字，但是在事实上，显式的RETURN-FROM调用在Lisp中出现的频率远小于return语句在源自C的语言里出现的频率，因为所有的Lisp表达式，包括诸如循环和条件语句这样的控制结构，都会求值得到一个值，因此在实践中这不是什么问题。</p>
<h1 id="作为数据的函数————高阶函数">作为数据的函数————高阶函数</h1><p>使用函数主要方式—-<strong>通过名字来调用</strong> 但有时将函数作为数据看待也是很有用的。列如，可以将一个函数作为参数传递给另一个函数，从而能写出一个通用的排序函数，允许调用者提供一个比较任意两元素的函数，这样通用的底层算法就可以跟许多不同的比较函数配合使用了。</p>
<p>类似的，回调函数（callback）和钩子（hook）也需要能够保存代码引用便于以后运行。由于函数已经是一种对代码比特进行抽象的标准方式，因此允许把函数视为数据也是合理的。</p>
<p>在Lisp中，函数只是另一种类型的对象，在用DEFUN定义一个函数时，实际上做了两件事：创建一个新的函数对象以及赋予其一个名字，前面说过，也可以使用LAMBDA表达式来创建一个函数而无需为其指定一个名字。一个函数对象的实际表示，无论是有名的还是匿名的，都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。只需要知道如何保持它们以及需要时如何调用它们。</p>
<p>特殊操作符FUNCTION提供了用来获取一个函数对象的方法，它接受单一实参并返回与该参数同名的函数。这个名字是不被引用的。因此如果一个函数foo的定义如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? (defun foo (x) (* x x))</span><br><span class="line">FOO</span><br><span class="line">就可以得到如下的函数对象</span><br><span class="line">? (<span class="function"><span class="keyword">function</span></span> foo)</span><br><span class="line">#&lt;Compiled-<span class="function"><span class="keyword">function</span></span> FOO #x302000F99E4F&gt;</span><br></pre></td></tr></table></figure>
<p>事实上前面已经用过FUNCTION了，但是它以伪装的形式出现的，前面用到的#’语法就是FUNCTION的语法糖，正如’是QUOTE的语法糖一样。因此也可以像这样得到foo的函数对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="preprocessor">#'foo</span></span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;Compiled-function FOO #x302000ECB11F&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一旦得到了函数对象，就只剩下一件事可做了——调用它。Common Lisp提供了两个函数用来调用函数: FUNCALL和APPLY 它们的区别仅在于如何获取传递给函数的实参。</p>
<p>FUNCALL用于在编写代码时确切知道传递给函数多少实参时，FUNCALL的第一个实参是被调用的函数对象，其余的实参被传递到该函数中。因此，下面两个表达式是等价的:</p>
<p><code>（foo 1 2 3）= （funcall #&#39;foo 1 2 3）</code></p>
<p>不过，用FUNCALL来调用一个写代码时名字已知的函数毫无意义。事实上，前面的两个表达式很可能被编译成相同的机器指令。</p>
<p>下面这个函数演示了FUNCALL的另一个更有建设性的用法。它接受一个函数对象作为实参，并使用实参函数在min和max之间以step为步长的返回值绘制一个简单的ASCII式柱状图:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L-USER&gt; <span class="list">(<span class="keyword">defun</span> plot <span class="list">(<span class="keyword">fn</span> min max step)</span></span><br><span class="line">	   <span class="list">(<span class="keyword">loop</span> for i from min to max by step do</span><br><span class="line">		<span class="list">(<span class="keyword">loop</span> repeat <span class="list">(<span class="keyword">funcall</span> fn i)</span> do <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"*"</span>)</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~%"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>FUNCALL表达式在每个i值上计算函数的值，内层LOOP循环使用计算得到的值来决定向标准输出打印多少星号。</p>
<p>请注意，不需要使用FUNCTION或#‘来得到fn的函数值，因为它是作为函数对象的变量的值，所以你需要它解释成一个变量。可以用任何接受单一数值实参的函数来调用plot，列如内置的函数EXP，它返回以e为底以其实参为指数的值。</p>
<pre><code>(plot <span class="comment">#'exp 0 4 1/2)</span>
<span class="keyword">*</span>
<span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
NIL
</code></pre><p>然而，当实参列表只在运行期已知时，FUNCALL的表现不佳，列如，为了再次调用plot函数，假设你已有一个列表，其包括一个函数对象，一个最小值和一个最大值以及一个步长。换句话说，这个列表包含了你想要作为实参传给plot的所有值，假设这个列表保存在变量plot-data中，可以像这样用列表中的值来调用plot:</p>
<p><code>(plot (first plot-data) (second plot-data) (third plot-data) (fourth plot-data))</code></p>
<p>这样固然可以，但仅仅为了将实参传给plot而显式地将其解开，看起来相当不爽。</p>
<p>这样就需要APPLY的原因，和FUNCTION一样，APPLY的第一个参数是一个函数对象，但在这个函数对象之后，它期待一个列表而非单独的实参。它将函数应用在列表中的值上，这就使你可以写出下面的替代版本:</p>
<p><code>(apply #&#39;plot plot-data)</code></p>
<p>更方便的是，APPLY还接受“孤立”（loose）的实参，只要最后一个参数是个列表，因此，加入plot-data只含有最小，最大和步长值，那么你仍然可以像这样来使用APPLY在该范围上绘制EXP函数:</p>
<p><code>(apply #&#39;plot exp plot-data)</code></p>
<p>APPLY并不关心所用的函数是否接受&amp;optional &amp;rest 或&amp;key实参——由任何孤立实参和最后的列表所组合而成的实参列表必定是一个合法的实参列表，其对于该函数来说带有足够的实参用于所有必要形参和适当的关键字形参。</p>
<h1 id="匿名函数">匿名函数</h1><p>一开始编写或只是使用那些可以接受其它函数作为实参的函数，你就必然发现，有时不得不去定义和命名一个仅使用一次的函数，尤其是你可能从不用名字来调用它时，这会让人相当恼火。</p>
<p>觉得没必要用DEFUN来定义一个新函数时，可以使用一个LAMBDA表达式创建匿名的函数。前面讨论过，一个LAMBDA表达式形式如下:</p>
<p><code>(lambda (parameters) body)</code></p>
<p>可以将LAMBDA表达式视为一种特殊类型的函数名，其名字本身直接描述函数的用途，这就解释了为什么可以使用一个带有#’的LAMBDA表达式来代替一个函数名。</p>
<p><code>(funcall #&#39;(lambda (x y) (+ x y)) 2 3)  -&gt;5</code></p>
<p>甚至可以在一个函数调用表达式中将LAMBDA表达式用作函数名，由此一来，我们可以在需要时以更简洁方式来书写前面的FUNCALL表达式如下:</p>
<p><code>((lambda (x y) (+ x y)) 2 3) -&gt; 5</code></p>
<p>但是几乎没人这样做，它唯一的用途是来强调将LAMBDA表达式用在任何一个正常函数名可以出现的场合是合法的。</p>
<p>在需要传递一个作为实参的函数给另一个函数，并且需要传递的这个函数简单到可以内联表达时，匿名函数特别有用，列如，假设想要绘制函数2x 你可以定义下面的函数:</p>
<p><code>defun double (x) (* 2 x))</code></p>
<p>并随后将其传给plot</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'double 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">Nil</span><br></pre></td></tr></table></figure>
<p>但如果写成这样就会更简单和清晰:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'(lambda (x) (* 2 x)) 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>LAMBDA表达式的另一项重要用途是制作闭包（closure），即捕捉了其创建时环境信息的函数。前面也使用了一点闭包，但是要想深入了解闭包的工作原理和用途，更多地还是要从变量而非函数的角度去考察，下面在研究吧。</p>
<p><del>也可以不带前缀#’来使用一个LAMBDA表达式作为FUNCALL的参数</del></p>
<p><del>关于这个。。。</del></p>
<hr>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[语法]]></title>
    <link href="http://ioschen.com/2014/03/23/yufa/"/>
    <id>http://ioschen.com/2014/03/23/yufa/</id>
    <published>2014-03-23T06:28:09.000Z</published>
    <updated>2014-03-28T03:13:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="括号里都有神马">括号里都有神马</h1><h1 id="S-表达式">S-表达式</h1><p>s-表达式基本元素是列表和原子。列表由括号包围，并可包含任何数量的由空格所分隔的元素。</p>
<p>空列表（）也可写成NIL既是原子也是列表</p>
<h2 id="数字的表示方法">数字的表示方法</h2><ol>
<li>123  整数123</li>
<li>3/7  比值七分之三</li>
<li>1.0  默认精度的浮点数1</li>
<li>1.0e0  同一个浮点数的另一个写法</li>
<li>1.0d0  双精度的浮点数1</li>
<li>1.0e-4  等价于万分之一的浮点数</li>
<li>+42  整数42</li>
<li>-42  附属42</li>
<li>-1/4  比值负四分之一</li>
<li>-2/8  负四分之一另一种写法</li>
<li>246/2  123另一种写法</li>
<li>lisp复数后面第十章开始解说</li>
</ol>
<p>-2/8和246/2等价于-1/4和123  1.0 等同于1.0e0   1.0、1.0d0 和1是不一样的，因为精度不同，代表的是不同类型的对象</p>
<h2 id="字符串">字符串</h2><ol>
<li>字符川由双引号包括，在字符串中，一个反斜杠会转义接下来的任意字符。</li>
<li>两个在字符串中必须被转移的字符串是<code>双引号和反斜杠本身</code></li>
</ol>
<table>
<thead>
<tr>
<th>字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foo”</td>
<td>含有foo的字符串</td>
</tr>
<tr>
<td>“fo\o”</td>
<td>含有foo的字符串</td>
</tr>
<tr>
<td>“fo\\o”</td>
<td>含有fo\o的字符串</td>
</tr>
<tr>
<td>“fo\”o”</td>
<td>含有fo”和o的字符串</td>
</tr>
</tbody>
</table>
<pre><code>lisp中所使用的名字，诸如FORMAT  hello-world和<span class="keyword">*</span>db<span class="keyword">*</span>均由称为符号的对象所表示。空白字符不可以出现在列表里，只有一个句点的名字也不可以。这是个字符不能出现在名字里:开括号，闭括号，双引号和单引号，反引号，逗号，冒号，分号，反斜杠以及竖线。（加上反斜杠转义或者将有需要转义的字符串的字符名字用竖线包起来，还是可以使用的）
</code></pre><p>读取器将把foo Foo和FOO都读成FOO，但\f\o\o 和 |foo|都被读成foo这是和符号FOO不同的另一个对象，这就是为什么REPL中定义一个函数时，它的名字会被打印成大写形式的原因。</p>
<p>现在标准的编码风格是将代码全部写成小写形式，然后让读取器将名字转换为大写。</p>
<p>为了保证同一个名字总是被读取成相同的符号，读取器保留这个符号，在已读取名字将其全部转化成大写形式后，读取器在一个称为包得表里查询带有相同名字的已有符号，如果没有找到，就创建一个新符号并添加到表里，否则返回已在表中的那个符号。<code>无论在任何地方，同意的名字出现在任何s-表达式里，都会用同一个对象去表示它</code></p>
<blockquote>
<p>全局变量名字开始和结尾处有*</p>
<blockquote>
<p>常量名开始结尾处有+</p>
<blockquote>
<p>有些程序员将特别低层的函数名前面加%或者%%</p>
<blockquote>
<p>语言标准所定义的名字只能使用字母字符表（A-Z）外加* + - / 1 2 &lt; = &gt; 以及&amp;这些符号</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="目前要求">目前要求</h2><p>只用列表，数字，字符串和符号就可以描述很大一部分的lisp程序呢其他的后面说<font color="red">目前关键是要理解怎样用数字，字符串和由符号借助括号所组成的列表式构建s-表达式，从而表示任意的树状对象。</font>下面是一些简单的列子。</p>
<ol>
<li>x                  符号x</li>
<li>（）             空列表</li>
<li>（1 2 3）         三个数字组成的列表</li>
<li>（”foo” “bar”） 两个字符串组成的列表</li>
<li>（x y z）         三个符号所组成的列表</li>
<li>（x 1 “foo”）    一个符号，一个数字和一个字符串所组成的列表</li>
<li>（+ （* 2 3）4）一个符号，一个列表，一个数字组成的列表</li>
</ol>
<p>下面这种四元素列表就稍显复杂了，它含有两个符号，空列表以及另一个列表-其本身又含有两个符号和一个字符串:<br>    <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> hello-world <span class="list">()</span> <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="作为Lisp形式的S-表达式">作为Lisp形式的S-表达式</h1><ol>
<li><p>读取器把大量文本转化为s-表达式后，这些s-表达式随后可以作为lisp形式被求值。（有些没必要求值）<br>任何一个原子（非列表或空列表）都是一个合法的Lisp形式</p>
</li>
<li><p>作为最简单的lisp形式，原子可以被分成两个类别：符号和所有其他内容。符号在作为lisp形式被求值时会被视为一个变量名，并且会被求值为该变量的当前值。</p>
</li>
<li><p>所有其他的原子，包括数字和字符串都是自求值对象。<br>比如输入10和helloworld</p>
</li>
<li><p>把符号变成自求值对象也是可能的，它所命名的变量可以被赋值成符号本身的值。两个以这种方式定义的常量是T和NIL，既所谓的真值和假值</p>
</li>
<li>另一类自求值符号是<code>关键字</code>符号-以名字冒号开始的符号。当读取器保留这样一个名字时，它会自动定义一个以此命名的常值变量并以该符号作为其值。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们开始考虑列表的求值方式时候，事情变得更加有趣了，所有合法的列表形式均以一个符号开始，但是有三种类型的列表形式，他们会以三种相当不同的方式进行求值，为了确定一个给定的列表式哪种形式，求值器必须检测列表开始处的那个符号是一个函数，宏还是特殊操作符的名字。如果该符号尚未定义，比如说当你正在编译一段含有对尚未定义函数的引用代码时，它会被假设成一个函数的名字。我将把这三种类型的形式称为函数调用形式，宏形式和特殊形式。</span><br></pre></td></tr></table></figure>
<p>common lisp中一个符号可以同时为操作符（函数，宏或特殊操作符）和变量命名</p>
<h1 id="函数调用">函数调用</h1><p>函数调用形式的求值规则很简单，对以lisp形式存在的列表其余元素进行求值并将结果传递到命名函数中，这一规则明显有着附加的句法限制在函数调用形式上:除第一个以外，所有的列表元素他们自身必须是一个形态良好的lisp形式，换句话说，函数调用形式的基本语法应如下所示，其中每个参数本身也是lisp形式:<br>（function-name argument*）</p>
<ol>
<li>(+ 1 2)首先求值1，再求值2然后将得到的值传给+函数再返回3</li>
<li>（<em> （+ 1 2）（- 3 4））先求参数的值为3和-1最后传递到</em>函数里，从而得到-3</li>
</ol>
<h1 id="特殊操作符">特殊操作符</h1><p>并非所有操作都可以定义成函数，由于一个函数的所有参数在函数调用之前都将被求值，因此无法写出一个累世IF操作符那样的函数</p>
<p>当列表的第一个元素是一个由特殊操作符所命名的符号时，表达式的其余部分将按照该操作符的规则进行求值。</p>
<h2 id="IF操作符">IF操作符</h2><font color="red">IF的规则相当简单:求值第一个表达式。如果得到非NIL，那么求值下一个表达式并返回它的值，否则，返回第三个表达式的求值，或者如果第三个表达式被省略的话，返回NIL。换句话说，一个IF表达式的基本形式是像下面这样:</font>

<p>(if test-form then-form [else-form])</p>
<p>其中test-form将总是被求值 ，然后要么是then-form要么是else-form</p>
<h2 id="QUOTE操作符">QUOTE操作符</h2><p>一个更简单的操作符是QUOTE，它接受一个单一表达式作为其“参数”并简单的返回他，不经求值，列如，下面的表达式求值得到列表（+ 1 2），而不是值3:</p>
<p><code>(quote (+ 1 2))</code></p>
<p>QUOTE用得非常普遍，以至于读取器内置一个它的特别语法形式，还可以写成 ‘(+ 1 2) <del>该语法是读取器所理解的s-表达式语法的小扩展</del></p>
<p>一般来说，特殊操作符所实现的语言特性需要求职器操作出某些特殊处理。列如，有些的操作符修改了其他形式的求值环境，其中之一是LET，下面会详细解说，它用来创建新的变量绑定。下面的形式求值得到10，因为在第二个x的求值环境中，它是由LET赋值为10的变量名:</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">let</span></span> <span class="list">(<span class="list">(<span class="keyword">x</span> <span class="number">10</span>)</span>)</span> x)</span>
</code></pre><h1 id="宏">宏</h1><p>由于特殊操作符数量在标准语言中是固定的，然而宏却能提供给语言用户另一种语法扩展方式。宏是以一个s-表达式为其参数的函数，并返回一个lisp形式，然后对其求值并用该值取代宏形式。宏形式的求值过程包括两个阶段：<font color="red">首先，宏形式的袁术不经常求值既被传递到宏函数里，其次，由宏函数所返回的形式（展开式）按照正常的求值规则进行求值。</font></p>
<p>。。。</p>
<h1 id="真_假和等价">真 假和等价</h1><h2 id="真假">真假</h2><ol>
<li>符号NIL式唯一的假值，其他所有都是真值</li>
<li>符号T式标准的真值，可用于需要返回一个非    NIL值却又没有其他值可用的情况。</li>
<li>关于NIL唯一一个麻烦的一点是，它是唯一一个即是原子又是列表的对象：除了用来表示假以外，它还用来表示空列表。</li>
<li>nil （） ‘nil和’（）这四个求值结果一样的</li>
<li>t和‘t求值结果也完全相同：符号T</li>
</ol>
<h2 id="等价">等价</h2><ul>
<li>=用来比较数字</li>
<li>CHAR=用来比较字符</li>
</ul>
<p>等价时返回真，否则假</p>
<ol>
<li>EQ  只有两个对象相同时才是eq等价的（最好不是数字字符的比较时候用）</li>
<li>EQL  （eql 1 1）真    （eql 1 1.0）假</li>
<li>EQUAL 将在递归上具有相同结构和内容的表现视为等价，也认为含有相同字符的字符串是等价的，它对于位向量和路径名也定义了比eql更加宽松的等价性  </li>
<li>EQUALP  和equal相似，但是比较字符串忽略大小写区别，字母相同就是等价，只要数字表示相同数学意义上的值，他们在equalp下面就是等价的，因此（equalp 1 1.0）是真的。由equalp等价的元素组成的列表也是equalp等价的。同样的，带有equalp元素的数组也是equalp等价的，和equal一样，还有一些其他暂时没讲到的数据类型，equalp可认为两个对象是等价的，但是eql和equal则不会，对于所有其他数据类型，equalp会退到eql水平上。</li>
</ol>
<h1 id="格式化Lisp代码">格式化Lisp代码</h1><h2 id="代码缩进">代码缩进</h2><p>格式化代码关键在于正确缩进它，这一缩进应当反映出代码结构，这样就不用数括号了。一般而言，每一个新的嵌套层次都需要多缩进一点儿，并且如果折行是必须的，位于同一个嵌套层次的项应当按行对齐。<br>这样，一个需要跨越多行的函数调用可能就会被写成这样：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="keyword">some</span>-function arg-<span class="keyword">with</span>-a-long-<span class="property">name</span></span><br><span class="line">				 another-arg-<span class="keyword">with</span>-an-even-longer-					 <span class="property">name</span>）</span><br></pre></td></tr></table></figure>
<p>那些实现控制结构的宏和特殊形式在缩进上稍有不同：“主体”元素相对于整个形式的开括号缩进两个空格。就像这样</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">print</span>-<span class="keyword">list</span> （<span class="keyword">list</span>）</span><br><span class="line">	(dolist (i <span class="keyword">list</span>)</span><br><span class="line">		(<span class="keyword">format</span> t <span class="string">"item: ~a~%"</span> i))）</span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2><p><code>;;;;</code>   四个分号用于文件头注释</p>
<p><code>;;;</code>    带有三个分号的注释将通常作为段落注释应用到接下来的一大段代码上</p>
<p><code>;;</code>     两个分号说明该注释应用于接下来的代码上。注意，该注释与其所应用的代码具有相同的缩进</p>
<pre><code> ;;;这就是一大堆代码
（defun foo （x）
    （dotime （<span class="built_in">i</span> x）
         ;;这就是两个注释
        （some-<span class="function"><span class="keyword">function</span>-<span class="title">call</span>）</span>
        （another <span class="built_in">i</span>）
        （add-another）
        （baz）））
</code></pre><p>!–more–&gt;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="括号里都有神马">括号里都有神马</h1><h1 id="S-表达式">S-表达式</h1><p>s-表达式基本元素是列表和原子。列表由括号包围，并可包含任何数量的由空格所分隔的元素。</p>
<p>空列表（）也可写成NIL既是原子也是列表</p>
<h2 id=]]>
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iphoneSize]]></title>
    <link href="http://ioschen.com/2014/03/21/iphonesize/"/>
    <id>http://ioschen.com/2014/03/21/iphonesize/</id>
    <published>2014-03-21T00:53:44.000Z</published>
    <updated>2014-03-21T01:58:32.000Z</updated>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸未除2</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>head</td>
<td>(0,0,width,44)</td>
<td>(0,0,width,44)</td>
<td><font color="red">(0,20,width,44)</font></td>
<td><font color="red">(0,20,width,44)</font></td>
</tr>
<tr>
<td>center</td>
<td>(0,44,width,height-88)</td>
<td>(0,44,width,height-88)</td>
<td><font color="red">(0,64,width,height-108)</font></td>
<td><font color="red">(0,64,width,height-108)</font></td>
</tr>
<tr>
<td>foot</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>center大小</td>
<td>320*372</td>
<td>320*460</td>
<td>320*372</td>
<td>320*460</td>
</tr>
</tbody>
</table>
<h5 id="iphone4和iphone5只有高度相差88"><font color="red">iphone4和iphone5只有高度相差88</font></h5><p><del>表格中的height是self.view.frame.size.height，里面的width也是一样</del></p>
<p><del>ios6和ios7的self.view.frame.size是不一样的</del></p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸未除2</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>head</td>
<td>(0,0,width,44)</td>
<td>(0,0,width,44)</td>
<td><font color=red>(0,20,width,44)</font></td>
<td><font color=red>(0,20,width,44)</font></td>
</tr>
<tr>
<td>center</td>
<td>(0,44,width,height-88)</td>
<td>(0,44,width,height-88)</td>
<td><font color=red>(0,64,width,height-108)</font></td>
<td><font color=red>(0,64,width,height-108)</font></td>
</tr>
<tr>
<td>foot</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
<td>(0,height-44,width,44)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>规格</th>
<th>iphone4_ios6</th>
<th>iphone5_ios6</th>
<th>iphone4_ios7</th>
<th>iphone5_ios7</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸</td>
<td>640*960</td>
<td>640*1136</td>
<td>640*960</td>
<td>640*1136</td>
</tr>
<tr>
<td>center大小</td>
<td>320*372</td>
<td>320*460</td>
<td>320*372</td>
<td>320*460</td>
</tr>
</tbody>
</table>
<h5 id="iphone4和iphone5只有高度相差88"><font color=red>iphone4和iphone5只有高度相差88</font></h5><p><del>表格中的height是self.view.frame.size.height，里面的width也是一样</del></p>
<p><del>ios6和ios7的self.view.frame.size是不一样的</del></p>]]>
    
    </summary>
    
      <category term="ios" scheme="http://ioschen.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单的数据库]]></title>
    <link href="http://ioschen.com/2014/03/19/singlesql/"/>
    <id>http://ioschen.com/2014/03/19/singlesql/</id>
    <published>2014-03-19T12:31:31.000Z</published>
    <updated>2014-03-23T06:31:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CD和记录">CD和记录</h1><p>为了记录一些CD中MP3的信息，需要做一个数据库。<br>数据库每条记录包含CD标题和艺术家信息，一个多少用户喜欢它的评级，以及一个表示是否已经转换过的标记。<br>所以，需要一种方式表示一条数据库的记录（也就是一仗CD）最简单的就是使用列表</p>
<h2 id="列表">列表</h2><p><code>（list 1 2 3）</code>会得到（1 2 3）</p>
<h2 id="四元素列表">四元素列表</h2><h2 id="属性表">属性表</h2><p>以冒号开始的名字为关键字符号</p>
<p><code>（list :a 1 :b 2 :c 3）</code></p>
<p>(:A 1 :B 2 :C 3)</p>
<h2 id="GETF函数">GETF函数</h2><p>getf接受一个plist和一个符号，并返回plist中跟在那个符号后面的值</p>
<p>（getf （list :a 1 :b 2 :c 3）:a）得到1</p>
<p>（getf （list :a 1 :b 2 :c 3）:c）得到3</p>
<h2 id="make-cd函数">make-cd函数</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> make-cd <span class="list">(<span class="keyword">title</span> artist rating ripped)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">list</span></span> <span class="attribute">:title</span> title <span class="attribute">:artist</span> artist <span class="attribute">:rating</span> rating <span class="attribute">:ripped</span> ripped)</span>)</span></span><br></pre></td></tr></table></figure>
<p>defun告诉我们正在定义一个函数</p>
<p>函数名是make-cd，函数名都是-在中间命名，这个和其他语言区别啊</p>
<p>跟在名字后面的是形参列表，这个函数有四个形参 title artist rating 和ripped</p>
<p>形参列表后面的都是函数体，上面的函数体只有一个形式，即对list的调用，档make-cd被调用时，传递给调用的参数被绑定到形参列表中的变量上。</p>
<p>列如，为了建立一个关于Kathy Mattea的名为Roses的CD的记录，可以这样调用make-cd</p>
<p><code>(make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t)</code></p>
<p>回车返回(:TITLE “Roses” :ARTIST “Kathy Mattea” :RATING 7 :RIPPED T)</p>
<h1 id="录入CD">录入CD</h1><h2 id="DEFVAR宏定义全局变量*db*">DEFVAR宏定义全局变量*db*</h2><p>只有单一记录还不能算是一个数据库，需要一些更大的结构来保存记录，出于简化目的，可以使用一个全局变量*db*</p>
<p>命名中的*号是Lisp的全局变量命名约定</p>
<p><code>(defvar *db* nil)</code></p>
<p>可以用PUSH宏为*db*添加新的项，稍微抽象一些，因此可以定义一个函数add-record来给数据库增加一条记录</p>
<p>其实就是插入数据</p>
<p><code>(defun add-record (cd) (push cd *db*))</code></p>
<h2 id="插入数据">插入数据</h2><p>现在可以讲add-record和make-cd一起使用，为数据库添加新CD记录了</p>
<p><code>(add-record (make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t))</code></p>
<p><code>(add-record (make-cd &quot;Qoses&quot; &quot;Kathy Mattea&quot; 6 t))</code>    </p>
<p>每次都PUSH返回正在修改的变量的最新值</p>
<h1 id="查看数据库的内容">查看数据库的内容</h1><h2 id="无论如何，输入*db*都可以看到*db*的当前值">无论如何，输入*db*都可以看到*db*的当前值</h2><p>但是这个查看方式不爽，不是人类看的，可以用一个dump-db函数讲数据库变成有格式的，符合人类看的</p>
<p>比如</p>
<p>TITLE: home<br>ARTIST: da<br>RATING:     5<br>ROPPED: T</p>
<p>TITLE: homeqe<br>ARTIST: da<br>RATING:     6<br>ROPPED: T</p>
<p><del>全局变量一个缺点是每时每刻只能有一个数据库</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">	<span class="list">(<span class="keyword">dolist</span> <span class="list">(<span class="keyword">cd</span> <span class="variable">*db*</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~a: ~10t~a~%~&#125;~%"</span> cd)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的工作原理就是在使用DOLIST宏在*db*的所有元素上循环，依次绑定每个元素到变量cd上，然后使用format函数打印出每个cd的值</p>
<p>format至少接收两个参数，第一个是用来发送输出的流，t是标准输出流的简称。</p>
<p>第二个蚕食是一个格式字符串，内容既包括字面文本，也包括那些告诉format如何插入其余参数等信息的指令，。格式指令以~开始，类似于printf指令以%开始，</p>
<p>~a指令是美化指令，它的意图是消耗一个参数，然后将其输出成人类可读的形式，这将使得关键字被渲染成不带前导冒号的形式，而字符串也不再有引号呢，</p>
<p>比如<code>(format t &quot;~a&quot; &quot;jing yu&quot;)</code></p>
<p>输出 </p>
<pre><code>jing yu

 <span class="keyword">NIL</span>
</code></pre><p>~t指令用于制表，~10t告诉format产生足够的空格，以确保在处理下一个~a之前将光标移动10列。~t指令不适用任何参数</p>
<p><code>（format &quot;~a:~10t~a&quot; :artist &quot;Dixie Chicks&quot;）</code></p>
<p>输出</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dixie Chicks</span><br><span class="line"></span><br><span class="line"><span class="keyword">NIL</span></span><br></pre></td></tr></table></figure>
<p>现在事情复杂了，档format看到~{的时候，下一个被使用的实参必须是一个列表。format在列表上循环操作，处理位于~{和~}之间的指令，同时在每次需要时，从列表上使用尽可能多的元素，在dump-db里，format循环将每次循环时从列表上消耗一个关键字和一个值。</p>
<p>~%指令并不消耗任何实参，而只是告诉format来产生一个执行，然后再~{循环结束以后，最后一个~%告诉format再输出一个额外的换行，以便在每个cd数据间产生一个空行</p>
<p><del>从技术上来讲，也可以使用format在整个数据库本身循环，从而将dump-db函数变成只有一行</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~&#123;~a: ~10t~a~%~&#125;~%~&#125;"</span> <span class="variable">*db*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="最牛逼的FORMAT指令~R指令">最牛逼的FORMAT指令~R指令</h2><p>用英语说一个大数字</p>
<p><code>(format nil &quot;~r&quot; 3489142793724123341)</code></p>
<h1 id="改进用户交互">改进用户交互</h1><p>这个界面不友好对于普通用户 ，变成提示用户输入的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-read <span class="list">(<span class="keyword">prompt</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">format</span> <span class="variable">*query-io*</span> <span class="string">"~a: "</span> prompt)</span></span><br><span class="line">	<span class="list">(<span class="keyword">force-output</span> <span class="variable">*query-io*</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">read-line</span> <span class="variable">*query-io*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">    <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"ripped [y/n]"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword"><span class="built_in">or</span></span> <span class="list">(<span class="keyword">parse-integer</span> <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span> <span class="attribute">:junk-allowed</span> t)</span> <span class="number">0</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Ripped [y/n]: "</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> add-cds <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">loop</span></span> <span class="list">(<span class="keyword">add-record</span> <span class="list">(<span class="keyword">prompt-for-cd</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Another? [y/n]: "</span>)</span>)</span> <span class="list">(<span class="keyword">return</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="保存和加载数据库">保存和加载数据库</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> save-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">out</span> filename</span><br><span class="line">                           <span class="keyword">:direction</span> <span class="keyword">:output</span></span><br><span class="line">                           <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">print</span> <span class="variable">*db*</span> out)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果退出了下次数据没了就吊了，所以必须保存</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> load-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">in</span> filename)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">setf</span> *db* <span class="list">(<span class="keyword"><span class="built_in">read</span></span> in)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>读取数据</p>
<p>load-db之前要确保保存了，如果save-db后又加入了一些数据，这个时候load-db那么这些刚加入的数据就会丢失</p>
<h1 id="查询数据库">查询数据库</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">#'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"Dixie Chicks"</span>)</span>)</span> *db*)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> select-by-artist <span class="list">(<span class="keyword">artist</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">       #'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"sfada"</span>)</span>)</span> *db*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="更新已有记录">更新已有记录</h1><h1 id="消除重复，获益良多">消除重复，获益良多</h1><h1 id="总结">总结</h1><p>我已经不想写了，也没有完全看下去，最后的部分主要是加入数据库的几个功能-增加删除修改查询</p>
<p>昨天晚上今天晚上两个晚上没有看出什么，唯一的感觉就是这个好像真的很牛逼，几个方法就U可以实现增删查改</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CD和记录">CD和记录</h1><p>为了记录一些CD中MP3的信息，需要做一个数据库。<br>数据库每条记录包含CD标题和艺术家信息，一个多少用户喜欢它的评级，以及一个表示是否已经转换过的标记。<br>所以，需要一种方式表示一条数据库的记录（也就是一仗CD）最简单的就是使用列表</p>
<h2 id="列表">列表</h2><p><code>（list 1 2 3）</code>会得到（1 2 3）</p>
<h2 id="四元素列表">四元素列表</h2><h2 id="属性表">属性表</h2><p>以冒号开始的名字为关键字符号</p>
<p><code>（list :a 1 :b 2 :c 3）</code></p>
<p>(:A 1 :B 2 :C 3)</p>
<h2 id="GETF函数">GETF函数</h2><p>getf接受一个plist和一个符号，并返回plist中跟在那个符号后面的值</p>
<p>（getf （list :a 1 :b 2 :c 3）:a）得到1</p>
<p>（getf （list :a 1 :b 2 :c 3）:c）得到3</p>
<h2 id="make-cd函数">make-cd函数</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> make-cd <span class="list">(<span class="keyword">title</span> artist rating ripped)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">list</span></span> <span class="attribute">:title</span> title <span class="attribute">:artist</span> artist <span class="attribute">:rating</span> rating <span class="attribute">:ripped</span> ripped)</span>)</span></span><br></pre></td></tr></table></figure>
<p>defun告诉我们正在定义一个函数</p>
<p>函数名是make-cd，函数名都是-在中间命名，这个和其他语言区别啊</p>
<p>跟在名字后面的是形参列表，这个函数有四个形参 title artist rating 和ripped</p>
<p>形参列表后面的都是函数体，上面的函数体只有一个形式，即对list的调用，档make-cd被调用时，传递给调用的参数被绑定到形参列表中的变量上。</p>
<p>列如，为了建立一个关于Kathy Mattea的名为Roses的CD的记录，可以这样调用make-cd</p>
<p><code>(make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t)</code></p>
<p>回车返回(:TITLE “Roses” :ARTIST “Kathy Mattea” :RATING 7 :RIPPED T)</p>
<h1 id="录入CD">录入CD</h1><h2 id="DEFVAR宏定义全局变量*db*">DEFVAR宏定义全局变量*db*</h2><p>只有单一记录还不能算是一个数据库，需要一些更大的结构来保存记录，出于简化目的，可以使用一个全局变量*db*</p>
<p>命名中的*号是Lisp的全局变量命名约定</p>
<p><code>(defvar *db* nil)</code></p>
<p>可以用PUSH宏为*db*添加新的项，稍微抽象一些，因此可以定义一个函数add-record来给数据库增加一条记录</p>
<p>其实就是插入数据</p>
<p><code>(defun add-record (cd) (push cd *db*))</code></p>
<h2 id="插入数据">插入数据</h2><p>现在可以讲add-record和make-cd一起使用，为数据库添加新CD记录了</p>
<p><code>(add-record (make-cd &quot;Roses&quot; &quot;Kathy Mattea&quot; 7 t))</code></p>
<p><code>(add-record (make-cd &quot;Qoses&quot; &quot;Kathy Mattea&quot; 6 t))</code>    </p>
<p>每次都PUSH返回正在修改的变量的最新值</p>
<h1 id="查看数据库的内容">查看数据库的内容</h1><h2 id="无论如何，输入*db*都可以看到*db*的当前值">无论如何，输入*db*都可以看到*db*的当前值</h2><p>但是这个查看方式不爽，不是人类看的，可以用一个dump-db函数讲数据库变成有格式的，符合人类看的</p>
<p>比如</p>
<p>TITLE: home<br>ARTIST: da<br>RATING:     5<br>ROPPED: T</p>
<p>TITLE: homeqe<br>ARTIST: da<br>RATING:     6<br>ROPPED: T</p>
<p><del>全局变量一个缺点是每时每刻只能有一个数据库</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">	<span class="list">(<span class="keyword">dolist</span> <span class="list">(<span class="keyword">cd</span> <span class="variable">*db*</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~a: ~10t~a~%~&#125;~%"</span> cd)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的工作原理就是在使用DOLIST宏在*db*的所有元素上循环，依次绑定每个元素到变量cd上，然后使用format函数打印出每个cd的值</p>
<p>format至少接收两个参数，第一个是用来发送输出的流，t是标准输出流的简称。</p>
<p>第二个蚕食是一个格式字符串，内容既包括字面文本，也包括那些告诉format如何插入其余参数等信息的指令，。格式指令以~开始，类似于printf指令以%开始，</p>
<p>~a指令是美化指令，它的意图是消耗一个参数，然后将其输出成人类可读的形式，这将使得关键字被渲染成不带前导冒号的形式，而字符串也不再有引号呢，</p>
<p>比如<code>(format t &quot;~a&quot; &quot;jing yu&quot;)</code></p>
<p>输出 </p>
<pre><code>jing yu

 <span class="keyword">NIL</span>
</code></pre><p>~t指令用于制表，~10t告诉format产生足够的空格，以确保在处理下一个~a之前将光标移动10列。~t指令不适用任何参数</p>
<p><code>（format &quot;~a:~10t~a&quot; :artist &quot;Dixie Chicks&quot;）</code></p>
<p>输出</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dixie Chicks</span><br><span class="line"></span><br><span class="line"><span class="keyword">NIL</span></span><br></pre></td></tr></table></figure>
<p>现在事情复杂了，档format看到~{的时候，下一个被使用的实参必须是一个列表。format在列表上循环操作，处理位于~{和~}之间的指令，同时在每次需要时，从列表上使用尽可能多的元素，在dump-db里，format循环将每次循环时从列表上消耗一个关键字和一个值。</p>
<p>~%指令并不消耗任何实参，而只是告诉format来产生一个执行，然后再~{循环结束以后，最后一个~%告诉format再输出一个额外的换行，以便在每个cd数据间产生一个空行</p>
<p><del>从技术上来讲，也可以使用format在整个数据库本身循环，从而将dump-db函数变成只有一行</del></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> dump-db <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~&#123;~&#123;~a: ~10t~a~%~&#125;~%~&#125;"</span> <span class="variable">*db*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="最牛逼的FORMAT指令~R指令">最牛逼的FORMAT指令~R指令</h2><p>用英语说一个大数字</p>
<p><code>(format nil &quot;~r&quot; 3489142793724123341)</code></p>
<h1 id="改进用户交互">改进用户交互</h1><p>这个界面不友好对于普通用户 ，变成提示用户输入的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-read <span class="list">(<span class="keyword">prompt</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">format</span> <span class="variable">*query-io*</span> <span class="string">"~a: "</span> prompt)</span></span><br><span class="line">	<span class="list">(<span class="keyword">force-output</span> <span class="variable">*query-io*</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">read-line</span> <span class="variable">*query-io*</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">    <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span></span><br><span class="line">     <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"ripped [y/n]"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> prompt-for-cd <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword">make-cd</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Title"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Artist"</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword"><span class="built_in">or</span></span> <span class="list">(<span class="keyword">parse-integer</span> <span class="list">(<span class="keyword">prompt-read</span> <span class="string">"Rating"</span>)</span> <span class="attribute">:junk-allowed</span> t)</span> <span class="number">0</span>)</span></span><br><span class="line">       <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Ripped [y/n]: "</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> add-cds <span class="list">()</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">loop</span></span> <span class="list">(<span class="keyword">add-record</span> <span class="list">(<span class="keyword">prompt-for-cd</span>)</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">not</span></span> <span class="list">(<span class="keyword">y-or-n-p</span> <span class="string">"Another? [y/n]: "</span>)</span>)</span> <span class="list">(<span class="keyword">return</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="保存和加载数据库">保存和加载数据库</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> save-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">out</span> filename</span><br><span class="line">                           <span class="keyword">:direction</span> <span class="keyword">:output</span></span><br><span class="line">                           <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">print</span> <span class="variable">*db*</span> out)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果退出了下次数据没了就吊了，所以必须保存</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> load-db <span class="list">(<span class="keyword">filename</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">with-open-file</span> <span class="list">(<span class="keyword">in</span> filename)</span></span><br><span class="line">        <span class="list">(<span class="keyword">with-standard-io-syntax</span></span><br><span class="line">            <span class="list">(<span class="keyword">setf</span> *db* <span class="list">(<span class="keyword"><span class="built_in">read</span></span> in)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>读取数据</p>
<p>load-db之前要确保保存了，如果save-db后又加入了一些数据，这个时候load-db那么这些刚加入的数据就会丢失</p>
<h1 id="查询数据库">查询数据库</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">#'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"Dixie Chicks"</span>)</span>)</span> *db*)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> select-by-artist <span class="list">(<span class="keyword">artist</span>)</span></span><br><span class="line">      <span class="list">(<span class="keyword">remove-if-not</span> </span><br><span class="line">       #'<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">cd</span>)</span> <span class="list">(<span class="keyword">equal</span> <span class="list">(<span class="keyword">getf</span> cd <span class="attribute">:artist</span>)</span> <span class="string">"sfada"</span>)</span>)</span> *db*)</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="更新已有记录">更新已有记录</h1><h1 id="消除重复，获益良多">消除重复，获益良多</h1><h1 id="总结">总结</h1><p>我已经不想写了，也没有完全看下去，最后的部分主要是加入数据库的几个功能-增加删除修改查询</p>
<p>昨天晚上今天晚上两个晚上没有看出什么，唯一的感觉就是这个好像真的很牛逼，几个方法就U可以实现增删查改</p>]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Common lisp]]></title>
    <link href="http://ioschen.com/2014/03/18/lisp/"/>
    <id>http://ioschen.com/2014/03/18/lisp/</id>
    <published>2014-03-18T12:41:38.000Z</published>
    <updated>2014-03-19T12:30:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="我为什么学习lisp">我为什么学习lisp</h1><p>至于我为什么学习lisp，这一切都源于Emacs，因为Emacs我知道了lisp，知道它很牛逼，在一些unix论坛也发现很多人说lisp很牛逼。后来学习了几天就没有坚持下去，至于没有坚持下去可能是觉得这个没什么用处吧，这次看完黑客与画家又一次听说lisp很牛逼，实在无法忍受，于是这次开始学习lisp。看看到底有没有外界说的那么牛逼。思想上能有什么启发。</p>
<h1 id="lisp环境的安装">lisp环境的安装</h1><p>我对lisp的历史，分支什么的不是太感兴趣，只是在书中稍微了解了下，直接开始学习了。<br>Common lisp学习环境可以下载一个lispbox或者ccl（这个是Mac上面当今最主流的）。</p>
<p><a href="http://common-lisp.net/project/lispbox/" target="_blank" rel="external">lispbox下载链接</a><br>其实lispbox就是Emacs配置的</p>
<p>CCL可以直接从AppStore下载</p>
<p>这两个在Mac上面其实都很简单，不需要怎么配置就可以直接使用，但是我很喜欢CCL，因为它简单而又强大。</p>
<h1 id="Hello_World">Hello World</h1><ol>
<li><code>“hello，world”</code></li>
<li><code>（format t &quot;hello,world&quot;）</code></li>
<li><code>(write-line &quot;hello,world&quot;)</code></li>
<li><code>(print &quot;hello,world&quot;)</code><br>这四种各有含义。<a id="more"></a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="我为什么学习lisp">我为什么学习lisp</h1><p>至于我为什么学习lisp，这一切都源于Emacs，因为Emacs我知道了lisp，知道它很牛逼，在一些unix论坛也发现很多人说lisp很牛逼。后来学习了几天就没有坚持下去，至于没有坚持下去可能是觉得这个没什么用处吧，这次看完黑客与画家又一次听说lisp很牛逼，实在无法忍受，于是这次开始学习lisp。看看到底有没有外界说的那么牛逼。思想上能有什么启发。</p>
<h1 id="lisp环境的安装">lisp环境的安装</h1><p>我对lisp的历史，分支什么的不是太感兴趣，只是在书中稍微了解了下，直接开始学习了。<br>Common lisp学习环境可以下载一个lispbox或者ccl（这个是Mac上面当今最主流的）。</p>
<p><a href="http://common-lisp.net/project/lispbox/">lispbox下载链接</a><br>其实lispbox就是Emacs配置的</p>
<p>CCL可以直接从AppStore下载</p>
<p>这两个在Mac上面其实都很简单，不需要怎么配置就可以直接使用，但是我很喜欢CCL，因为它简单而又强大。</p>
<h1 id="Hello_World">Hello World</h1><ol>
<li><code>“hello，world”</code></li>
<li><code>（format t &quot;hello,world&quot;）</code></li>
<li><code>(write-line &quot;hello,world&quot;)</code></li>
<li><code>(print &quot;hello,world&quot;)</code><br>这四种各有含义。]]>
    
    </summary>
    
      <category term="Common lisp" scheme="http://ioschen.com/tags/Common-lisp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[anytime]]></title>
    <link href="http://ioschen.com/2014/02/22/anytime/"/>
    <id>http://ioschen.com/2014/02/22/anytime/</id>
    <published>2014-02-22T12:36:41.000Z</published>
    <updated>2014-03-08T16:26:09.000Z</updated>
    <content type="html"><![CDATA[<p>好久没有写了，今天写一个留下，看看有没有生疏</p>
<p>以前买东西的时候总是在乎涨价了，降价了，比价什么的，这个固然重要，但是只要自己开心就好，</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>好久没有写了，今天写一个留下，看看有没有生疏</p>
<p>以前买东西的时候总是在乎涨价了，降价了，比价什么的，这个固然重要，但是只要自己开心就好，</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[game]]></title>
    <link href="http://ioschen.com/2014/01/20/game/"/>
    <id>http://ioschen.com/2014/01/20/game/</id>
    <published>2014-01-20T01:03:01.000Z</published>
    <updated>2014-01-20T03:13:11.000Z</updated>
    <content type="html"><![CDATA[<p>#游戏开发<br>游戏开发最重要的就是选好游戏引擎</p>
<p>##游戏引擎<br>我所知道的公开的比较红得也就那几个</p>
<ol>
<li>cocos2d (已经出局)</li>
<li>cocos2d-x</li>
<li>Unity3d</li>
<li>sprite kit</li>
</ol>
<p>#性能对比<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表格使用</span><br><span class="line">sprite kit |<span class="string"> cocos2d-x </span>|<span class="string">unity3d </span><br><span class="line">-</span>|<span class="string">-</span>|<span class="string">-</span>|</span><br><span class="line">fddfs |<span class="string"> df </span>|<span class="string"> fds/</span>|<span class="string"> </span><br><span class="line">1. 最后一个转义字符/</span><br><span class="line">2. 每个环境对语法的支持不一样,效果不一样,主题也可以决定效果</span><br><span class="line">3. hexo里面第二排必须n个-</span>|<span class="string">  -</span>|<span class="string">标书一列</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th></th>
<th>sprite kit</th>
<th>cocos2d-x</th>
<th>unity3d </th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="red">优点</font></td>
<td>fddfs</td>
<td>df</td>
<td>fds/</td>
<td></td>
</tr>
<tr>
<td><font color="red">缺点</font></td>
<td>是</td>
<td>s</td>
<td>s</td>
<td></td>
</tr>
</tbody>
</table>
<p>##我的结论<br>游戏开发只选apple的<code>sprite kit</code>虽然这个不稳定,<br>后起,如果苹果倒了,就全倒了</p>
<p>#数学公式<br>    <script type="math/tex">E=mc^2</script><br>    数学公式</p>
<script type="math/tex">E=mc^2</script>

<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以下是几个三角恒等式：</span><br><span class="line">&lt;script type="math/tex; mode=display"&gt;</span><br><span class="line"><span class="command">\begin</span><span class="special">&#123;</span>align<span class="special">&#125;</span></span><br><span class="line"><span class="command">\sin</span> <span class="command">\left</span>(x+y<span class="command">\right</span>)=<span class="command">\sin</span> x <span class="command">\cos</span> y + <span class="command">\cos</span> x <span class="command">\sin</span> y<span class="command">\\</span></span><br><span class="line"><span class="command">\cos</span> <span class="command">\left</span>(x+y<span class="command">\right</span>)=<span class="command">\cos</span> x <span class="command">\cos</span> y - <span class="command">\sin</span> x <span class="command">\sin</span> y</span><br><span class="line"><span class="command">\end</span><span class="special">&#123;</span>align<span class="special">&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>以下是几个三角恒等式：</p>
<script type="math/tex; mode=display">
\begin{align}
\sin \left(x+y\right)=\sin x \cos y + \cos x \sin y\\
\cos \left(x+y\right)=\cos x \cos y - \sin x \sin y
\end{align}
</script>

<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>#游戏开发<br>游戏开发最重要的就是选好游戏引擎</p>
<p>##游戏引擎<br>我所知道的公开的比较红得也就那几个</p>
<ol>
<li>cocos2d (已经出局)</li>
<li>cocos2d-x</li>
<li>Unity3d</li>
<li>sprite kit</li>
</ol>
<p>#性能对比<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表格使用</span><br><span class="line">sprite kit |<span class="string"> cocos2d-x </span>|<span class="string">unity3d </span><br><span class="line">-</span>|<span class="string">-</span>|<span class="string">-</span>|</span><br><span class="line">fddfs |<span class="string"> df </span>|<span class="string"> fds/</span>|<span class="string"> </span><br><span class="line">1. 最后一个转义字符/</span><br><span class="line">2. 每个环境对语法的支持不一样,效果不一样,主题也可以决定效果</span><br><span class="line">3. hexo里面第二排必须n个-</span>|<span class="string">  -</span>|<span class="string">标书一列</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th></th>
<th>sprite kit</th>
<th>cocos2d-x</th>
<th>unity3d </th>
</tr>
</thead>
<tbody>
<tr>
<td><font color=red>优点</font></td>
<td>fddfs</td>
<td>df</td>
<td>fds/</td>
<td></td>
</tr>
<tr>
<td><font color=red>缺点</font></td>
<td>是</td>
<td>s</td>
<td>s</td>
<td></td>
</tr>
</tbody>
</table>
<p>##我的结论<br>游戏开发只选apple的<code>sprite kit</code>虽然这个不稳定,<br>后起,如果苹果倒了,就全倒了</p>
<p>#数学公式<br>    <script type="math/tex">E=mc^2</script><br>    数学公式</p>
<script type="math/tex">E=mc^2</script>

<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以下是几个三角恒等式：</span><br><span class="line">&lt;script type="math/tex; mode=display"&gt;</span><br><span class="line"><span class="command">\begin</span><span class="special">&#123;</span>align<span class="special">&#125;</span></span><br><span class="line"><span class="command">\sin</span> <span class="command">\left</span>(x+y<span class="command">\right</span>)=<span class="command">\sin</span> x <span class="command">\cos</span> y + <span class="command">\cos</span> x <span class="command">\sin</span> y<span class="command">\\</span></span><br><span class="line"><span class="command">\cos</span> <span class="command">\left</span>(x+y<span class="command">\right</span>)=<span class="command">\cos</span> x <span class="command">\cos</span> y - <span class="command">\sin</span> x <span class="command">\sin</span> y</span><br><span class="line"><span class="command">\end</span><span class="special">&#123;</span>align<span class="special">&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>以下是几个三角恒等式：</p>
<script type="math/tex; mode=display">
\begin{align}
\sin \left(x+y\right)=\sin x \cos y + \cos x \sin y\\
\cos \left(x+y\right)=\cos x \cos y - \sin x \sin y
\end{align}
</script>]]>
    
    </summary>
    
      <category term="game" scheme="http://ioschen.com/tags/game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[writer]]></title>
    <link href="http://ioschen.com/2014/01/19/writer/"/>
    <id>http://ioschen.com/2014/01/19/writer/</id>
    <published>2014-01-19T01:35:02.000Z</published>
    <updated>2014-01-19T09:00:57.000Z</updated>
    <content type="html"><![CDATA[<p>#HTML设置属性,配合Markdown</p>
<p>##字体大小和色彩等<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">size</span>=<span class="value">20</span> <span class="attribute">color</span>=<span class="value">red</span>&gt;</span>文字四大行<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<font size="20" color="red">文字四大行</font>

<p>##字体背景色和空格<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">##<span class="title">&lt;span style="background-color: #ff6600;"&gt;</span>你的文字<span class="title">&lt;/span&gt;</span></span></span><br><span class="line"> 前面加<span class="preprocessor">#等markdown语法也可以用</span></span><br><span class="line"> &amp;nbsp;是空格</span><br><span class="line"> 下面这个做排版的标题很好,颜色自己选择</span><br><span class="line"> <span class="preprocessor">##<span class="title">&lt;span style="background-color: #ff6600;"&gt;</span>你的文字&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="title">&lt;/span&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>##<span style="background-color: #ff6600;">你的文字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>##添加音频</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">embed</span> <span class="attribute">src</span>=<span class="value">"http://www.xiami.com/widget/0_3515679/singlePlayer.swf"</span> <span class="attribute">type</span>=<span class="value">"application/x-shockwave-flash"</span> <span class="attribute">width</span>=<span class="value">"257"</span> <span class="attribute">height</span>=<span class="value">"33"</span> <span class="attribute">wmode</span>=<span class="value">"transparent"</span>&gt;</span><span class="tag">&lt;/<span class="title">embed</span>&gt;</span></span><br></pre></td></tr></table></figure>
<embed src="http://www.xiami.com/widget/0_3515679/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent">


<p>##添加视频<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">height</span>=<span class="value">498</span> <span class="attribute">width</span>=<span class="value">510</span> <span class="attribute">src</span>=<span class="value">"http://player.youku.com/embed/XMjI2MjU3MDMy"</span>  <span class="attribute">frameborder</span>=<span class="value">0</span> <span class="attribute">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="title">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMjI2MjU3MDMy" frameborder="0" allowfullscreen></iframe>
]]></content>
    <summary type="html">
    <![CDATA[<p>#HTML设置属性,配合Markdown</p>
<p>##字体大小和色彩等<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br]]>
    </summary>
    
      <category term="hexo" scheme="http://ioschen.com/tags/hexo/"/>
    
  </entry>
  
</feed>
