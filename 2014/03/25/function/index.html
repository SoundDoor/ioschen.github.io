<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>函数 | 忠良</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="书接上文有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 
（宏是用来生成代码，不是用来完成实际操作的）
定义新函数定义方式函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：
123（defun name （parameter*）	&quot;Opti">
<meta property="og:type" content="article">
<meta property="og:title" content="函数">
<meta property="og:url" content="https://ioschen.com/2014/03/25/function/index.html">
<meta property="og:site_name" content="忠良">
<meta property="og:description" content="书接上文有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 
（宏是用来生成代码，不是用来完成实际操作的）
定义新函数定义方式函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：
123（defun name （parameter*）	&quot;Opti">
<meta property="og:updated_time" content="2014-03-27T08:02:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="函数">
<meta name="twitter:description" content="书接上文有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 
（宏是用来生成代码，不是用来完成实际操作的）
定义新函数定义方式函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：
123（defun name （parameter*）	&quot;Opti">
  
    <link rel="alternative" href="/atom.xml" title="忠良" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars2.githubusercontent.com/u/5210832?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">忠良</a></h1>
		</hgroup>

		
		<p class="header-subtitle">得良哥一诺，如得黄金万两</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/APP/" style="font-size: 10px;">APP</a> <a href="/tags/Common-lisp/" style="font-size: 20px;">Common lisp</a> <a href="/tags/Mac软件/" style="font-size: 15px;">Mac软件</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/freebsd/" style="font-size: 10px;">freebsd</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/ios/" style="font-size: 15px;">ios</a> <a href="/tags/ruby/" style="font-size: 10px;">ruby</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/swift-ssid/" style="font-size: 10px;">swift ssid</a> <a href="/tags/人性/" style="font-size: 10px;">人性</a> <a href="/tags/技巧/" style="font-size: 10px;">技巧</a> <a href="/tags/灵感/" style="font-size: 10px;">灵感</a> <a href="/tags/资料分享/" style="font-size: 10px;">资料分享</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://sspai.com/">少数派</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.apple.com/swift/">苹果开发者</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.yinxiang.com/">印象笔记的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.apple.com/swift/">V2EX</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://swift.org/">Swift官网</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">忠良</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars2.githubusercontent.com/u/5210832?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">忠良</h1>
			</hgroup>
			
			<p class="header-subtitle">得良哥一诺，如得黄金万两</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-function" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/03/25/function/" class="article-date">
  	<time datetime="2014-03-25T12:57:35.000Z" itemprop="datePublished">2014-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      函数
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Common-lisp/">Common lisp</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="书接上文">书接上文</h1><p>有了语法和语义规则以后，所有lisp程序的三个最基本组成部分就是函数，变量和宏。一开始数据库建立就全部使用了，现在开始详细学习，首先学习函数，和其它语言一样，函数提供了用于抽象和功能化的基本方法 </p>
<p>（宏是用来生成代码，不是用来完成实际操作的）</p>
<h1 id="定义新函数">定义新函数</h1><h2 id="定义方式">定义方式</h2><p>函数一般使用DEFUN宏来定义。DEFUN的结构看起来像这样：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（defun <span class="keyword">name</span> （<span class="type">parameter</span>*）</span><br><span class="line">	<span class="string">"Optional documentating string."</span></span><br><span class="line">	body-<span class="keyword">form</span>）</span><br></pre></td></tr></table></figure>
<h2 id="命名方式">命名方式</h2><p>任何符号都可以用作函数名。通常函数名包含字典字符和连字符。但是在特定的命名约定里，其它字符也允许使用。列如，将值得一种类型转换成另一种函数有时会在名字中使用-&gt;</p>
<p>一个将字符串转换成微件（widget）的函数可能叫做string-&gt;widget  最重要的一个命名约定是用连字符而不是下划线或者内部大小写</p>
<p>因此是a-b而不是a_b或者aB</p>
<h2 id="定义参数">定义参数</h2><p>一个函数的形参列表定义了一些变量，将用来保存函数在调用时所传递的实参。如果函数是不带有实参，则该列表就是空得，写成（）。不同种类的形参分别负责处理必要的，可选的，多重的以及关键字实参。</p>
<h2 id="参数说明">参数说明</h2><p>如果一个字符串紧跟在形参列表之后，那么它应该就是一个用来描述函数用途的文档字符串。当定义函数时，该文档字符串将被关联到函数名上，并且以后可以通过DOCUMENTATION函数来获取</p>
<h2 id="最后总结">最后总结</h2><p>一个DEFUN的主体可由任意数量的lisp表达式所构成，他们将在函数被调用时依次求值，而最后一个表达式的值将被作为整个函数的值返回，另外RETURN-FROM特殊操作符可用于从函数的任何位置立即返回。</p>
<p>一开始学习的时候写的hello-world，形式如下</p>
<p><code>（defun hello-world () (format t &quot;hello, world&quot;)）</code></p>
<p>分析如下</p>
<ol>
<li>名字是hello-world</li>
<li>形式列表为空，因此不接受任何参数</li>
<li>没有文档字符串</li>
<li>函数体由一个表达式所构成（format t “hello，world”）</li>
</ol>
<p>另一个列子</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> verbose-sum <span class="list">(<span class="keyword">x</span> y)</span></span><br><span class="line">      <span class="string">"Sum any two numbers after printing a message."</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"Summing ~d and ~d.~%"</span> x y)</span></span><br><span class="line">      <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这个函数称为verbose-sum 接受两个实参分别为形参x和y一一对应并且带有一个文档字符串，以及一个由两个表达式所组成的主体。有“+”调用所返回的值将成为verbose-sum的返回值。</p>
<h1 id="函数形参列表">函数形参列表</h1><p>函数名和文档字符串差不多了，现在了解形参列表</p>
<p>形参列表的基本用途是为了声明一些变量用来接收传递给函数的实参，当形参列表是一个由变量名所组成的简单列表时，如同在verbose-sum里那样，这些形参叫必要形参。当函数调用时候，必须为每个必要形参都提供一个实参。每一个形参被绑定到对应的实参上。</p>
<p>但是，形参列表也给了更灵活的方法将函数调用实参映射到函数形参。除了必要形参以外，一个函数还可以有可选形参，或者也可以用单一形参绑定到含有任意多个额外参数的列表上。最后，参数还可以通过关键字而不是位置来映射到形参上，这样Commom lisp的形参列表对于集中常见的编码问题提供了一种便利的解决方案。</p>
<h1 id="可选形参">可选形参</h1><h2 id="定义">定义</h2><p>为了定义一个可选形参的函数，在必要形参的名字后放置符号&amp;optional后接可选形参的名字</p>
<h2 id="列子">列子</h2><p><code>（defun foo （a b &amp;optional c d）(list a b c d)）</code></p>
<p>当函数被调用时，实参被首先绑定到必要形参上，在所有必要形参都被赋值以后，如果还有任何实参剩余，它们的值被赋给可选形参。如果实参在所有可选形参被赋值前用完了，那么其余的可选形参将自动绑定到NIL上。这样，列子定义的函数会给出下面的结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 NIL NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3 4） -&gt; （1 2 3 4）</li>
</ul>
<p>lisp任然可以确保适当的数量的实参被传递给函数——在本列中是2-4个。而如果函数用太少或太多的参数来调用的话，会报错。</p>
<p>当然，我们经常想要一个不同于NIL的默认值，这时可以通过将新参名替换成一个含有名字跟一个表达式的列表来制定该默认值。只有在调用者没有传递足够的实参来为可选形参提供值得时候，这个表达式才会被求值，通常情况只是简单的提供一个值作为表达式：</p>
<p><code>(defun foo (a &amp;optional（b 10)) (list  a b))</code></p>
<p>上述函数要求将一个实参绑定到形参a上，当存在第二个实参时，第二个形参b将使用其值，否则使用10</p>
<ul>
<li>（foo 1 2） -&gt; （1 2）</li>
<li>（foo 1）-&gt; （1 10）</li>
</ul>
<p>不过，有时可能需要更灵活选择默认值，比如可能想要基于其他形参来计算默认值，默认值表达式可以引用早先出现在形参列表中的形参。如果要编写一个返回矩形的某种表示的函数，并且想要使它可以特别的产生正方形，那么可以使用一个像这样的形参列表。</p>
<p><code>(defun make-rectangle (width &amp;optional (height width)) ...)</code><br>除非明确知道否则这将导致height形参带有和width形参相同的值。</p>
<p>有时，有必要去了解一个可选形参的值究竟是被调用者明确指定还是使用了默认值。除了代码检查是否默认值（假如调用者碰巧显式传递了默认值，那么这样做终归是无效的）以外，还可以通过在形参标示符的默认值表达式之后添加另一个变量名来做到这点。该变量将在调用者实际为该形参提供了一个实参是被绑定到真值，否则为NIL 通常约定，这种变量的名字与对应的真实形参相同，但是带有一个 -supplied-p后缀<br>列如:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">a</span> b <span class="keyword">&amp;optional</span> <span class="list">(<span class="keyword">c</span> <span class="number">3</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">lisp</span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这将给出类似下面结果</p>
<ul>
<li>（foo 1 2） -&gt; （1 2 3 NIL）</li>
<li>（foo 1 2 3） -&gt; （1 2 3 T）</li>
<li>（foo 1 2 4） -&gt; （1 2 4 T）</li>
</ul>
<h1 id="剩余形参">剩余形参</h1><p>可选形参仅适用于一些较为分散并且不能确定调用者是否会提供值得形参。但某些函数需要接收可变数量的实参，比如前面已经出现过的内置函数。FORMAT有两个必要实参，即流合控制串。单在这两个之后，它还需要一组可变数量的实参，这取决于控制串需要插入多少个值。</p>
<p>+函数也接受可变数量的实参——没有特别的理由限制它只能在两个数之间相加，它可以对任意数量的值做加法运算（它甚至可以没有实参，此时返回0——加法的底数）。下面这些都是这两个函数的合法调用:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, world"</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"hello, ~a"</span> name)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">format</span></span> t <span class="string">"x: ~d y: ~d"</span> x y)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>很明显，也可以通过简单给它一些可选形参来写出接受可变数量实参的函数，但这样将会非常麻烦，光是写形参列表就已经够麻烦了，何况还要在函数体中处理所有这些形参。为了做好这件事，还不得不使用一个合法函数调用所能够传递的那么多的可选形参。这一具体数量与具体实现相关，但可以保证至少有50个。在当前所有实现中，它的最大值范围从4096到536870911</p>
<p>相反，Lisp允许在符合&amp;rest之后<em>包括</em>一揽子形参。如果函数带有&amp;rest形参，那么任何满足了必要可选形参之后其余所有实参就将被收集到一个列表里成为该&amp;rest形参的值。这样，FORMAT和+的形参列表可能看起来会是这样:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> format <span class="list">(<span class="keyword">stream</span> string <span class="keyword">&amp;rest</span> values)</span> ...)</span></span><br><span class="line"><span class="list">(<span class="keyword">defun</span> + <span class="list">(<span class="keyword">&amp;rest</span> nmbers)</span> ...)</span></span><br></pre></td></tr></table></figure>
<h1 id="关键字形参">关键字形参</h1><p>如果我想给第四个形参提供值，其余不给，怎么办呢，关键字形参就起作用了。（这个没有描述清楚）</p>
<p>如果用可选形参的话。如果给第四个可选形参传递一个显式值，就会导致前面三个可选形参对于调用者来说变成了必要形参。</p>
<p>定义：在任何必要的&amp;optional和&amp;rest形参之后，可以加上符号&amp;key以及任意数量的关键字形参标示符，后者的格式类似于可选形参标示符。下面就是一个只有关键字形参的函数:</p>
<p><code>(defun foo (&amp;key a b c) (list a b c))</code></p>
<p>当调用这个函数时，每一个关键字形参将绑定到紧跟在同名键字后面的那个值上，如前面所说，关键字以冒号开始的名字，并且他们被自动定义为自求值常量。</p>
<p>如果一个给定的关键字没有出现在实参列表中，那么对应的形参将被赋予其默认值，如同可选形参那样。因为关键字实参带有标签，所以他们在必要实参之后可按任意顺序进行传递。例如foo可以用下列形式调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">foo</span>)</span>  -&gt; <span class="list">(<span class="keyword">NIL</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:c</span> <span class="number">1</span>)</span> -&gt; <span class="list">(<span class="keyword">NIL</span> NIL <span class="number">1</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> NIL <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:b</span> <span class="number">2</span> <span class="keyword">:c</span> <span class="number">3</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">3</span> <span class="keyword">:b</span> <span class="number">2</span>)</span> -&gt; <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br></pre></td></tr></table></figure>
<p>如同可选形参那样，关键字形参也可以提供一个默认值形式以及一个supplied-p变量名。</p>
<p>在关键字形参和可选形参中，这个默认值形式都可以引用那些早先出现在形参列表中的形参。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="keyword">a</span> <span class="number">0</span>)</span> <span class="list">(<span class="keyword">b</span> <span class="number">0</span> b-supplied-p)</span> <span class="list">(<span class="keyword">c</span> <span class="list">(<span class="keyword">+</span> a b)</span>)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword">list</span> a b c b-supplied-p)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> NIL)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span>)</span>  -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt;<span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br><span class="line"><span class="list">(<span class="keyword">foo</span> <span class="keyword">:a</span> <span class="number">2</span> <span class="keyword">:b</span> <span class="number">1</span> <span class="keyword">:c</span> <span class="number">4</span>)</span> -&gt; <span class="list">(<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> T)</span></span><br></pre></td></tr></table></figure>
<p>同样，出于某种原因想让调用者用来指定形参的关键字不同于实际形参名，那么可以将形参名替换成一个列表，令其含有调用函数时使用的关键字以及用作形参的名字，比如说下面这个foo的定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">&amp;key</span> <span class="list">(<span class="list">(<span class="attribute">:apple</span> a)</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:box</span> b)</span> <span class="number">0</span>)</span> <span class="list">(<span class="list">(<span class="attribute">:charlie</span> c)</span> <span class="number">0</span> c-supplied-p)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">list</span></span> a b c c-supplied-p)</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以让调用者这样调用它:</p>
<p><code>(foo :apple 10 :box 20 :charlie 30)  -&gt; (10 20 30 T)</code></p>
<p>这种风格在想要完全将函数的公共API与其内部细节相隔离时特别有用，通常是因为想要在内部使用段变量名，而不是API中的描述性关键字。不过该特性不常被用到。</p>
<h1 id="混合不同的形参类型">混合不同的形参类型</h1><p>四个混合使用，多种混合使用时候：必须以这样的顺序声明:首先是<em>必要形参</em> 其次是<em>可选形参</em> 再次是<em>剩余形参</em> 最后才是<em>关键字形参</em>。但在使用多种类型形参的函数中，一般情况是将必要和另外一种类型形参组合使用，或者可能是组合&amp;optional形参和&amp;rest形参。其它两种组合方式，无论是&amp;optional形参还是&amp;rest形参，当与&amp;key形参组合使用时，都可能导致某种奇怪的行为。</p>
<p>将&amp;optional形参和&amp;key形参组合使用时将产生非常奇怪的结果，因此也许应该避免将他们一起使用，问题出现在如果调用者没有为所有可选形参提供值时，那么没有得到值得可选形参将吃掉原本用于关键字形参的关键字和值。列如，下面这个函数很不明智地混合了&amp;optional形参和&amp;key形参:</p>
<p><code>（defun foo （x &amp;optional y &amp;key z）（list x y z））</code></p>
<p>如果像这样调用的话，就没问题:</p>
<p><code>(foo 1) -&gt; (1 nil nil)</code></p>
<p>但是这样的话将报错:</p>
<p><code>(foo 1 :z 3) -&gt; ERROR</code></p>
<p>这是因为关键字:z被作为一个值填入到可选的y形参中了，只留下了参数3被处理。在这里，Lisp期待一个成对的关键字/值，或者什么也没有，否则就会报错，也许更坏的是，如果该函数带有两个&amp;optional形参，上面最后一个调用将导致值:z和3分别被绑定到两个&amp;optional形参上，而&amp;key形参z将得到默认值NIL 而不声明缺失了东西。</p>
<p>一般而言，如果正在编写一个同时使用&amp;optional形参和&amp;key形参的函数，可能就应该将它变成全部使用&amp;key形参的形式——他们更灵活，并且总会可以在不破坏该函数的已有调用的情况下添加新的关键字形参。也可以移除关键字形参，只要没人在使用他们，一般而言，使用关键字形参就uhui使代码相对易于维护和拓展——如果需要为函数添加一些需要用到新参数的新行为，就可以直接添加关键字形参，而无需修改甚至重新编译任何调用该函数的已有代码。</p>
<p>虽然可以安全的组合使用&amp;rest形参和&amp;key形参    ，但其行为初看起来可能会有一点奇怪。正常的来讲，无论是&amp;rest还是&amp;key出现在形参列表中，都将导致所有出现在必要形参和&amp;optional形参之后的那些值被特别处理——要么作为&amp;rest和&amp;key同时出现在形参列表中，那么两件事都会发生——所有剩余的值，包括关键字本身，都将被收集到一个列表里，然后绑定到&amp;rest形参上，而适当的值，也会同时被绑定到&amp;key形参上，因此给定下列函数:</p>
<p><code>(defun foo (&amp;rest rest &amp;key a b c) (list rest a b c))</code></p>
<p>将会得到如下结果:</p>
<p><code>(foo :a 1 :b 2 :c 3) -&gt; ((:A 1 :B 2 :C 3) 1 2 3)</code></p>
<h1 id="函数返回值">函数返回值</h1><p>目前所有函数都使用了默认的返回值行为，既<em>最后一个表达式的值</em>被作为整个函数的<strong>返回值</strong>。这是从函数中返回值得最常见方式。</p>
<p>有些时候，尤其是想要从嵌套的控制结构中脱身时，如果有办法从函数中间返回，那就是非常便利的。在这种情况下，你可以使用RETURN-FROM特殊操作符，它能够立即以任何职从函数中间返回。<del>RETURN-FROM事实上不只用于函数，还可以用来从一个由BLOCK特殊操作符所定义的代码块中返回。</del>不过DEFUN会自动将其整个函数体包装在一个与其函数同名的代码块中，因此，对一个带有当前函数名和想要返回的值的RETURN-FROM是一个特殊操作符，其第一个“参数”是它想要返回的代码块名。该名字不被求值，因此无需引用。</p>
<p>下面这个函数使用了嵌套循环来发现第一个数对——每个都小于10，并且其成绩大于函数的参数，它使用RETURN-FROM在发现后立即返回该数对;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">defun</span> foo <span class="list">(<span class="keyword">n</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">i</span> <span class="number">10</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword"><span class="built_in">dotimes</span></span> <span class="list">(<span class="keyword">j</span> <span class="number">10</span>)</span></span><br><span class="line">			<span class="list">(<span class="keyword"><span class="built_in">when</span></span> <span class="list">(<span class="keyword"><span class="built_in">&gt;</span></span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> i j)</span> n)</span></span><br><span class="line">				<span class="list">(<span class="keyword">return-from</span> foo <span class="list">(<span class="keyword"><span class="built_in">list</span></span> i j)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>必须承认的是，不得不指定正在返回的函数名多少会有些不便——比如改变了函数的名字，就需要同时改变RETURN-FROM中所使用的名字，但是在事实上，显式的RETURN-FROM调用在Lisp中出现的频率远小于return语句在源自C的语言里出现的频率，因为所有的Lisp表达式，包括诸如循环和条件语句这样的控制结构，都会求值得到一个值，因此在实践中这不是什么问题。</p>
<h1 id="作为数据的函数————高阶函数">作为数据的函数————高阶函数</h1><p>使用函数主要方式—-<strong>通过名字来调用</strong> 但有时将函数作为数据看待也是很有用的。列如，可以将一个函数作为参数传递给另一个函数，从而能写出一个通用的排序函数，允许调用者提供一个比较任意两元素的函数，这样通用的底层算法就可以跟许多不同的比较函数配合使用了。</p>
<p>类似的，回调函数（callback）和钩子（hook）也需要能够保存代码引用便于以后运行。由于函数已经是一种对代码比特进行抽象的标准方式，因此允许把函数视为数据也是合理的。</p>
<p>在Lisp中，函数只是另一种类型的对象，在用DEFUN定义一个函数时，实际上做了两件事：创建一个新的函数对象以及赋予其一个名字，前面说过，也可以使用LAMBDA表达式来创建一个函数而无需为其指定一个名字。一个函数对象的实际表示，无论是有名的还是匿名的，都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。只需要知道如何保持它们以及需要时如何调用它们。</p>
<p>特殊操作符FUNCTION提供了用来获取一个函数对象的方法，它接受单一实参并返回与该参数同名的函数。这个名字是不被引用的。因此如果一个函数foo的定义如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? (defun foo (x) (* x x))</span><br><span class="line">FOO</span><br><span class="line">就可以得到如下的函数对象</span><br><span class="line">? (<span class="function"><span class="keyword">function</span></span> foo)</span><br><span class="line">#&lt;Compiled-<span class="function"><span class="keyword">function</span></span> FOO #x302000F99E4F&gt;</span><br></pre></td></tr></table></figure>
<p>事实上前面已经用过FUNCTION了，但是它以伪装的形式出现的，前面用到的#’语法就是FUNCTION的语法糖，正如’是QUOTE的语法糖一样。因此也可以像这样得到foo的函数对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="preprocessor">#'foo</span></span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;Compiled-function FOO #x302000ECB11F&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一旦得到了函数对象，就只剩下一件事可做了——调用它。Common Lisp提供了两个函数用来调用函数: FUNCALL和APPLY 它们的区别仅在于如何获取传递给函数的实参。</p>
<p>FUNCALL用于在编写代码时确切知道传递给函数多少实参时，FUNCALL的第一个实参是被调用的函数对象，其余的实参被传递到该函数中。因此，下面两个表达式是等价的:</p>
<p><code>（foo 1 2 3）= （funcall #&#39;foo 1 2 3）</code></p>
<p>不过，用FUNCALL来调用一个写代码时名字已知的函数毫无意义。事实上，前面的两个表达式很可能被编译成相同的机器指令。</p>
<p>下面这个函数演示了FUNCALL的另一个更有建设性的用法。它接受一个函数对象作为实参，并使用实参函数在min和max之间以step为步长的返回值绘制一个简单的ASCII式柱状图:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L-USER&gt; <span class="list">(<span class="keyword">defun</span> plot <span class="list">(<span class="keyword">fn</span> min max step)</span></span><br><span class="line">	   <span class="list">(<span class="keyword">loop</span> for i from min to max by step do</span><br><span class="line">		<span class="list">(<span class="keyword">loop</span> repeat <span class="list">(<span class="keyword">funcall</span> fn i)</span> do <span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"*"</span>)</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"~%"</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>FUNCALL表达式在每个i值上计算函数的值，内层LOOP循环使用计算得到的值来决定向标准输出打印多少星号。</p>
<p>请注意，不需要使用FUNCTION或#‘来得到fn的函数值，因为它是作为函数对象的变量的值，所以你需要它解释成一个变量。可以用任何接受单一数值实参的函数来调用plot，列如内置的函数EXP，它返回以e为底以其实参为指数的值。</p>
<pre><code>(plot <span class="comment">#'exp 0 4 1/2)</span>
<span class="keyword">*</span>
<span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
NIL
</code></pre><p>然而，当实参列表只在运行期已知时，FUNCALL的表现不佳，列如，为了再次调用plot函数，假设你已有一个列表，其包括一个函数对象，一个最小值和一个最大值以及一个步长。换句话说，这个列表包含了你想要作为实参传给plot的所有值，假设这个列表保存在变量plot-data中，可以像这样用列表中的值来调用plot:</p>
<p><code>(plot (first plot-data) (second plot-data) (third plot-data) (fourth plot-data))</code></p>
<p>这样固然可以，但仅仅为了将实参传给plot而显式地将其解开，看起来相当不爽。</p>
<p>这样就需要APPLY的原因，和FUNCTION一样，APPLY的第一个参数是一个函数对象，但在这个函数对象之后，它期待一个列表而非单独的实参。它将函数应用在列表中的值上，这就使你可以写出下面的替代版本:</p>
<p><code>(apply #&#39;plot plot-data)</code></p>
<p>更方便的是，APPLY还接受“孤立”（loose）的实参，只要最后一个参数是个列表，因此，加入plot-data只含有最小，最大和步长值，那么你仍然可以像这样来使用APPLY在该范围上绘制EXP函数:</p>
<p><code>(apply #&#39;plot exp plot-data)</code></p>
<p>APPLY并不关心所用的函数是否接受&amp;optional &amp;rest 或&amp;key实参——由任何孤立实参和最后的列表所组合而成的实参列表必定是一个合法的实参列表，其对于该函数来说带有足够的实参用于所有必要形参和适当的关键字形参。</p>
<h1 id="匿名函数">匿名函数</h1><p>一开始编写或只是使用那些可以接受其它函数作为实参的函数，你就必然发现，有时不得不去定义和命名一个仅使用一次的函数，尤其是你可能从不用名字来调用它时，这会让人相当恼火。</p>
<p>觉得没必要用DEFUN来定义一个新函数时，可以使用一个LAMBDA表达式创建匿名的函数。前面讨论过，一个LAMBDA表达式形式如下:</p>
<p><code>(lambda (parameters) body)</code></p>
<p>可以将LAMBDA表达式视为一种特殊类型的函数名，其名字本身直接描述函数的用途，这就解释了为什么可以使用一个带有#’的LAMBDA表达式来代替一个函数名。</p>
<p><code>(funcall #&#39;(lambda (x y) (+ x y)) 2 3)  -&gt;5</code></p>
<p>甚至可以在一个函数调用表达式中将LAMBDA表达式用作函数名，由此一来，我们可以在需要时以更简洁方式来书写前面的FUNCALL表达式如下:</p>
<p><code>((lambda (x y) (+ x y)) 2 3) -&gt; 5</code></p>
<p>但是几乎没人这样做，它唯一的用途是来强调将LAMBDA表达式用在任何一个正常函数名可以出现的场合是合法的。</p>
<p>在需要传递一个作为实参的函数给另一个函数，并且需要传递的这个函数简单到可以内联表达时，匿名函数特别有用，列如，假设想要绘制函数2x 你可以定义下面的函数:</p>
<p><code>defun double (x) (* 2 x))</code></p>
<p>并随后将其传给plot</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'double 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">Nil</span><br></pre></td></tr></table></figure>
<p>但如果写成这样就会更简单和清晰:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(plot <span class="comment">#'(lambda (x) (* 2 x)) 0 10 1)</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>LAMBDA表达式的另一项重要用途是制作闭包（closure），即捕捉了其创建时环境信息的函数。前面也使用了一点闭包，但是要想深入了解闭包的工作原理和用途，更多地还是要从变量而非函数的角度去考察，下面在研究吧。</p>
<p><del>也可以不带前缀#’来使用一个LAMBDA表达式作为FUNCALL的参数</del></p>
<p><del>关于这个。。。</del></p>
<hr>
<a id="more"></a>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/03/26/variable/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          变量
        
      </div>
    </a>
  
  
    <a href="/2014/03/23/yufa/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">语法</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>





<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ioschen'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 忠良
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>